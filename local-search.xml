<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2022/02/24/HTTP/"/>
    <url>/2022/02/24/HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP（HyperText-Transfer-Protocol，超文本传输协议"><a href="#HTTP（HyperText-Transfer-Protocol，超文本传输协议" class="headerlink" title="HTTP（HyperText Transfer Protocol，超文本传输协议"></a>HTTP（HyperText Transfer Protocol，超文本传输协议</h2><blockquote><p>HTTP 是基于 TCP/IP 协议的应用层协议，用于客户端和服务器之间的通信<br>链路层，网络层，传输层，应用层</p></blockquote><h3 id="HTTP-报文组成部分"><a href="#HTTP-报文组成部分" class="headerlink" title="HTTP 报文组成部分"></a>HTTP 报文组成部分</h3><ul><li><p>请求报文</p><ul><li>请求行 <code>Request Method</code>,<code>Request URL</code></li><li>请求头 包含若干属性，key:value 值</li><li>空行</li><li>请求体</li></ul></li><li><p>响应报文</p><ul><li>状态行 <code>Request Version</code>,<code>Status Code及其描述</code></li><li>响应头 包含若干属性，key:value 值</li><li>空行</li><li>响应体</li></ul></li></ul><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><ul><li><p>缓存相关</p><ul><li><code>Cache-Control</code></li><li><code>Pragma</code></li><li><code>Expires</code>实体首部</li><li><code>Last-Modified</code>实体首部</li><li><code>If-Modified-Since</code></li><li><code>ETag</code></li><li><code>If-None-Match</code></li></ul></li><li><p>Cookie</p><ul><li><code>Cookie</code></li><li><code>Set-Cookie</code></li></ul></li><li><p>跨域</p><ul><li><code>Origin</code></li><li><code>Access-Control-Request-Method</code></li><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Max-Age</code></li><li><code>Access-Control-Allow-Credentials</code></li></ul></li><li><p>连接</p><ul><li><code>Connection</code>:keep-alive / close / upgrade</li><li><code>Referer</code>请求来源域</li><li><code>Origin</code>请求来源域<blockquote><p>这个单词是错的</p></blockquote></li><li><code>Host</code>服务器域名</li><li><code>Upgrade</code>:websocket<h4 id="HTTP-的响应状态码"><a href="#HTTP-的响应状态码" class="headerlink" title="HTTP 的响应状态码"></a>HTTP 的响应状态码</h4></li></ul></li></ul><p><code>1xx 请求收到</code>,</p><p><code>2xx 处理成功</code>,</p><p><code>3xx 重定向</code>,</p><p><code>4xx 处理发生错误，责任在客户端</code>,</p><p><code>5xx 处理发生错误，责任在服务端</code></p><h4 id="常见-code"><a href="#常见-code" class="headerlink" title="常见 code"></a>常见 code</h4><ul><li><p>100 继续发送</p></li><li><p>101 协议升级</p></li><li><p>200 OK</p></li><li><p>301 永久性重定向，资源已经分配了新的 URl</p></li><li><p>302 临时重定向</p></li><li><p>303 表示资源存在着另一个 URL，应使用 GET 方法获取资源</p><blockquote><p>对于 301/302/303 响应，几乎所有浏览器都会删除报文主体并自动用 GET 重新请求</p></blockquote></li><li><p>304 资源未修改</p></li><li></li><li><p>400 Bad Request请求报文语法错误</p></li><li><p>401 Unauthorized需要认证</p></li><li><p>403 Forbidden禁止访问</p></li><li><p>404 Not Found</p></li><li><p>405 不允许该请求方法</p></li><li><p>408 请求超时</p></li><li><p>500 服务器错误</p></li><li><p>503 服务器过载</p></li><li><p>505 不支持该版本HTTP协议</p></li></ul><h2 id="HTTP-发展"><a href="#HTTP-发展" class="headerlink" title="HTTP 发展"></a>HTTP 发展</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><ul><li><p><code>GET</code></p></li><li><p>只能且直接返回html</p><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3></li><li><p>串行连接：每次通信完后断开TCP通道，每个新请求都需要建立新的连接</p></li><li><p><code>GET</code></p><ol><li>请求放在参数放在URL地址后</li><li>刷新无副作用</li><li>能保存书签，会被浏览器缓存，加入历史记录</li><li>编码urlencoded</li><li>浏览器或者服务器会对URL长度做限制</li></ol></li><li><p><code>POST</code></p><ol><li>请求参数放在body中</li><li>刷新提示再次提交？</li><li>不缓存不保存不记录</li><li>数据类型无限制</li></ol></li><li><p><code>HEAD</code> 与 get 相同的请求，不过只请求头部，获取其中“关于该资源的信息”(元信息或称元数据)</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3></li><li><p>持久连接：一定时间内，只要不是主动断开则保持连接（keep-alive设定这个时长），但是下一个请求必须等待上一个请求响应完成（线头阻塞）</p></li><li><p>管线化持久连接：在同一条长连接上发出连续的请求，而不用等待应答返回,只能用于<code>GET</code>,<code>HEAD</code>,<code>PUT</code>,<code>DELETE</code>请求</p></li><li><p><code>OPTIONS</code>询问获取当前资源所支持的方法</p></li><li><p><code>PUT</code>从客户端向服务器传送新文件</p></li><li><p><code>PATCH</code>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p></li><li><p><code>DELETE</code>请求服务器删除指定文件</p></li><li><p><code>TRACE</code>回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p><code>CONNECT</code> HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p></li></ul><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><ul><li>2009 年推出，试验性</li><li>位于HTTP与SSl之间，是对HTTP的增强</li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>多路复用：通过一个 TCP 连接，可以无限制处理多个 HTTP 请求。</p></li><li><p>赋予请求优先级：给请求逐个分配优先级顺序。可以解决在发送多个请求时，因带宽低而导致响应变慢的问题。</p></li><li><p>压缩 HTTP 头部：压缩方式：DELEFT</p></li><li><p>服务端推送</p></li><li><p>SPDY 位于 HTTP 下，TCP 和 SSL 之上，可以兼容老版本 http 同时使用可用的 ssl 功能</p></li><li><p>SPDY 强制使用 SSL</p></li></ol><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><ul><li><p>2015 年发布，基于 SPDY 协议</p></li><li><p>http/1.x 是一个超文本协议，而 http2 是一个二进制协议</p></li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>二进制分帧</p><p> 当客户端同时向服务端发起多个请求，那么这些请求会被分解成一一个的帧，每个帧都会在一个 TCP 链路中无序的传输，当帧到达服务端之后，就可以根据 <code>Stream Identifier</code> 来重新组合得到完整的请求。</p></li><li><p>头部压缩</p><ul><li>请求和响应首部压缩</li><li><code>HPACK</code> 算法，客户端和服务器建立字典（首部表）重复头部不用再发送</li></ul></li><li><p>服务端推送</p></li><li><p>多路复用</p><ul><li>同域名的通信都在单个连接上完成(只占用一个 tcp 连接</li><li>单连接可以承受任意数量的双向数据流</li></ul></li></ol><h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><ul><li>http3使用新的UDP协议<code>QUIC</code>代替TCP</li><li>解决http2时代丢包阻塞</li><li>切换网络时的连接保持（快速重启会话）</li><li>加密传输</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="TLS-SSl"><a href="#TLS-SSl" class="headerlink" title="TLS/SSl"></a>TLS/SSl</h3><ul><li><p>传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p></li><li><p>TLS协议的特点是与应用层协议（HTTP，FTP）无耦合，应用层协议能透明运行在TLS协议上层（HTTP与TCP之间）</p></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>【非对称加密】</p><p>只有使用私钥才能解开公钥加密</p></li><li><p>【摘要算法】</p><p>输出固定长度的数据，用来计算数据指纹，比如SHA256</p></li><li><p>【数字签名】</p><p>使用私钥对摘要算法得出的指纹加密</p><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3></li><li><p>证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号，摘要算法等信息的明文</p></li><li><p>CA使用CA私钥对证书明文摘要算法后得出的指纹进行加密得到签名</p></li></ul><h3 id="浏览器验证证书合法性"><a href="#浏览器验证证书合法性" class="headerlink" title="浏览器验证证书合法性"></a>浏览器验证证书合法性</h3><ol><li>从操作系统中找到相应的<code>CA机构证书</code></li><li>使用<code>CA证书</code>的公钥<code>解密``站点证书</code>的<code>签名</code>得到校验码1</li><li>使用证书制定的摘要算法对<code>站点证书</code>明文计算得到校验码2</li><li>比较两个校验码相同则说明证书没被篡改</li><li>后面就开始查看证书是否在有效期，是否对应当前域名，是否在吊销列表中等</li></ol><h3 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h3><ol><li>用户访问:443,发送客户端支持的加密算法列表和随机数<code>Random_C</code></li><li>服务器根据支持的贾母算法计算并返回证书和随机数<code>Random_S</code></li><li>用户浏览器使用 <em><strong>CA公钥</strong></em> 打开并验证证书的合法性得到证书中的 <em><strong>服务器公钥</strong></em></li><li>用户生成生新的随机数<code>Premaster secret</code>，并使用 <em><strong>服务器公钥</strong></em> 加密发送给服务器</li><li>服务器使用自己的 <em><strong>服务器私钥</strong></em> 解密，得到 <code>Premaster secret</code></li><li>此后双方使用同样的加密算法对三个随机数进行计算得到对称的密钥<code>enc_key</code></li><li>至此双方得到了对称加密密钥,之后的连接都只使用对称加密</li></ol><h2 id="TCP握手"><a href="#TCP握手" class="headerlink" title="TCP握手"></a>TCP握手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>为了确保通信双方收发能力正常</li><li>指定自己的初始化序列号，为后面的可靠传送做准备</li><li>过程：<ul><li>第一次握手：<br>客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>ISN(c)</code>。此时客户端处于 <code>SYN_Send</code> 状态。</li><li>第二次握手：<br>服务器收到客户端的 <code>SYN</code> 报文之后，会以自己的 <code>SYN</code> 报文作为应答，并且也是指定了自己的初始化序列号 <code>ISN(s)</code>，同时会把客户端的 <code>ISN(c) + 1</code> 作为 <code>ACK(确认字符)</code> 的值，表示自己已经收到了客户端的 <code>SYN</code>，此时服务器处于 <code>SYN_REVD</code> 的状态。</li><li>第三次握手：<br>客户端收到 <code>SYN</code> 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 <code>ISN(s) + 1</code> 作为 <code>ACK</code> 的值，表示已经收到了服务端的 <code>SYN</code> 报文，此时客户端处于 <code>establised</code> 状态。<blockquote><p>同时该tcp栈已经允许请求数据，例如可以同时带上一个GET请求</p></blockquote></li><li>服务器收到 ACK 报文之后，也处于 <code>establised</code> 状态，此时，双方以建立起了链接。</li></ul></li></ol><blockquote><p>半连接队列：在TCP协议三次握手的连接过程中，如果一个用户向服务器发送了SYN报文，服务器又发出 SYN+ACK 应答报文后未收到客户端的 ACK 报文回应，这种情况下服务器端会再次发送SYN+ACK给客户端，并等待一段时间后丢弃这个未完成的连接，这段时间的长度称为SYN Timeout，一般来说这个时间是分钟级。</p></blockquote><blockquote><p>泛洪攻击：SYN 泛洪攻击通过发送大量的伪造 TCP 连接报文而造成大量的 TCP 半连接,服务器端将为了维护这样一个庞大的半连接列表而消耗非常多的资源。这样服务器端将忙于处理攻击者伪造的TCP连接请求而无法处理正常连接请求,甚至会导致堆栈的溢出崩溃。</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li>断开tcp连接</li><li>过程：<ul><li>第一次挥手：<br>客户端发送<code>FIN</code> 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li><li>第二次握手：<br>服务端收到 <code>FIN</code> 之后，会把客户端的序列号值 + 1 作为 <code>ACK</code> 报文的序列号值并发送给客户端，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code>状态。</li><li>第三次挥手：<br>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <code>FIN</code> 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态。</li><li>第四次挥手：<br>客户端收到 FIN 之后，也把服务端的序列号值 + 1 作为自己 <code>ACK</code> 报文的序列号值并发送给服务端,此时客户端处于 <code>TIME_WAIT</code> 状态。之后才会进入 <code>CLOSED</code> 状态</li><li>服务端收到 <code>ACK</code> 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ul></li></ol><blockquote><p><code>TIME_WAIT</code> 状态:<br>客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭,确保服务器是否已经收到了 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p></blockquote><blockquote><p>也可缩短为三次挥手，上述二三步骤合并，服务器同时回复ACK和FIN</p></blockquote><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><ul><li>websocket的出现解决了传统http请求只能由客户端发起的缺陷</li><li>http无法得知服务器连续的状态变化，只能靠轮询</li><li>ws构造函数就要传入<code>绝对URL</code>，且连接不能转发只能是直接连接</li><li>全双工，双向通信</li><li>服务端推送</li><li>持久连接</li><li>基于 TCP 传输，复用 HTTP 的握手通道</li><li>协议升级为ws<ol><li>客户端请求<div class="hljs code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> Upgrade<span class="hljs-symbol">Upgrade:</span> websocket</code></pre></div></li><li>服务端响应协议升级<div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">101</span> Switching Protocols</code></pre></div></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/02/24/Promise/"/>
    <url>/2022/02/24/Promise/</url>
    
    <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 对象用于处理异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>  解决回调地狱，使用统一的 API 接口处理异步任务</li><li>  链式调用</li><li>  返回值穿透（onFulfilled 不是 function 时，上一步的执行结果 value 将继续向后传递）</li><li>  错误冒泡（</li></ul><blockquote><p>回调地狱</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">//f2的执行需要等待f1的结果</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-function"><span class="hljs-title">f3</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-function"><span class="hljs-title">f4</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-function"><span class="hljs-title">f5</span>(<span class="hljs-params"></span>)</span>&#123;          ...        &#125;        ...      &#125;    &#125;  &#125;&#125;</code></pre></div><h2 id="Promise-对象有以下两个特点"><a href="#Promise-对象有以下两个特点" class="headerlink" title="Promise 对象有以下两个特点"></a>Promise 对象有以下两个特点</h2><ol><li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><ul><li>  为 Promise 实例添加状态改变时的回调函数</li><li>  then 方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数</li><li>  then 方法返回的是一个新的 Promise 实例,可以 then 方法后面再调用另一个 then 方法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">getJSON(<span class="hljs-string">&quot;/post/1.json&quot;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">post</span>) </span>&#123;<span class="hljs-keyword">return</span> getJSON(post.commentURL);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcA</span>(<span class="hljs-params">comments</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;resolved: &quot;</span>, comments);&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funcB</span>(<span class="hljs-params">err</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;rejected: &quot;</span>, err);&#125;);<span class="hljs-comment">// 第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</span></code></pre></div><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><ul><li><p>  指定发生错误时的回调函数</p></li><li><p>  Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</span><span class="hljs-comment">// bad</span>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-comment">// success</span>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<span class="hljs-comment">// error</span>&#125;);<span class="hljs-comment">// good</span>promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-comment">//cb</span><span class="hljs-comment">// success</span>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<span class="hljs-comment">// error</span>&#125;);</code></pre></div><blockquote><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应</p></blockquote><ul><li>  catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法</li></ul><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><ul><li><p>  finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p></li><li><p>  finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p></li></ul><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><ul><li>  Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</li></ul><p><code>const p = Promise.all([p1, p2, p3]);</code></p><ul><li>  p 的状态由 p1、p2、p3 决定，分成两种情况。</li></ul><ol><li><p>只有 p1、p2、p3 的状态都变成<code>fulfilled</code>，p 的状态才会变成<code>fulfilled</code>，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p></li><li><p>只要 p1、p2、p3 之中有一个被<code>rejected</code>，p 的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给 p 的回调函数</p></li></ol><blockquote><p>如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法</p></blockquote><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><code>const p = Promise.race([p1, p2, p3]);</code></p><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//example</span><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([fetch(<span class="hljs-string">&quot;/resource-that-may-take-a-while&quot;</span>),<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;request timeout&quot;</span>)), <span class="hljs-number">5000</span>);&#125;), <span class="hljs-comment">// 5s内请求不resolve则抛出错误</span>]);p.then(<span class="hljs-built_in">console</span>.log).catch(<span class="hljs-built_in">console</span>.error);</code></pre></div><p>###<del>promise.try()</del></p><p><del>不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它</del></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;  database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;)  .then(...)  .catch(...) <span class="hljs-comment">// promise错误</span>&#125; <span class="hljs-keyword">catch</span> (e) &#123; <span class="hljs-comment">// 同步错误</span>  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// try catch捕获同步错误</span><span class="hljs-comment">// 用promise.try改写</span><span class="hljs-built_in">Promise</span>.try(<span class="hljs-function">() =&gt;</span> database.users.get(&#123;<span class="hljs-attr">id</span>: userId&#125;))  .then(...)  .catch(...)</code></pre></div><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>  立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行</li></ul><blockquote><p>Promise.resolve()方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;three&quot;</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;two&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;one&quot;</span>);<span class="hljs-comment">// one</span><span class="hljs-comment">// two</span><span class="hljs-comment">// three</span></code></pre></div><ul><li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> thenable = &#123;<span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">resolve, reject</span>)</span> &#123;reject(<span class="hljs-string">&quot;出错了&quot;</span>);&#125;,&#125;;<span class="hljs-built_in">Promise</span>.reject(thenable).catch(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(e);&#125;);<span class="hljs-comment">// catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span></code></pre></div></li></ul><h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isComplex = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;function&quot;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>);<span class="hljs-comment">// 符合A+规范的promise</span><span class="hljs-comment">// promises-aplus-tests</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;<span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;pending&quot;</span>;<span class="hljs-built_in">this</span>.data = <span class="hljs-literal">null</span>;<span class="hljs-built_in">this</span>.onFulfilledCb = [];<span class="hljs-built_in">this</span>.onRejectedCd = [];<span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<span class="hljs-comment">//<span class="hljs-doctag">NOTE:</span> 处理异步，处理value也是个Promise</span><span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) <span class="hljs-keyword">return</span> value.then(resolve, reject);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;fulfilled&quot;</span>;<span class="hljs-built_in">this</span>.data = value;<span class="hljs-built_in">this</span>.onFulfilledCb.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(value));&#125;&#125;);&#125;;<span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<span class="hljs-built_in">this</span>.status = <span class="hljs-string">&quot;rejected&quot;</span>;<span class="hljs-built_in">this</span>.data = reason;<span class="hljs-built_in">this</span>.onRejectedCd.forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> cb(reason));&#125;&#125;);&#125;;<span class="hljs-keyword">try</span> &#123;executor(resolve, reject);&#125; <span class="hljs-keyword">catch</span> (e) &#123;reject(e);&#125;&#125;<span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value;onRejected =<span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span>? onRejected: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<span class="hljs-keyword">throw</span> err;  &#125;;<span class="hljs-keyword">let</span> promise2;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;pending&quot;</span>) &#123;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 计算then后的promise状态resolvePromise()</span>promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-built_in">this</span>.onFulfilledCb.push(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-built_in">this</span>.data);resolvePromise(x, promise2, resolve, reject);&#125; <span class="hljs-keyword">catch</span> (e) &#123;reject(e);&#125;&#125;);<span class="hljs-built_in">this</span>.onRejectedCd.push(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-built_in">this</span>.data);resolvePromise(x, promise2, resolve, reject);&#125; <span class="hljs-keyword">catch</span> (e) &#123;reject(e);&#125;&#125;);&#125;);&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 这里不用管promise状态了,交给构造函数处理,简写就好</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;fulfilled&quot;</span>) &#123;promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> onFulfilled(<span class="hljs-built_in">this</span>.data));&#125;);&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span></span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-string">&quot;rejected&quot;</span>) &#123;promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> onRejected(<span class="hljs-built_in">this</span>.data));&#125;);&#125;<span class="hljs-keyword">return</span> promise2;&#125;;<span class="hljs-comment">// 决定then执行后的状态，达成链式调用</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">x, promise2, resolve, reject</span>) </span>&#123;<span class="hljs-keyword">if</span> (x === promise2) &#123;<span class="hljs-comment">// 终止链式调用抛出循环引用报错</span>reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;cycle quotes detected&quot;</span>));&#125;<span class="hljs-keyword">if</span> (isComplex(x)) &#123;<span class="hljs-comment">// x是复杂类型/function</span><span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">let</span> then = x.then;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-comment">// x是promise</span>then.call(x,(v) =&gt; &#123;<span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;flag = <span class="hljs-literal">true</span>;resolvePromise(v, promise2, resolve, reject);&#125;,(r) =&gt; &#123;<span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;flag = <span class="hljs-literal">true</span>;reject(r);&#125;);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// x是obj</span>resolve(x);&#125;&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span>;flag = <span class="hljs-literal">true</span>;reject(e);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// x是值</span>resolve(x);&#125;&#125;<span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> resolve(value));&#125;;<span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(reason));&#125;;<span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected);&#125;;<span class="hljs-built_in">Promise</span>.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then((value) =&gt; &#123;<span class="hljs-built_in">Promise</span>.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> value);&#125;,(reason) =&gt; &#123;<span class="hljs-built_in">Promise</span>.resolve(callback()).then(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">throw</span> reason;&#125;);&#125;);&#125;;<span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) </span>&#123;<span class="hljs-comment">// 抛出第一个改变的状态</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;pArr.forEach(<span class="hljs-function">(<span class="hljs-params">pItem</span>) =&gt;</span> pItem.then(resolve, reject));&#125;);&#125;;<span class="hljs-built_in">Promise</span>.any = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) </span>&#123;<span class="hljs-comment">// 有resolve就resolve</span><span class="hljs-comment">// 都没有resolve则返回一个由所有err组成的AggregateError对象</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!pArr.length) <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> AggregateError([]));<span class="hljs-keyword">const</span> res = [];pArr.forEach(<span class="hljs-function">(<span class="hljs-params">pItem, index</span>) =&gt;</span> &#123;pItem.then((v) =&gt; &#123;resolve(v);&#125;,(e) =&gt; &#123;res[index] = e;&#125;);&#125;);reject(<span class="hljs-keyword">new</span> AggregateError(res));&#125;);&#125;;<span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) </span>&#123;<span class="hljs-comment">// resolve全部value</span><span class="hljs-comment">// 有err就reject</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!pArr.length) <span class="hljs-keyword">return</span> resolve([]);<span class="hljs-keyword">const</span> res = [];pArr.forEach(<span class="hljs-function">(<span class="hljs-params">pItem, index</span>) =&gt;</span> &#123;pItem.then((v) =&gt; &#123;res[index] = v;&#125;,(e) =&gt; &#123;reject(e);&#125;);&#125;);resolve(res);&#125;);&#125;;<span class="hljs-built_in">Promise</span>.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) </span>&#123;<span class="hljs-comment">// 记录每个promise的状态</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!pArr.length) <span class="hljs-keyword">return</span> resolve([]);<span class="hljs-keyword">const</span> res = [];pArr.forEach(<span class="hljs-function">(<span class="hljs-params">pItem, index</span>) =&gt;</span> &#123;<span class="hljs-comment">// if (pItem instanceof Promise) &#123;</span>pItem.then((v) =&gt; &#123;res[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;resolve&quot;</span>, <span class="hljs-attr">value</span>: v &#125;;&#125;,(e) =&gt; &#123;res[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;reject&quot;</span>, <span class="hljs-attr">reason</span>: e &#125;;&#125;);<span class="hljs-comment">// &#125; else &#123;</span><span class="hljs-comment">//   res[index] = &#123; status: &quot;resolve&quot;, value: pItem &#125;;</span><span class="hljs-comment">// &#125;</span>&#125;);resolve(res);&#125;);&#125;;</code></pre></div><h2 id="同步函数-promise-化"><a href="#同步函数-promise-化" class="headerlink" title="同步函数 promise 化"></a>同步函数 promise 化</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promisify =(func) =&gt;(...args) =&gt;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;args.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, value</span>) </span>&#123;<span class="hljs-keyword">if</span> (err) reject(err);<span class="hljs-keyword">else</span> resolve(value);&#125;);func.apply(<span class="hljs-literal">null</span>, args);&#125;);</code></pre></div><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<span class="hljs-comment">// ...</span>&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<span class="hljs-comment">// ...</span>resolve(p1);&#125;);<span class="hljs-comment">//p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;fail&quot;</span>)), <span class="hljs-number">3000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> resolve(p1), <span class="hljs-number">1000</span>);&#125;);p2.then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(result)).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(error));<span class="hljs-comment">// Error: fail</span><span class="hljs-comment">// 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios和fetch</title>
    <link href="/2022/02/24/axios%E5%92%8Cfetch/"/>
    <url>/2022/02/24/axios%E5%92%8Cfetch/</url>
    
    <content type="html"><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><blockquote><p>基于XHR的Promise封装</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>PromiseAPI</li><li>客户端防止<code>CSRF</code></li><li>提供并发请求的接口</li><li>从node创建http请求</li><li>拦截器</li><li>取消请求abort</li></ol><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li><p>添加拦截器</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.interceptors.request.use(  (config) =&gt; &#123;    &lt;!-- 加入参数 --&gt;    config.params = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">666</span>&#125;    <span class="hljs-keyword">return</span> config  &#125;,  (err) =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)  &#125;);</code></pre></div></li><li><p>执行顺序</p><ul><li>请求拦截器 后面的拦截器先执行</li><li>响应拦截器 前面的拦截器先执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;request1&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err1&#x27;</span>)&#125;)axios.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;request2&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err2&#x27;</span>)&#125;)axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response1&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resErr1&#x27;</span>)&#125;)axios.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;response2&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;resErr2&#x27;</span>)&#125;)&lt;!-- <span class="hljs-built_in">console</span> --&gt;request2request1response1response2</code></pre></div></li></ul><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> CancelToken = axios.CancelToken;<span class="hljs-keyword">let</span> cancel = <span class="hljs-literal">null</span>btn.onclick = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(cancel !== <span class="hljs-literal">null</span>) cancel()  &lt;!-- 执行取消函数 --&gt;  axios(&#123;    method:<span class="hljs-string">&#x27;GET&#x27;</span>,    url:<span class="hljs-string">&#x27;http://xxxxxxx&#x27;</span>,    &lt;!--  --&gt;    cancelToken : <span class="hljs-keyword">new</span> CancelToken(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>&#123;      cancel = c      &lt;!-- cancelToken --&gt;    &#125;)  &#125;)&#125;.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  cancel = <span class="hljs-literal">null</span>&#125;)</code></pre></div><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><blockquote><p>原生api</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>只针对网络请求报错(请求不能完成)</li><li>携带cookie要添加配置</li><li>不支持取消请求abort</li><li>无法检测请求进度</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试题</title>
    <link href="/2022/02/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/02/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h2><ul><li>  边框属性<code>border-radius</code>，<code>box-shadow</code>，<code>border-image</code></li><li>  背景控制<code>background-size,background-origin</code></li><li>  文字效果和自动换行<code>text-shadow,word-wrap</code></li><li>  自定义字体<code>@font-face</code></li><li>  2d/3d 变换，过渡和动画<code>transition``animation</code></li><li>  CSS 多列布局<code>CSS Multi-column Layout</code></li><li>  盒模型属性<code>box-sizing</code></li><li>  弹性盒子<code>flex</code></li><li>  更强大的多媒体查询</li></ul><h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ul><li><p>IE</p><ul><li>双边距<ul><li>  <code>display:inline</code></li></ul></li><li>默认高度<code>16px</code><ul><li>  <code>font-size:0</code></li><li>  <code>overflow:hidden</code></li></ul></li><li>超链接内 img 会有边框<ul><li>  <code>border:0</code></li></ul></li></ul></li><li><p>3px bug</p><ul><li>  <code>display:block</code></li><li>  <code>vertical-align:top</code></li></ul></li></ul><h2 id="position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样"><a href="#position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样" class="headerlink" title="position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样"></a>position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样</h2><ul><li>  如果元素的 display 为 none，那么元素不被渲染，position，float 不起作用；</li><li>  如果元素拥有 position:absolute;或 position:fixed;属性，那么元素将为绝对定位，float 不起作用。</li><li>  如果元素 float 属性不是 none，元素会脱离文档流，根据 float 属性值来显示。</li><li>  有浮动、绝对定位，inline-block 属性的元素，margin 不会和垂直方向上的其他元素 margin 折叠。</li></ul><h2 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h2><ul><li>  不同边 border 之间 45 度拼接</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">50px</span> red solid;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">50px</span> $(背景色) solid;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> $(背景色) solid;&#125;</code></pre></div><h2 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h2><p><code>border-radius属性</code></p><ul><li>border-radius 是简写属性<ul><li>  border-top-left-radius</li><li>  border-top-right-radius</li><li>  border-bottom-right-radius</li><li>  border-bottom-left-radius</li><li>  top 左右，bottom 右左，顺时针顺序</li><li>  “/“ 用来分隔水平方向和垂直方向</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-comment">/* 绘制半椭圆 */</span><span class="hljs-selector-tag">div</span>&#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">border-style</span>: solid; <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#f00</span>; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>/<span class="hljs-number">100%</span> <span class="hljs-number">100%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>； /* 水平方向上四个角的半径都为<span class="hljs-number">50%</span> /  垂直方向 左右上半径为<span class="hljs-number">100%</span>，左右下为<span class="hljs-number">0</span>*/&#125;</code></pre></div><h2 id="文本控制"><a href="#文本控制" class="headerlink" title="文本控制"></a>文本控制</h2><ul><li>  单行文本居中，多行文本左对齐</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">text-align</span>:center&#125;<span class="hljs-selector-tag">p</span>&#123;  <span class="hljs-attribute">display</span>:inline-block;  <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:left</span>&#125;</code></pre></div><ul><li>  多行文本省略号</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">p</span>:after&#123;  content:<span class="hljs-string">&#x27;...&#x27;</span>&#125;</code></pre></div><ul><li>  单行文本溢出省略</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-attribute">overflow</span>: hidden；/* （文字长度超出限定宽度，则隐藏超出的内容） */white-space: nowrap；/* （设置文字在一行显示，不能换行） */text-overflow: ellipsis；/* （规定当文本溢出时，显示省略符号来代表被修剪的文本） */</code></pre></div><ul><li>  多行文本溢出</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS">-webkit-line-clamp: <span class="hljs-number">2</span>；/* （用来限制在一个块元素显示的文本的行数，<span class="hljs-number">2</span> 表示最多显示 <span class="hljs-number">2</span> 行。为了实现该效果，它需要组合其他的 WebKit 属性） */display: -webkit-box；/* （和 <span class="hljs-number">1</span> 结合使用，将对象作为弹性伸缩盒子模型显示 ） */-webkit-box-orient: vertical；/* （和 <span class="hljs-number">1</span> 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ） */overflow: hidden；/* （文本溢出限定的宽度就隐藏内容） */text-overflow: ellipsis；/* （多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本) */</code></pre></div><h2 id="dpr-1px-边框"><a href="#dpr-1px-边框" class="headerlink" title="dpr 1px 边框"></a>dpr 1px 边框</h2><ul><li>  伪元素配合媒体查询<code>transform:scale()</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-class">.onePx_border</span>:after&#123;    /* 整个div边框 */    content: <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#cccccc</span>;    <span class="hljs-comment">/* 注意宽高和圆角单位都要配合媒体查询 */</span>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">26px</span>;？？？    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>/<span class="hljs-number">200%</span>/<span class="hljs-number">333%</span>    height: <span class="hljs-number">100%</span>/<span class="hljs-number">200%</span>/<span class="hljs-number">333%</span>    /* 单独一边的边框 */    content: <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#cccccc</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;  <span class="hljs-selector-class">.onePx_border</span>:after &#123;    -webkit-transform: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);    -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;  &#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">3</span>) &#123;  <span class="hljs-selector-class">.onePx_border</span>:after &#123;    -webkit-transform: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.3</span>);    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.3</span>);    -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;  &#125;&#125;</code></pre></div><ul><li><p>rem + viewport</p><ol><li>整体缩放 px 单位</li></ol>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// scale</span>    <span class="hljs-keyword">var</span> clientWidth = <span class="hljs-built_in">window</span>.screen.width;    <span class="hljs-keyword">var</span> dpr = <span class="hljs-built_in">window</span>.devicePixelRatio;    <span class="hljs-keyword">var</span> vp = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;meta&#x27;</span>);    vp.name = <span class="hljs-string">&#x27;viewport&#x27;</span>;    vp.content = <span class="hljs-string">`initial-scale=<span class="hljs-subst">$&#123;<span class="hljs-number">1.0</span> * <span class="hljs-number">1</span> <span class="hljs-regexp">/ dpr&#125;, maximum-scale=$&#123;1.0 * 1 /</span> dpr&#125;</span>, minimum-scale=<span class="hljs-subst">$&#123;<span class="hljs-number">1.0</span> * <span class="hljs-number">1</span> / dpr&#125;</span>, user-scalable=no, width=device-width`</span>;    <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;meta&#x27;</span>)[<span class="hljs-number">0</span>];    m.parentNode.insertBefore(vp, m);    <span class="hljs-comment">// rem</span>    <span class="hljs-built_in">document</span>.documentElement.style.fontSize = ?  &#125;)();&lt;/script&gt;</code></pre></div><ol start="2"><li>其他元素使用 rem 单位</li></ol></li></ul><h2 id="垂直居中-div"><a href="#垂直居中-div" class="headerlink" title="垂直居中 div"></a>垂直居中 div</h2><ul><li>  绝对定位+上下左右 0+margin 0</li><li>  绝对定位+负 margin</li><li>  绝对定位+负 translate</li><li>  flex+justify-content+align-items</li><li>  table-cell+vertical-align</li></ul><h2 id="三栏布局-左右固定中间自适应"><a href="#三栏布局-左右固定中间自适应" class="headerlink" title="三栏布局(左右固定中间自适应)"></a>三栏布局(左右固定中间自适应)</h2><ol><li><p>绝对定位</p></li><li><p>左右浮动【自适应元素要放在最后】</p> <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>* &#123;<span class="css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span>&#125;<span class="css"><span class="hljs-selector-tag">body</span> &#123;</span><span class="css"><span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span>&#125;.container &#123;<span class="css"><span class="hljs-attribute">overflow</span>: hidden;</span>&#125;.column &#123;<span class="css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>&#125;.left &#123;<span class="css"><span class="hljs-attribute">float</span>: left;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span>&#125;.center &#123;<span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span>&#125;.right &#123;<span class="css"><span class="hljs-attribute">float</span>: right;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span>&#125;/*左右浮动至左右并处于同一行          *未浮动的center内容会被浮动元素环绕          */<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>全部左浮，-margin 移到上一行【自适应元素放在最前】</p> <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>* &#123;<span class="css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span>&#125;<span class="css"><span class="hljs-selector-tag">body</span> &#123;</span><span class="css"><span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span>&#125;.container &#123;<span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">overflow</span>: hidden;</span>&#125;.column &#123;<span class="css"><span class="hljs-attribute">position</span>: relative;</span>/**<span class="css">        *设置定位，元素需要手动移动至<span class="hljs-attribute">padding</span>空隙中</span>        */<span class="css"><span class="hljs-attribute">float</span>: left;</span><span class="css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>&#125;.left &#123;<span class="css"><span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span>&#125;.center &#123;<span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span>&#125;.right &#123;<span class="css"><span class="hljs-attribute">left</span>: <span class="hljs-number">150px</span>;</span><span class="css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>全部左浮，center 元素需要撑开 center-wrapper【自适应元素放在最前】</p> <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>* &#123;<span class="css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span>&#125;<span class="css"><span class="hljs-selector-tag">body</span> &#123;</span><span class="css"><span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span>&#125;.container &#123;<span class="css"><span class="hljs-attribute">overflow</span>: hidden;</span>&#125;.column &#123;<span class="css"><span class="hljs-attribute">float</span>: left;</span><span class="css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>&#125;.left &#123;<span class="css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span>&#125;.center-wrapper &#123;<span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span>&#125;.center &#123;<span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span><span class="css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span>&#125;.right &#123;<span class="css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;</span><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span>&#125;/**       *3，4方法类似<span class="css">       * -<span class="hljs-number">100%</span>的<span class="hljs-attribute">margin-left</span>将元素移到上行最左</span><span class="css">       * -自身宽度<span class="hljs-attribute">margin-left</span>将元素移到上行最右</span><span class="css">       * 并通过给center加<span class="hljs-attribute">padding</span></span>       */<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center-wrapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>flex</p><p> <code>flex-grow</code>:1 自适应填充剩余空间</p></li><li><p>grid</p><p> <code>grid-template-column/row</code>中给自适应元素写 auto 大小</p></li><li><p>table<br> table 下的<code>table-cell</code>会自动自适应没写 width 的元素</p> <div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<span class="hljs-attribute">display</span>: table;<span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<span class="hljs-attribute">display</span>: table-cell;&#125;<span class="hljs-selector-class">.main</span> &#123;<span class="hljs-attribute">background</span>: pink;&#125;<span class="hljs-selector-class">.left</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<span class="hljs-attribute">background</span>: red;&#125;<span class="hljs-selector-class">.right</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<span class="hljs-attribute">background</span>: yellow;&#125;</code></pre></div></li></ol><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><ul><li>  物理像素:物理成像点</li><li>  css 像素:开发逻辑单位</li><li>  设备独立像素:设备屏幕呈现的像素量</li><li>  dpi 设备像素比:物理像素/设备独立像素(用多少个物理像素渲染一个设备独立像素)</li></ul><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><ul><li>使用rem<code>postcss-pxtorem</code> / 大屏设备显示过大</li><li>使用vw/vh<code>postcss-px-to-viewport</code> / 大屏设备显示过大</li><li>百分比单位</li><li>px 为主，搭配 vw/vh、媒体查询与 flex 进行布局</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>div高度为宽度一半</title>
    <link href="/2022/02/24/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/"/>
    <url>/2022/02/24/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h2><ul><li><code>static</code><ul><li>正常流，默认值</li><li>top, right, bottom, left 和 z-index 属性无效。</li></ul></li><li><code>relative</code><ul><li>相对正常流偏移</li><li>原位置有预留空间</li></ul></li><li><code>absolute</code><ul><li>移出正常文档流</li><li>相对于最近的 非static 定位祖先元素偏移</li><li>不为元素预留空间</li></ul></li><li><code>fixed</code><ul><li>移出正常文档流</li><li>相对于屏幕视口（viewport）的位置来指定元素位置</li><li>不为元素预留空间<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote></li></ul></li><li><code>sticky</code><ul><li>相对定位和固定定位的混合</li><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li><li>跨越特定阈值前为相对定位，之后为固定定位</li></ul></li></ul><h2 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h2><h3 id="包含块的作用"><a href="#包含块的作用" class="headerlink" title="包含块的作用"></a>包含块的作用</h3><p>  元素的尺寸及位置，常常会受它的包含块所影响。对于一些属性，例如 width,height,padding,margin，绝对定位元素的偏移值（比如 position 被置为 absolute 或 fixed），当我们对其赋予百分比值时，其参考值是包含块的尺寸。</p><h3 id="确定包含块"><a href="#确定包含块" class="headerlink" title="确定包含块"></a>确定包含块</h3><blockquote><p>一个元素的包含块并不一定父元素的内容区</p></blockquote><p>元素的包含块由其<code>position</code>决定：</p><ul><li><code>static 、 relative 或 sticky </code>，包含块可能由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）的内容区的边缘组成（<code>content</code>）</li><li><code>absolute</code> ，包含块就是由它的最近的 <code>position 的值不是 static</code> （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成（<code>content+padding</code>）</li><li><code>fixed</code>，在连续媒体的情况下(continuous media)包含块是 viewport ,在分页媒体(paged media)下的情况下包含块是分页区域(page area)。<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时,包含块是这个元素的内边距区 content+padding</p></blockquote></li></ul><h3 id="根据包含块计算"><a href="#根据包含块计算" class="headerlink" title="根据包含块计算"></a>根据包含块计算</h3><ul><li>要计算 <code>height</code> <code>top</code> 及 <code>bottom</code> 中的百分值，是通过包含块的 <code>height</code> 的值</li><li>要计算 <code>width</code>, <code>left</code>, <code>right</code>, <strong><code>padding</code>!, <code>margin</code></strong> 这些属性由包含块的 <code>width</code> 属性的值来计算它的百分值。</li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol><li><p>实现一个div垂直水平居中高度为宽度的一半自适应</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 外层wrapper */</span><span class="hljs-selector-class">.outer-wrapper</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">display</span>:flex;  <span class="hljs-comment">/* flex默认行排列，所以这里设置侧轴对齐 */</span>  <span class="hljs-attribute">align-items</span>:center&#125;<span class="hljs-comment">/* 内层wrapper */</span><span class="hljs-selector-class">.inner-wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* padding,margin值的百分比是相较于父元素width */</span>&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-comment">/* 两个position设置都是为了确定包含块 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-comment">/* 这里的高度就=&gt;inner-wrapper[height+padding]=&gt;outer-wrapper[width]*50% */</span>&#125;</code></pre></div></li><li><p>实现div正方形大小自适应</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">padding-top</span>:<span class="hljs-number">50%</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* 同样相较于包含块的尺寸百分比 */</span>  <span class="hljs-comment">/* width和padding都等于wrapper包含块的宽度的一半 */</span>&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;  <span class="hljs-comment">/* 偏移到wrapper位置 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;&#125;<span class="hljs-comment">/* 也可使用伪元素撑开高度 */</span><span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* 触发BFC避免塌陷 */</span>  <span class="hljs-attribute">display</span>:flow-root&#125;<span class="hljs-selector-class">.div</span><span class="hljs-selector-pseudo">::after</span>&#123;  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">display</span>:block&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6新特性</title>
    <link href="/2022/02/24/es6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/02/24/es6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="【let-const】"><a href="#【let-const】" class="headerlink" title="【let / const】"></a>【let / const】</h2><ul><li>都用于声明变量</li><li>不存在变量提升，暂时性死区</li><li>不能重复声明</li><li>快级作用域</li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>可以重新赋值<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3></li><li>声明时需赋值</li><li>只读不可改变（对于复杂变量，可以修改变量内容，变量内存地址未改变）</li></ul><h2 id="【解构赋值】"><a href="#【解构赋值】" class="headerlink" title="【解构赋值】"></a>【解构赋值】</h2><p>只有可遍历（具备遍历器<code>[Symbol.Iterator]</code>）的数据结构才能解构赋值</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>交换变量</li><li>提取对象中的数据</li><li>解构默认值</li><li>剩余运算</li></ul><h2 id="【字符串】"><a href="#【字符串】" class="headerlink" title="【字符串】"></a>【字符串】</h2><ul><li><p>识别</p><ul><li><code>includes()</code></li><li><code>startsWith()</code></li><li><code>endsWith()</code> </li></ul></li><li><p>补全</p><ul><li><code>padStart(len,x)</code>// 补全后的最小长度，不足则用x在开头填充</li><li><code>padEnd()</code>// 在末尾填充</li></ul></li><li><p>重复</p><p><code>String.prototype.repeat()</code></p></li><li><p>模版字符串<code>多行，插值$&#123;x&#125;</code></p></li></ul><h2 id="【数值】"><a href="#【数值】" class="headerlink" title="【数值】"></a>【数值】</h2><blockquote><p>普通number类型只能保留53个二进制位/16个10进制位的精度</p></blockquote><ul><li>最大最小安全整数<code>Number.MAX_SAFE_INTEGER</code>,<code>Number.MAX_SAFE_INTEGER</code></li><li>识别<ul><li><code>Number.isSafeInteger()</code></li><li><code>Number.isFinite()</code></li></ul></li><li>大数<code>BigInt</code>类型，后要加上字母n<code>123n</code>，没有位数限制 </li><li>指数运算<code>**</code></li></ul><h2 id="【数组】"><a href="#【数组】" class="headerlink" title="【数组】"></a>【数组】</h2><ul><li>方法<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.from() <span class="hljs-comment">// 从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</span><span class="hljs-built_in">Array</span>.of() <span class="hljs-comment">// Array()只传一个参数就作为新建的数组长度</span>includes()copyWithin()fill()find() / findIndex()keys(),values(),entries()flat()</code></pre></div></li><li>扩展运算符<code>...</code></li></ul><h2 id="【对象】"><a href="#【对象】" class="headerlink" title="【对象】"></a>【对象】</h2><ul><li>方法<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.is(a,b)<span class="hljs-comment">// 比较两个值是否严格相等，与（===）基本类似</span><span class="hljs-comment">// Object.is与全等的区别</span><span class="hljs-comment">//  Object.is(+0,-0);  //false</span><span class="hljs-comment">//  +0 === -0  //true</span><span class="hljs-comment">//  Object.is(NaN,NaN); //true</span><span class="hljs-comment">//  NaN === NaN  //false</span><span class="hljs-built_in">Object</span>.assign() <span class="hljs-comment">// 潜拷贝</span></code></pre></div></li><li>扩展运算符<code>...</code></li></ul><h2 id="【函数】"><a href="#【函数】" class="headerlink" title="【函数】"></a>【函数】</h2><ul><li>箭头函数<ul><li>箭头函数没有自己的this,静态绑定书写时的上下文</li><li>箭头函数没有<code>prototype</code> —&gt; <strong>不能作为构造函数，不能 new</strong></li><li>箭头函数没有<code>arguments</code>属性</li><li>不能用作<code>generator</code>函数</li></ul></li><li>函数参数默认值<code>function fn1(arg1=&#39;xxx&#39;)&#123;&#125;</code></li><li>函数剩余参数<code>function(a, b, ...theArgs)</code></li></ul><h2 id="【Symbol】"><a href="#【Symbol】" class="headerlink" title="【Symbol】"></a>【Symbol】</h2><p>独一无二的值,<code>Symbol()</code>声明</p><h2 id="【Set-WeakSet】"><a href="#【Set-WeakSet】" class="headerlink" title="【Set/WeakSet】"></a>【Set/WeakSet】</h2><ul><li>Set类似于数组，但是成员的值都是唯一的<div class="hljs code-wrapper"><pre><code class="hljs javascript">sizeadd()<span class="hljs-keyword">delete</span>()has()clear()</code></pre></div></li><li>WeakSet的成员只能是对象，【弱引用】，【不可遍历】<div class="hljs code-wrapper"><pre><code class="hljs javascript">add()<span class="hljs-keyword">delete</span>()has()</code></pre></div></li></ul><h2 id="【Map-WeakMap】"><a href="#【Map-WeakMap】" class="headerlink" title="【Map/WeakMap】"></a>【Map/WeakMap】</h2><ul><li>Object的键传统上只能使用字符串，Map无此限制<div class="hljs code-wrapper"><pre><code class="hljs javascript">sizeset(key,value) <span class="hljs-comment">// 返回整个 Map 结构</span>get() <span class="hljs-comment">// 找不到该 key 返回 undefined</span>has()<span class="hljs-keyword">delete</span>() <span class="hljs-comment">// 删除失败返回 false</span>clear() <span class="hljs-comment">// 无返回值</span></code></pre></div></li><li>WeakMap只接受对象作为键名（除了null），【键名弱引用】<div class="hljs code-wrapper"><pre><code class="hljs javascript">set()get()has()<span class="hljs-keyword">delete</span>()</code></pre></div></li><li>map和object的区别<ol><li>键的变量类型限制</li><li>map原生具有遍历器</li><li>map遍历时保持插入时的顺序(object遍历时会对整数键名排序)</li><li>map.size()返回长度</li></ol></li></ul><h2 id="【Proxy】"><a href="#【Proxy】" class="headerlink" title="【Proxy】"></a>【Proxy】</h2><p>拦截器/代理 <code>const _proxy1 = new Proxy(target,handler)</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 常用handlers</span>handler.getPrototypeOf()<span class="hljs-comment">// Object.getPrototypeOf 方法的捕捉器。</span>handler.setPrototypeOf()<span class="hljs-comment">// Object.setPrototypeOf 方法的捕捉器。</span>handler.getOwnPropertyDescriptor()<span class="hljs-comment">// Object.getOwnPropertyDescriptor 方法的捕捉器。</span>handler.defineProperty()<span class="hljs-comment">// Object.defineProperty 方法的捕捉器。</span>handler.has()<span class="hljs-comment">// in 操作符的捕捉器。</span>handler.get()<span class="hljs-comment">// 属性读取操作的捕捉器。</span>handler.set()<span class="hljs-comment">// 属性设置操作的捕捉器。</span>handler.deleteProperty()<span class="hljs-comment">// delete 操作符的捕捉器。</span>handler.ownKeys()<span class="hljs-comment">// Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</span>handler.apply()<span class="hljs-comment">// 函数调用操作的捕捉器。</span>handler.construct()<span class="hljs-comment">// new 操作符的捕捉器。</span></code></pre></div><h2 id="【Reflect】"><a href="#【Reflect】" class="headerlink" title="【Reflect】"></a>【Reflect】</h2><p>操作对象的API</p><ul><li>将对象操作的返回更合理化（报错-&gt;false</li><li>将对象操作函数化<blockquote><p>某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p></blockquote></li><li>与Proxy中方法均对应<h2 id="【Promise】"><a href="#【Promise】" class="headerlink" title="【Promise】"></a>【Promise】</h2></li><li>处理异步操作，避免回调嵌套</li><li>状态不可逆</li><li>中途不可停止</li><li>需要捕获promise内错误</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve,reject))<span class="hljs-built_in">Promise</span>.prototype.then(onFulfilled,onRejected)<span class="hljs-built_in">Promise</span>.prototype.catch()<span class="hljs-comment">// promise中的错误会一直冒泡到最后，没有捕获则报错</span><span class="hljs-built_in">Promise</span>.prototype.finally()<span class="hljs-built_in">Promise</span>.all() <span class="hljs-comment">// 全部fulfilled或者有谁rejected</span><span class="hljs-built_in">Promise</span>.allSettled() <span class="hljs-comment">// 全部得到不管什么状态</span><span class="hljs-built_in">Promise</span>.race() <span class="hljs-comment">// 最先改变status</span><span class="hljs-built_in">Promise</span>.any() <span class="hljs-comment">// 最先fulfilled或者全部rejected</span><span class="hljs-built_in">Promise</span>.resolve()<span class="hljs-built_in">Promise</span>.reject()<span class="hljs-built_in">Promise</span>.try()</code></pre></div><h2 id="【Iterator迭代器】"><a href="#【Iterator迭代器】" class="headerlink" title="【Iterator迭代器】"></a>【Iterator迭代器】</h2><h3 id="Symbol-Iterator"><a href="#Symbol-Iterator" class="headerlink" title="[Symbol.Iterator]"></a>[Symbol.Iterator]</h3><ul><li>统一的遍历集合数据的借口</li><li>只要拥有<code>[Symbol.Iterator]</code>的数据结构都可以用for…of遍历</li></ul><h3 id="原生具备-Iterator-接口的数据结构如下。"><a href="#原生具备-Iterator-接口的数据结构如下。" class="headerlink" title="原生具备 Iterator 接口的数据结构如下。"></a>原生具备 Iterator 接口的数据结构如下。</h3><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments</li><li>Dom Node</li></ul><h2 id="【Generator】"><a href="#【Generator】" class="headerlink" title="【Generator】"></a>【Generator】</h2><ul><li><p>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 <code>迭代器</code> （ iterator ）对象。当这个迭代器的 <code>next()</code> 方法被调用时，其内的语句会执行到下一个<code>yield</code>的位置，<code>yield</code> 后紧跟迭代器要返回的值。</p></li><li><p>或者如果用的是 <code>yield*</code>，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</p></li><li><p><code>next()</code>方法返回一个对象，<code>&#123;value:当前的返回,done:是否迭代完&#125;</code></p></li><li><p>当在生成器函数中显式 <code>return</code> 时，会导致生成器立即变为完成状态，如果 <code>return</code> 后面跟了一个值，那么这个值会作为当前调用 <code>next()</code> 方法返回值。</p></li><li><p>调用 <code>next()</code>方法时，如果传入了参数，那么这个参数会传给上一条执行的 <code>yield</code>语句左边的变量，例如下面例子中的 x ：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">yield</span> <span class="hljs-number">10</span>;    x=<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;foo&#x27;</span>;    <span class="hljs-keyword">yield</span> x;&#125;<span class="hljs-keyword">var</span> gen_obj=gen();<span class="hljs-built_in">console</span>.log(gen_obj.next());<span class="hljs-comment">// 执行 yield 10，返回 10</span><span class="hljs-built_in">console</span>.log(gen_obj.next());<span class="hljs-comment">// 执行 yield &#x27;foo&#x27;，返回 &#x27;foo&#x27;</span><span class="hljs-built_in">console</span>.log(gen_obj.next(<span class="hljs-number">100</span>));<span class="hljs-comment">// 将 100 赋给上一条 yield &#x27;foo&#x27; 的左值，即执行 x=100，返回 100</span><span class="hljs-built_in">console</span>.log(gen_obj.next());<span class="hljs-comment">// 执行完毕，value 为 undefined，done 为 true</span></code></pre></div></li></ul><ul><li>自执行generator<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// co函数简单实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">co</span>(<span class="hljs-params">fn</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> gen = fn()    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step</span>(<span class="hljs-params">nextF</span>)</span>&#123;      <span class="hljs-keyword">let</span> ret      <span class="hljs-keyword">try</span>&#123;        ret = nextF()      &#125;<span class="hljs-keyword">catch</span>(e)&#123;        <span class="hljs-keyword">return</span> reject(e)      &#125;      <span class="hljs-keyword">if</span>(ret.done) <span class="hljs-keyword">return</span> resolve(ret.value)      <span class="hljs-built_in">Promise</span>.resolve(ret.value).then(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;        step(<span class="hljs-function">()=&gt;</span>gen.next(v))      &#125;,<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;        step(<span class="hljs-function">()=&gt;</span>gen.throe(e))      &#125;)    &#125;    step(<span class="hljs-function">()=&gt;</span>gen.next(<span class="hljs-literal">undefined</span>))  &#125;)&#125;</code></pre></div><h2 id="【async-await】"><a href="#【async-await】" class="headerlink" title="【async/await】"></a>【async/await】</h2>自执行的Generator函数语法糖。</li></ul><h2 id="【Class】"><a href="#【Class】" class="headerlink" title="【Class】"></a>【Class】</h2><ol><li><p>类表达式和类声明</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> A = <span class="hljs-class"><span class="hljs-keyword">class</span> </span>&#123;&#125;<span class="hljs-comment">// or</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;</code></pre></div><blockquote><p>类声明和类表达式的主体都执行在严格模式下</p></blockquote></li><li><p>继承</p><p>本质使用的是原型式继承</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.name = name  &#125;  <span class="hljs-function"><span class="hljs-title">fun1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-title">extend</span> <span class="hljs-title">B</span></span>&#123;  <span class="hljs-title">constructor</span> (<span class="hljs-params">name</span>)&#123;    <span class="hljs-built_in">super</span>(name) <span class="hljs-comment">// 调用父类构造函数 // </span>      &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">fun2</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">super</span>.fun1() <span class="hljs-comment">// 调用一个父类方法</span>  &#125;</code></pre></div></li><li><p>静态字段，私有字段，私有实例字段</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;  <span class="hljs-comment">//静态字段</span>  <span class="hljs-keyword">static</span> attr1 = <span class="hljs-number">123</span>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;im func1&#x27;</span>&#125;  <span class="hljs-comment">//只在类声明中存在，实例不能访问</span>  <span class="hljs-comment">// 公有字段</span>  attr2 = <span class="hljs-number">666</span>  <span class="hljs-function"><span class="hljs-title">func2</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  <span class="hljs-comment">// 每个实例都复制一份</span>  <span class="hljs-comment">//私有实例字段</span>  <span class="hljs-comment">//不能直接访问，闭包访问</span>  #attr3  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.#attr3 = name  &#125;  <span class="hljs-function"><span class="hljs-title">getPrivate</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#attr3  &#125;  #func3 = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;im private&#x27;</span>);  &#125;  <span class="hljs-function"><span class="hljs-title">getPrivateFunc</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#func3()  &#125;&#125;</code></pre></div></li><li><p>getter / setter</p><p> 当使用 get 关键字时，属性将被定义在实例的原型上，当使用Object.defineProperty()时，属性将被定义在实例自身上。</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;  <span class="hljs-keyword">get</span> <span class="hljs-title">hello</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;world&#x27;</span>;  &#125;&#125;<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> Example();<span class="hljs-built_in">console</span>.log(obj.hello);<span class="hljs-comment">// &quot;world&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;hello&#x27;</span>));<span class="hljs-comment">// undefined</span></code></pre></div><h2 id="【模块化-ES-module】"><a href="#【模块化-ES-module】" class="headerlink" title="【模块化 ES module】"></a>【模块化 ES module】</h2></li><li><p>语法</p></li></ol><p><code>export / export</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是 Node 中向外暴露成员的形式：</span><span class="hljs-comment">// module.exports = &#123;&#125;</span><span class="hljs-comment">// ES6中导入模块，使用 import 模块名称 from &#x27;模块标识符&#x27; import &#x27;表示路径&#x27;</span><span class="hljs-comment">// 在 ES6 中，使用 export default 和 export 向外暴露成员：</span><span class="hljs-keyword">var</span> info = &#123;  name: <span class="hljs-string">&quot;zs&quot;</span>,  age: <span class="hljs-number">20</span>&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  address: <span class="hljs-string">&quot;深圳&quot;</span>&#125;;<span class="hljs-comment">// 注意： export default 向外暴露的成员，可以使用任意的变量来接收</span><span class="hljs-comment">// 注意： 在一个模块中，export default 只允许向外暴露1次</span><span class="hljs-comment">// 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> title = <span class="hljs-string">&quot;小星星&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> content = <span class="hljs-string">&quot;哈哈哈&quot;</span>;<span class="hljs-comment">// 注意： 使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式，叫做 【按需导出】</span><span class="hljs-comment">// 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以不在 &#123;&#125; 中定义</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用 &#123;&#125; 按需接收；</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，如果 就想 换个 名称来接收，可以使用 as 来起别名；</span><span class="hljs-comment">// 在Node中 使用 var 名称 = require(&#x27;模块标识符&#x27;)</span><span class="hljs-comment">// module.exports 和 exports 来暴露成员</span></code></pre></div><ol start="2"><li><p>使用 babel 编译 ES6 语法</p><p>Babel 是一个工具链，主要用于在旧的浏览器或环境中将 ECMAScript 2015+ 代码转换为向后兼容版本的 JavaScript 代码</p></li><li><p>模块化工具 webpack,rollup</p></li></ol><h2 id="装饰器语法"><a href="#装饰器语法" class="headerlink" title="装饰器语法"></a>装饰器语法</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">@demo<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span>(<span class="hljs-params">target</span>)</span>&#123;  target.value = <span class="hljs-number">666</span>&#125;<span class="hljs-comment">// 等价于</span>MyClass = demo(MyClass)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2022/02/24/flex/"/>
    <url>/2022/02/24/flex/</url>
    
    <content type="html"><![CDATA[<p>ref:<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">阮一峰的网络日志</a></p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul><li><p><code>flex-direction</code> 主轴的方向 </p><ul><li><code>row(默认住) | row-reverse</code> 横向排列</li><li><code>column | column-reverse</code>纵向排列</li></ul></li><li><p><code>flex-wrap</code> 换行</p><ul><li><code>nowrap</code>不换行</li><li><code>wrap</code>换行</li><li><code>wrap-reverse</code>逆序换行</li></ul></li><li><p><code>flex-flow</code>(上述两种的简写)</p></li><li><p><code>justify-content</code> 主轴上的对齐方式</p><ul><li><code>flex-start</code>（默认值）：左对齐 </li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></li><li><p><code>align-items</code> 侧轴上如何对齐 </p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li><li><code>flex-end</code>：交叉轴的终点对齐</li><li><code>center</code>：交叉轴的中点对齐</li><li><code>baseline</code>: 项目的第一行文字的基线对齐</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul></li><li><p><code>align-content</code> 多根轴线的对齐方式</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐</li><li><code>flex-end</code>：与交叉轴的终点对齐</li><li><code>center</code>：与交叉轴的中点对齐</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴</li></ul></li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ul><li><p><code>order</code></p><p>项目的排列顺序。数值越小，排列越靠前，默认为0</p></li><li><p><code>flex-grow</code></p><p>如果存在剩余空间，1放大，0不放大</p></li><li><p><code>flex-shrink</code></p><p>如果空间不足，1缩小，0不缩小</p></li><li><p><code>flex-basis</code></p><p>  基础大小</p></li><li><p><code>flex</code>是上述三种的简写</p><p><code>[flex-grow] [flex-shrink] [flex-basis]</code></p></li><li><p><code>align-self</code></p><p>采用与其他兄弟项目不一样的对齐方式,参考<code>[align-item]</code></p><h2 id="布局实例"><a href="#布局实例" class="headerlink" title="布局实例"></a>布局实例</h2></li></ul><ol><li><p>圣杯布局</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:burlywood&quot;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 按照顺序渲染，如果需提前修改元素order属性，越小越优先 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:chocolate&quot;</span>&gt;</span>nav<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:blueviolet&quot;</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:cadetblue&quot;</span>&gt;</span>aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:darkslateblue&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-comment">/* 垂直方向 */</span>  <span class="hljs-attribute">flex-direction</span>: column;&#125;<span class="hljs-selector-tag">header</span>,<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-comment">/* 6em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6em</span>;&#125;<span class="hljs-selector-class">.body</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">nav</span>,<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">aside</span>&#123;  <span class="hljs-comment">/* 10em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10em</span>;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>&#125;</code></pre></div></li><li><p>固定的底栏</p><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-comment">/* 改变flex朝向 */</span>  <span class="hljs-attribute">flex-direction</span>:column;  <span class="hljs-comment">/* 占满视口高度 */</span> &lt;----------------  <span class="hljs-attribute">min-height</span>:<span class="hljs-number">100vh</span>;&#125;<span class="hljs-selector-tag">header</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">30px</span>;  <span class="hljs-attribute">background</span>: blue;&#125;<span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-comment">/* 主题内容填满剩余空间 */</span>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>&#125;<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-attribute">background</span>:black;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试题</title>
    <link href="/2022/02/24/html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/02/24/html%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h1><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><ul><li><p>纯表现的元素/可以用css实现的元素：<code>basefont</code>，<code>big</code>，<code>center</code>，<code>font</code>, <code>s</code>，<code>strike</code></p></li><li><p>对可用性产生负面影响的元素：<code>frame</code>,<code>frameset</code></p></li><li><p>语意化更好的标签，比如<code>header,nav,section,article,footer,aside</code></p></li><li><p>增强了<code>input</code>类型:<code>color</code>,<code>date</code>,<code>datetime-local</code>,<code>range</code>,<code>tel</code>,<code>search</code>,<code>url</code></p></li><li><p>新的表单元素:<code>datalist,progress,meter,output,keygen</code></p></li><li><p>表单校验(数据格式，数据范围，占位符，必填等)</p></li><li><p><code>canvas</code> API和内联 <code>svg</code></p></li><li><p><code>audio/video</code> 音视频元素</p></li><li><p><code>manifest</code>web应用离线缓存</p></li><li><p>地理定位<code>geolocation</code> API</p></li><li><p><code>webworker</code>将JS计算交给后台线程</p></li><li><p><code>websocket</code>全双工的支持服务端推送的持久化连接协议</p></li><li><p>webStorage：<code>localStorage sessionStorage</code></p></li><li><p><code>history</code>API</p></li></ul><h3 id="HTML5-哪些标签可以做-SEO"><a href="#HTML5-哪些标签可以做-SEO" class="headerlink" title="HTML5 哪些标签可以做 SEO"></a>HTML5 哪些标签可以做 SEO</h3><p><code>title、meta、header、footer、nav、article、aside</code></p><h1 id="meta元数据标签"><a href="#meta元数据标签" class="headerlink" title="meta元数据标签"></a>meta元数据标签</h1><ul><li><code>charset</code> 字符编码</li><li><code>keywords</code>关键词和爬虫</li><li><code>viewport</code> scale页面缩放</li><li><code>CSP</code>内容安全策略</li></ul><h1 id="HTML5-的离线存储"><a href="#HTML5-的离线存储" class="headerlink" title="HTML5 的离线存储"></a>HTML5 的离线存储</h1><p>在用户没有联网时，可以正常访问站点或应用；在联网的情况下，更新用户机器上的缓存文件。</p><ol><li>页面头部加入一个 manifest 的属性</li><li>在 cache.manifest 文件的编写离线存储的资源</li><li>在离线状态下，操作 window.applicationCache 进行需求实现</li></ol><h4 id="浏览器是如何对-HTML5-的离线存储资源进行管理和加载的"><a href="#浏览器是如何对-HTML5-的离线存储资源进行管理和加载的" class="headerlink" title="浏览器是如何对 HTML5 的离线存储资源进行管理和加载的"></a>浏览器是如何对 HTML5 的离线存储资源进行管理和加载的</h4><ul><li><p>在线的情况下，浏览器发现 HTML 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并且进行离线存储。</p></li><li><p>如果已经访问过 app，并且资源已经离线存储，浏览器会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件，如果文件没有发生改变，就不做任何操作，否则就会重新下载文件中的资源并进行离线存储。</p></li><li><p>离线的情况下，浏览器直接使用离线存储的资源。</p></li></ul><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>HTML 文档中的每个元素都使用一个矩形盒子来描述其占用空间，这个模型称为盒模型。盒模型包含四个区域：<code>margin</code>（外边距），<code>border</code>（边框），<code>padding</code>（内边距），<code>content</code>（内容区域）</p><blockquote><p>outline和box-shadow都会从margin box区域开始计算</p></blockquote><h2 id="标准模型和-IE-模型"><a href="#标准模型和-IE-模型" class="headerlink" title="标准模型和 IE 模型"></a>标准模型和 IE 模型</h2><ul><li>标准模型<code>box-sizing:content-box</code>,对其设置宽高只作用于<code>content box</code>区域</li><li>ie 模型<code>box-sizing:border-box</code>,对其设置宽高会作用于<code>content box</code>,<code>padding box</code>和 <code>border box</code>区域</li></ul><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p><code>display block</code></p><ol><li><p>独占一行</p></li><li><p>可以设置 width，height，margin，padding，border 属性</p></li><li><p>默认宽度是容器的 100%</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">article; <span class="hljs-comment">// h5</span>div;header; <span class="hljs-comment">// h5</span>section; <span class="hljs-comment">// h5</span>address; <span class="hljs-comment">// h5</span>ol;ul;aside; <span class="hljs-comment">// h5</span>footer; <span class="hljs-comment">// h5</span>audio; <span class="hljs-comment">// h5</span>video; <span class="hljs-comment">// h5</span>canvas; <span class="hljs-comment">// h5</span>hgroup; <span class="hljs-comment">// h5</span>p;h1 - h6;table;form;</code></pre></div><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p><code>display inline</code></p><ol><li>行内排列</li><li>不能设置 <code>width</code>、<code>height</code>,默认高度和宽度就是内容的高度和宽度</li><li>可以设置 <code>margin-left/right</code>，无法设置 <code>margin-top\bottom</code></li><li><code>border</code> 和 <code>padding</code> 可以设置，但是 <code>border-top</code> 和 <code>padding-top</code> 到页面顶部后就不再增加</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">img; <span class="hljs-comment">//可以设置宽高</span>span;label;strong;a;input; <span class="hljs-comment">//可以设置宽高</span>select; <span class="hljs-comment">//可以设置宽高</span>textarea; <span class="hljs-comment">//可以设置宽高</span></code></pre></div><h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><p><code>display line-block</code></p><p>在行内排列的块级元素</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 兼容</span>div &#123;    display： inline-block；    zoom： <span class="hljs-number">1</span>；   <span class="hljs-comment">//在IE下触发hasLayout</span>    display：inline；<span class="hljs-comment">//一旦触发了hasLayout设置display：inline和display：block效果相似。</span>&#125;</code></pre></div><h1 id="DOM元素的尺寸和位置"><a href="#DOM元素的尺寸和位置" class="headerlink" title="DOM元素的尺寸和位置"></a>DOM元素的尺寸和位置</h1><ol><li><p><code>HTMLElement.style</code>【只能获取内联样式】</p></li><li><p><code>window.getComputedStyle(HTMLElement)</code>【获取包含所有样式属性的对象</p></li><li><p><code>HTMLElement.getBoundingClientRect()</code>【描绘元素为相对窗口的矩形盒子】</p></li><li><p><code>HTMLElement.offsetWidth/offsetHeight </code> 【content+padding+border+scrollbar】</p></li><li><p><code>HTMLElement.clientWidth/clientHeight</code> 【content+padding】</p></li><li><p><code>HTMLElement.scrollWidth/scrollHeight </code>// 【包含滚出可是区域部分的clientWidth/clientHeight】</p></li><li><p><code>HTMLElement.scrollTop</code>// 【从元素的左上角开始，滚动出元素的上半部分的 width/height】</p></li></ol><p>！滚动到底</p><blockquote><p>ele.scrollHeight - ele.scrollTop === ele.clientHeight</p></blockquote><p>！元素进入可视范围(懒加载)</p><blockquote><p>要加载元素的.offsetTop - 容器.scrollTop &lt;= document.documentElement.clientHeight</p></blockquote><blockquote><p>要加载元素getBoundingClientRect()后的top &lt;= document.documentElement.clientHeight<br>！js获取这些属性会触发重排</p></blockquote><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>（Block Formatting Context） 块级格式化上下文,是一个对块级盒子的布局及浮动相互影响有特殊规则的区域</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><blockquote><p>一句话就是BFC内外不会互相影响。。。</p></blockquote><ul><li><p>BFC内盒子之间会发生外边距合并</p></li><li><p>BFC内浮动元素参与高度计算（高度塌陷）</p></li><li><p>BFC内盒子不会超出BFC边界（浮动覆盖）</p><h3 id="下列方式会创建BFC："><a href="#下列方式会创建BFC：" class="headerlink" title="下列方式会创建BFC："></a>下列方式会创建BFC：</h3><ul><li>根元素<code>HTML</code></li><li>浮动元素：<code>float</code> 不为 <code>none</code></li><li>绝对定位元素：<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code></li><li><code>overflow</code> 不为 <code>visible</code></li><li><code>display</code> 为 <code>flow-root</code></li><li>行内块元素<code>display</code> 为 <code>inline-block</code></li><li>弹性元素<code>display</code> 为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素</li><li>网格元素<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素</li><li>表格元素<code>display</code> 为 <code>table``table-cell</code>或<code>table-xxx</code>等匿名表格元素</li></ul></li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>用父元素伪类清除浮动</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-comment">/* 通用 */</span><span class="hljs-selector-class">.clearfather</span>:after &#123;  content: <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-attribute">clear</span>: both;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">overflow</span>: hidden;&#125;<span class="hljs-selector-class">.clearfather</span> &#123;  *zoom: <span class="hljs-number">1</span>; <span class="hljs-comment">/* ie6/7 */</span>&#125;</code></pre></div><ul><li>空 div 清除浮动</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfloat</span> &#123;  <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><ul><li>父元素 BFC</li></ul><p>设置能触发 BFC 的属性均可</p><h1 id="超链接伪类顺序"><a href="#超链接伪类顺序" class="headerlink" title="超链接伪类顺序"></a>超链接伪类顺序</h1><p>被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性排列顺序: <code>L-V-H-A</code></p><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;&#125;</code></pre></div><h1 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h1><p>_优雅降级_：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是旧式浏览器，则代码会针对旧版本的 IE 进行降级处理，使之在旧式浏览器上以某种形式降级体验而不至于完全不能使用。</p><p>_渐进增强_：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能，向页面增加不影响基础浏览器的额外样式和功能。当浏览器支持时，它们会自定地呈现出来并发挥作用。</p><h1 id="常见空-VOID-元素"><a href="#常见空-VOID-元素" class="headerlink" title="常见空 VOID 元素"></a>常见空 VOID 元素</h1><p><code>br、hr、img、input、link、meta</code></p><h1 id="window-load-和-DOMContentLoaded-的区别"><a href="#window-load-和-DOMContentLoaded-的区别" class="headerlink" title="window.load 和 DOMContentLoaded 的区别"></a><code>window.load</code> 和 <code>DOMContentLoaded</code> 的区别</h1><ul><li><code>window.load</code>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。</li><li><code>DOMContentLoaded</code>纯HTML加载完</li></ul><h1 id="visibilityState"><a href="#visibilityState" class="headerlink" title="visibilityState"></a><code>visibilityState</code></h1><p>通过<code>visibilityState</code>的值检测页面当前是否可见，以及打开页面的时间等<br>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</p><h1 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h1><ol><li>同层相邻块级元素之间外边距重叠</li><li>子元素与父元素的外边距重叠</li><li>空元素(margin-top直接贴到margin-bottom时)</li></ol><h1 id="link-和-import-有什么区别"><a href="#link-和-import-有什么区别" class="headerlink" title="link 和@import 有什么区别"></a>link 和@import 有什么区别</h1><ul><li><p><code>link</code>  是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS ，rel和图标等；<code>@import</code> 只能加载 CSS。</p></li><li><p><code>link</code> 支持并行下载；<code>@import</code> 串行下载且需放在样式表顶层。</p></li><li><p><code>@import</code> 是在 CSS2.1 提出的，低版本的浏览器（IE5 以下）不支持。</p></li><li><p><code>link</code> 支持使用 Javascript 控制 DOM 去改变样式；而<code>@import</code> 不支持。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型的判断与转换</title>
    <link href="/2022/02/24/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/02/24/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ECAMScript-中不能自定义数据类型，只能为下列-7-种"><a href="#ECAMScript-中不能自定义数据类型，只能为下列-7-种" class="headerlink" title="ECAMScript 中不能自定义数据类型，只能为下列 7 种"></a>ECAMScript 中不能自定义数据类型，只能为下列 7 种</h1><h2 id="简单数据类型（原始类型）"><a href="#简单数据类型（原始类型）" class="headerlink" title="简单数据类型（原始类型）"></a>简单数据类型（原始类型）</h2><ul><li><p><code>String</code></p></li><li><p><code>Number</code></p><ul><li><code>NaN</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span> === <span class="hljs-string">&#x27;number&#x27;</span>唯一一个自相反的值<span class="hljs-literal">NaN</span> !== <span class="hljs-literal">NaN</span></code></pre></div></li></ul></li><li><p><code>Boolean</code></p><ul><li>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 true，包括所有对象。</li><li>布尔值与其他类型比较都会转为数字</li></ul></li><li><p><code>null</code></p><ul><li><code>typeof null = object</code>,<em>null 表示一个空对象指针</em></li><li>null 必须手动设置，常用于作为参数传入，说明该参数不是对象</li><li>设置为 null 的变量或者对象会被内存收集器回收</li><li><code>null</code> 转为数字类型值为 <code>0</code></li></ul></li></ul><ul><li><p><code>undefined</code></p><ul><li>调用一个值而它本身没有赋值</li><li><code>undefined == null</code> </li><li><code>undefined</code> 转为数字类型为 <code>NaN</code></li></ul></li><li><p><code>Symbol</code>[ES6 新增]</p><ul><li>表示独一无二的值</li></ul></li></ul><h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><p><code>Object</code></p><ul><li>引用类型的值是指向保存在堆中的对象的指针</li><li>使用时要先从栈中读取内存地址，再沿着指针找到堆中的对象</li><li>Object</li><li>Array<ul><li>数组的每一项可以用来保存任何类型的数据</li></ul></li><li>Function<ul><li>每个函数都是 Function 的实例</li></ul></li></ul><h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><h2 id="typeOf"><a href="#typeOf" class="headerlink" title="typeOf"></a><code>typeOf</code></h2><ul><li>对未声明的变量，只有对它调用<code>typeof</code>不报错，return <code>undefined</code></li><li>特殊的几个</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &#x27;undefined&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>(); <span class="hljs-comment">// &#x27;symbol&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &#x27;object&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// number</span></code></pre></div><h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a><code>isNaN</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>));    <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">10</span>));     <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;10&quot;</span>));   <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;blue&quot;</span>)); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>));   <span class="hljs-comment">//false</span></code></pre></div><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p><code>instanceof</code> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性，但它不能检测<code>null</code> 和 <code>undefined</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span>&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span> <span class="hljs-comment">// true</span><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// error</span><span class="hljs-literal">undefined</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// error</span></code></pre></div><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-built_in">console</span>.log(arr.constructor); <span class="hljs-comment">// [Function: Array]</span><span class="hljs-built_in">console</span>.log(obj.constructor); <span class="hljs-comment">// [Function: Object]</span></code></pre></div><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// [object String]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>); <span class="hljs-comment">// [object Number]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [object Boolean]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>); <span class="hljs-comment">// [object Null]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>()); <span class="hljs-comment">// [object Function]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()); <span class="hljs-comment">// [object Date]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>()); <span class="hljs-comment">// [object RegExp]</span><span class="hljs-built_in">Object</span>.prototype.toString.call([]); <span class="hljs-comment">// [object Array]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="hljs-comment">// [object Object]</span><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()); <span class="hljs-comment">// [object Error]</span></code></pre></div><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="转为数值"><a href="#转为数值" class="headerlink" title="转为数值"></a>转为数值</h2><h3 id="Number-适用于任何类型"><a href="#Number-适用于任何类型" class="headerlink" title="Number() 适用于任何类型"></a>Number() 适用于任何类型</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">Number</span>(<span class="hljs-string">&quot;000011&quot;</span>); <span class="hljs-comment">// 11</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 1</span></code></pre></div><h3 id="parseInt-string-radix-主要用于字符串"><a href="#parseInt-string-radix-主要用于字符串" class="headerlink" title="parseInt(string, radix) 主要用于字符串"></a>parseInt(string, radix) 主要用于字符串</h3><ul><li>如果第一个字符不是数值字符、加号或减号，立即返回NaN<br>,这意味着空字符串也会返回 NaN<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 10</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-number">22.5</span>); <span class="hljs-comment">//22</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123abc&quot;</span>) <span class="hljs-comment">// 123</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].map(<span class="hljs-built_in">parseInt</span>)<span class="hljs-comment">// [1, NaN, NaN]</span><span class="hljs-comment">// map调用的回调会默认传入三个参数【当前元素，当前索引，当前数组】</span><span class="hljs-comment">// parseInt(1,0) =&gt; 1</span><span class="hljs-comment">// parseInt(2,1) =&gt; radix&gt;=2,NaN</span><span class="hljs-comment">// parseInt(3,2) =&gt; 木有二进制表示的3,NaN</span></code></pre></div><h3 id="parseFloat-string-主要用于字符串"><a href="#parseFloat-string-主要用于字符串" class="headerlink" title="parseFloat(string) 主要用于字符串"></a>parseFloat(string) 主要用于字符串</h3></li><li>只解析十进制</li><li>忽略2次出现的小数点<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;1234blue&quot;</span>); <span class="hljs-comment">// 1234</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.5&quot;</span>); <span class="hljs-comment">// 22.5</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.34.5&quot;</span>); <span class="hljs-comment">// 22.34</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0908.5&quot;</span>);  <span class="hljs-comment">//908.5</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.125e7&quot;</span>); <span class="hljs-comment">// 31250000</span></code></pre></div></li></ul><h2 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>  null和undefined没有toString()方法</p><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><ul><li><em>优先调用toString()</em></li><li>null 转换为 ‘null’</li><li>undefined 转换为 ‘undefined’</li></ul><h2 id="转为布尔值"><a href="#转为布尔值" class="headerlink" title="转为布尔值"></a>转为布尔值</h2><ul><li>Boolean()<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//除了以下六个转为 false 其他全部都为 true</span><span class="hljs-literal">undefined</span><span class="hljs-literal">null</span><span class="hljs-number">0</span>-<span class="hljs-number">0</span><span class="hljs-literal">NaN</span><span class="hljs-string">&#x27;&#x27;</span></code></pre></div></li></ul><h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><p>在 js 中，当运算符在运算时，如果两边数据不统一，CPU 就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算.这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换</p><h2 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="隐式转换规则"></a>隐式转换规则</h2><ul><li>转成 string 类型： <code>+</code>（字符串连接符）</li><li>转成 number 类型：<code>++/--</code>(自增自减运算符) <code>+ - * / %</code>(算术运算符) <code>&gt; &lt; &gt;= &lt;= == != === !===</code> (关系运算符)</li><li>转成 boolean 类型：<code>!</code>（逻辑非运算符）</li></ul><h2 id="字符串连接符与算术运算符"><a href="#字符串连接符与算术运算符" class="headerlink" title="字符串连接符与算术运算符"></a>字符串连接符与算术运算符</h2><p><code>+</code>左右有字符串则转为字符串拼接，否则转为数字计算</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//+是字符串连接符： String(1) + &#x27;true&#x27; = &#x27;1true&#x27;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">//1true</span><span class="hljs-comment">//+是算术运算符 ： 1 + Number(true) = 1 + 1 = 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//2</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(undefined) = 1 + NaN = NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//   NaN</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(null) = 1 + 0 = 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">//1</span><span class="hljs-comment">//</span></code></pre></div><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>会把其他数据类型转换成 number 之后再比较关系</p><p><em>此时并不是按照 Number()的形式转成数字，而是按照字符串对应的 unicode 编码来转成数字</em></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//true     &#x27;2&#x27;.charCodeAt() &gt; &#x27;10&#x27;.charCodeAt() = 50 &gt; 49 = true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字50</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字49（默认返回第一个字符的编码，如果想要查询第二个字符可以传参下标）</span><span class="hljs-comment">//多个字符从左往右依次比较</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">//false     先比较&#x27;a&#x27; 和 &#x27;b&#x27;， &#x27;a&#x27; 与 &#x27;b&#x27;不等，则直接得出结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;aad&quot;</span>); <span class="hljs-comment">//true     先比较&#x27;a&#x27;和&#x27;a&#x27;，两者相等，继续比较第二个字符 &#x27;b&#x27; 与 &#x27;a&#x27; ,得出结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字97</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b&quot;</span>.charCodeAt()); <span class="hljs-comment">//数字98</span><span class="hljs-comment">//2.3 特殊情况(无视规则)：如果数据类型是undefined与null，，得出固定的结果</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-comment">//2.4 特殊情况（无视规则）：NaN与任何数据比较都是NaN</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>); <span class="hljs-comment">//false</span></code></pre></div><h2 id="复杂数据类型的隐式转换"><a href="#复杂数据类型的隐式转换" class="headerlink" title="复杂数据类型的隐式转换"></a>复杂数据类型的隐式转换</h2><ol><li>先使用<code>valueOf()</code>方法获取其原始值，如果原始值不是<code>number</code>类型，则使用 <code>toString()</code>方法转成<code>string</code></li><li>再将 <code>string</code> 转成 <code>number</code> 运算</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == <span class="hljs-string">&quot;1,2&quot;</span>; <span class="hljs-comment">//true     先将左边数组转成string，然后右边也是string则转成unicode编码运算</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].valueOf(); <span class="hljs-comment">// [1,2]</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].toString(); <span class="hljs-comment">// &#x27;1,2&#x27;</span><span class="hljs-keyword">var</span> a = &#123;&#125;;a == <span class="hljs-string">&quot;[object Object]&quot;</span>; <span class="hljs-comment">//true</span>a.valueOf().toString(); <span class="hljs-comment">//[object Object]</span></code></pre></div><h2 id="逻辑非隐式转换与关系运算符"><a href="#逻辑非隐式转换与关系运算符" class="headerlink" title="逻辑非隐式转换与关系运算符"></a>逻辑非隐式转换与关系运算符</h2><blockquote><p>如果两个引用类型比较,会比较内存地址,注意要是其中有逻辑非运算符,非运算优先级会大于比较操作</p></blockquote><ul><li>空数组的 toString()方法会得到空字符串<code>&#39;&#39;</code></li><li>空对象的 toString()方法会得到字符串<code>[object Object]</code> </li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>([])); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Boolean</span>(![])); <span class="hljs-comment">// false</span><span class="hljs-comment">// Boolean除了0,-0,null,undefined,false,&#x27;&#x27;都转为true</span><span class="hljs-comment">//大坑</span><span class="hljs-built_in">console</span>.log([] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true []转数字为0</span><span class="hljs-built_in">console</span>.log(![] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true  </span><span class="hljs-comment">// 这里有逻辑非运算符,会先转Boolean,![]转布尔false，转数字为0</span><span class="hljs-comment">//神坑</span><span class="hljs-built_in">console</span>.log([] == ![]); <span class="hljs-comment">//true</span><span class="hljs-comment">// ![]转布尔false=&gt;0,0和[]比较,[]转数字为0</span><span class="hljs-built_in">console</span>.log([] == []); <span class="hljs-comment">//false // 内存地址不同</span><span class="hljs-comment">//史诗级坑</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == !&#123;&#125;); <span class="hljs-comment">//false</span><span class="hljs-comment">// &#123;&#125;最终转number为NaN,右边转数字为0</span><span class="hljs-built_in">console</span>.log(&#123;&#125; == &#123;&#125;); <span class="hljs-comment">//false // 内存地址不同</span></code></pre></div><h2 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h2><h3 id="es6-新增Object-is-判断"><a href="#es6-新增Object-is-判断" class="headerlink" title="es6 新增Object.is()判断"></a>es6 新增<code>Object.is()</code>判断</h3><p>修复了转布尔值的bug</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(-<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-number">0</span> / <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_Object</span>.<span class="hljs-title">is</span>(<span class="hljs-params">x,y</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Object</span>.is)&#123;    <span class="hljs-keyword">if</span>(x===y)&#123;      <span class="hljs-keyword">return</span> x!==<span class="hljs-number">0</span> || <span class="hljs-number">1</span>/x === <span class="hljs-number">1</span>/y    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> x!==x &amp;&amp; y!== y    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js运行机制</title>
    <link href="/2022/02/24/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/02/24/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/10714ad38f9a">ref:javascript 运行机制 EventLoop</a></p><h2 id="JS-的单线程"><a href="#JS-的单线程" class="headerlink" title="JS 的单线程"></a>JS 的单线程</h2><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程,保证执行任务的有序并复杂的同步问题。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>js主线程不断从任务队列读取任务进入执行栈执行的循环过程</p><p>因为 js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。如果遇到了异步任务，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的其他任务队列中等待执行。</p><ul><li><p>事件循环</p><ol><li>循环开始，整体函数 script 推入执行栈</li><li>执行执行栈中同步函数</li><li>遇到异步函数将其回调分别加入<em>宏任务队列</em>和<em>微任务队列</em></li><li>执行栈为空后（同步函数执行完），查看任务队列里微任务推入执行栈执行</li><li>执行完后，读取宏任务进入执行栈执行</li><li>执行该宏任务，如果该宏任务继续产生微任务则执行完微任务才能继续往下执行<br>blahblahblah。。。</li></ol></li></ul><h2 id="微任务-宏任务"><a href="#微任务-宏任务" class="headerlink" title="微任务/宏任务"></a>微任务/宏任务</h2><p>任务被分为两类：微任务（<code>micro task</code>）和宏任务（<code>macro task</code>），可以理解为一个完整执行的宏大任务就是一次事件循环。</p><ul><li><p>  JS 的事件循环中每个宏任务的末尾会追加一个微任务队列，宏任务执行完后会先去执行完这个微任务队列再进入下一个循环。</p></li><li><p>微任务（js引擎自己发起的任务）包括 <code>process.nextTick</code> ，<code>promise.then</code> ，<code>catch</code>,<code>finally</code> ，<code>MutationObserver</code></p><ul><li>  NOTE:遇到<code>nextTick</code>会提到微任务的栈顶</li><li>  NOTE:遇到 <code>await</code>时,对<code>await</code>右侧进行计算,接着先去去执行<code>async</code>外部的同步函数,后再回到<code>async</code>函数中</li></ul></li><li><p>  宏任务（宿主环境[浏览器，node]下发的任务）包括 <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code>操作 ，<code>UI</code>渲染</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li><p>```javascript<br> // 1<br> console.log(“script start”); // 1</p><p> setTimeout(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;setTimeout&quot;); // 4</code></pre></div><p> }, 0);</p><p> Promise.resolve()</p><div class="hljs code-wrapper"><pre><code class="hljs"> .then(function () &#123;     console.log(&quot;promise1&quot;); //2 &#125;) .then(function () &#123;     console.log(&quot;promise2&quot;); //3 &#125;);</code></pre></div> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="javascript">javascript</span><span class="javascript">    <span class="hljs-comment">// 2</span></span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span></span><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// 5</span></span><span class="javascript">    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//7</span></span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>); <span class="hljs-comment">//6</span></span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">//8</span></span><span class="javascript">    &#125;);</span><span class="javascript">    &#125;);</span><span class="javascript">    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span></span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span></span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span></span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span></span><span class="javascript">    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span></span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span></span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);</span><span class="javascript">    &#125;); <span class="hljs-comment">//12</span></span><span class="javascript">    &#125;);</span></code></pre></div></li><li><p>```javascript<br> // 3<br> async function async1() {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(1); //1 new Promise(() =&gt; &#123;     console.log(2); //2 &#125;); Promise.resolve().then(() =&gt; &#123;     console.log(&quot;异步3&quot;); //6 &#125;); console.log(&quot;同步3&quot;); //3</code></pre></div><p> }</p><p> Promise.resolve().then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(4); //5</code></pre></div><p> });</p><p> setTimeout(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(5); //7</code></pre></div><p> });</p><p> async1();</p><p> console.log(6); //4</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="javascript">javascript</span><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;定时器开始啦&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;马上执行for循环啦&quot;</span>);</span><span class="javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span><span class="javascript">    i == <span class="hljs-number">99</span> &amp;&amp; resolve();</span><span class="javascript">    &#125;</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;执行then函数啦&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;代码执行结束&quot;</span>);</span><span class="javascript">    <span class="hljs-comment">// 马上执行for循环啦</span></span><span class="javascript">    <span class="hljs-comment">// 代码执行结束</span></span><span class="javascript">    <span class="hljs-comment">// 执行then函数啦</span></span><span class="javascript">    <span class="hljs-comment">// 定时器开始啦</span></span></code></pre></div></li><li><p>```javascript<br> setTimeout(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;setTimeout&quot;);</code></pre></div><p> });</p><p> new Promise(function (resolve) {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise&quot;); resolve();</code></pre></div><p> }).then(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;then&quot;);</code></pre></div><p> });</p><p> console.log(“console”);</p><p> // promise<br> // console<br> // then<br> // setTimeout</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="javascript">javascript</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);</span><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-comment">// console.log(&#x27;2&#x27;);</span></span><span class="javascript">    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-comment">// console.log(&#x27;4&#x27;);</span></span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    &#125;);</span><span class="javascript">    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    &#125;);</span></code></pre></div></li><li><p>```javascript<br> setTimeout(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(1);</code></pre></div><p> }, 0);<br> Promise.resolve().then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(2);</code></pre></div><p> });<br> console.log(3);</p><p> // 3 2<br> // 1</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="javascript">javascript</span><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);</span><span class="javascript">    &#125;, <span class="hljs-number">0</span>);</span><span class="javascript">    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);</span><span class="javascript">    <span class="hljs-comment">// 2 5 3 4</span></span><span class="javascript">    <span class="hljs-comment">// 1</span></span></code></pre></div></li><li><p>```javascript<br> let a = new Promise((resolve) =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(2); resolve();</code></pre></div><p> }).then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(5);</code></pre></div><p> });<br> a.then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(3);</code></pre></div><p> });<br> a.then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(4);</code></pre></div><p> });</p><p> // 2 5 3 4</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="javascript">javascript</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>);</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-comment">// promise1,then11,promise2,then21,then12,then23</span></span></code></pre></div></li><li><p>```javascript<br> new Promise((resolve, reject) =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise1&quot;); resolve();</code></pre></div><p> })</p><div class="hljs code-wrapper"><pre><code class="hljs"> .then(() =&gt; &#123;     console.log(&quot;then11&quot;);     return new Promise((resolve, reject) =&gt; &#123;         console.log(&quot;promise2&quot;);         resolve();     &#125;)         .then(() =&gt; &#123;             console.log(&quot;then21&quot;);         &#125;)         .then(() =&gt; &#123;             console.log(&quot;then23&quot;);         &#125;); &#125;) .then(() =&gt; &#123;     console.log(&quot;then12&quot;); &#125;);</code></pre></div><p> // promise1 then11  promise2 then21 then12  then23</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="javascript">javascript</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then11&quot;</span>);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then21&quot;</span>);</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then23&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    &#125;)</span><span class="javascript">    .then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then12&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise3&quot;</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then31&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-comment">//promise1 promise3 then11 promise2 then31 then21 then12 then23</span></span></code></pre></div></li><li><p>```javascript<br> async function async1() {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);</code></pre></div><p> }</p><p> async function async2() {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;async2&quot;);</code></pre></div><p> }</p><p> console.log(“script start”);</p><p> setTimeout(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;settimeout&quot;);</code></pre></div><p> }, 0);</p><p> async1();</p><p> new Promise(function (resolve) {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise1&quot;); resolve();</code></pre></div><p> }).then(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise2&quot;);</code></pre></div><p> });<br> console.log(“script end”);</p><p> // script start,async1 start,async2,promise1,script end,async1 end,promise2<br> // settimeout</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="javascript">javascript</span><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 start&quot;</span>);</span><span class="javascript">    <span class="hljs-keyword">await</span> async2();</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async1 end&quot;</span>);</span><span class="javascript">    &#125;</span><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;async2&quot;</span>);</span><span class="javascript">    &#125;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>);</span><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;settimeout&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    async1();</span><span class="javascript">    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>);</span><span class="javascript">    resolve();</span><span class="javascript">    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    setImmediate(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setImmediate&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    process.nextTick(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;process&quot;</span>);</span><span class="javascript">    &#125;);</span><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script end&quot;</span>);</span><span class="javascript">    <span class="hljs-comment">//script start,async1 start,async2,promise1,script end,process,async1 end,promise2</span></span><span class="javascript">    <span class="hljs-comment">//sttimeout,setImmediate</span></span></code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js模块化</title>
    <link href="/2022/02/24/js%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2022/02/24/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>模块化的演进过程</p></blockquote><ol><li>文件划分</li><li>命名空间 (将每个模块暴露在全局对象</li><li>IIFE 立即执行函数 </li></ol><h2 id="模块化开发的思想"><a href="#模块化开发的思想" class="headerlink" title="模块化开发的思想"></a>模块化开发的思想</h2><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p><h3 id="CommonJS-Node-js"><a href="#CommonJS-Node-js" class="headerlink" title="CommonJS (Node.js)"></a>CommonJS (Node.js)</h3><ul><li><p>运行在服务端</p></li><li><p>代码同步加载</p></li><li><p>代码可以多次加载，但是运行结果会被缓存</p></li><li><p><code>require(&#39;xxx&#39;)</code>加载模块</p></li><li><p><code>module.exports=&#123;&#125;</code>(全局变量或方法)或<code>exports</code>定义对外的接口</p></li></ul><h3 id="AMD-require-js"><a href="#AMD-require-js" class="headerlink" title="AMD (require.js)"></a>AMD (require.js)</h3><ul><li><code>Async Module Definition</code></li><li>依赖前置，定义模块时就要声明依赖</li><li>代码异步加载，且谁先加载完执行谁  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// AMD</span>define(<span class="hljs-string">&quot;fooModule&quot;</span>,[<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;        a.doSomething();        b.doSomething();    <span class="hljs-comment">// ...可能b比a先执行了</span>    &#125;    <span class="hljs-keyword">return</span>&#123;        foo    &#125;    <span class="hljs-built_in">exports</span>.xxx = ...    <span class="hljs-built_in">module</span>.exports = ...&#125;);<span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;fooModule&quot;</span>,<span class="hljs-string">&#x27;./fooModule.js&#x27;</span>],<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span>,file</span>) </span>&#123;&#125;)</code></pre></div></li></ul><h3 id="CMD-sea-js"><a href="#CMD-sea-js" class="headerlink" title="CMD (sea.js)"></a>CMD (sea.js)</h3><ul><li><code>Common Module Definition</code></li><li> 定义和加载与AMD相同</li><li> 依赖可以就近书写</li><li>依赖全部加载完才按顺序执行  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CMD</span>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);    a.doSomething();    <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>);     b.doSomething();    <span class="hljs-built_in">exports</span>.xxx = ...    <span class="hljs-built_in">module</span>.exports = ...&#125;);</code></pre></div></li></ul><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><ul><li> <code>Universal Module Definition</code></li><li> 写法是一个自运行函数</li><li> 兼容CMD/AMD/命名空间</li></ul><h3 id="ES6-MODULE"><a href="#ES6-MODULE" class="headerlink" title="ES6 MODULE"></a>ES6 MODULE</h3><ul><li><p>！ES6模块不是对象，<code>import</code>指向的是模块的的只读引用（<strong>动态引用</strong>），<code>export</code>只是显式指定输出的代码</p></li><li><p>编译时加载,用到才执行</p></li><li><p><code>export</code>导出模块,提供<code>export default</code>制定默认输出</p></li><li><p><code>import</code>引入</p></li><li><p><code>import</code>和<code>export</code>命令只能写在代码顶层</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;    <span class="hljs-keyword">return</span> x * y;&#125;<span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> add;<span class="hljs-comment">// app.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;</code></pre></div></li></ul><h3 id="ES6-MODULE和CommonJS的区别"><a href="#ES6-MODULE和CommonJS的区别" class="headerlink" title="ES6 MODULE和CommonJS的区别"></a>ES6 MODULE和CommonJS的区别</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS模块</span><span class="hljs-comment">// 运行时加载</span><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">let</span> stat = _fs.stat;<span class="hljs-keyword">let</span> exists = _fs.exists;<span class="hljs-keyword">let</span> readfile = _fs.readfile;<span class="hljs-comment">//上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”</span>modules.exports xxx<span class="hljs-comment">//CommonJS 模块输出的是值的拷贝，输出后模块内部的变化就影响不到这个值</span><span class="hljs-comment">// ES6</span><span class="hljs-comment">// 编译时加载</span><span class="hljs-keyword">import</span> &#123; stat, exists, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<span class="hljs-comment">//编译时就完成模块加载，（确定了指针</span><span class="hljs-comment">//当然，这也导致了没法引用 ES6 模块本身，因为它不是对象</span><span class="hljs-built_in">exports</span> <span class="hljs-keyword">default</span> xxx<span class="hljs-comment">// ES6 MODULES输出的是值的引用，运行时才到指定模块中取值</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待整理的js片段</title>
    <link href="/2022/02/24/js%E7%89%87%E6%AE%B5/"/>
    <url>/2022/02/24/js%E7%89%87%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<ul><li>字母的所有组合</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> anagrams = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(str.length===<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> [str , str[<span class="hljs-number">1</span>] + str[<span class="hljs-number">0</span>]]  <span class="hljs-comment">// 手写长度为2时候的排列</span>  <span class="hljs-comment">// 这里使用reduce的第三个参数index，正在处理的元素</span>  <span class="hljs-comment">// 如果提供了initialValue，则起始索引号为0，否则从索引1起始。</span>  <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>).reduce(<span class="hljs-function">(<span class="hljs-params">acc,cur,index</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> other = str.slice(<span class="hljs-number">0</span>,index)+str.slice(index+<span class="hljs-number">1</span>)    <span class="hljs-comment">// other为除了当前处理元素外的字母</span>    <span class="hljs-comment">// a bcd =&gt;</span>    <span class="hljs-comment">// b cd =&gt; bcd bdc</span>    <span class="hljs-comment">// c bd =&gt; cbd cdb</span>    <span class="hljs-comment">// d bc =&gt; dbc dcb</span>    <span class="hljs-comment">// b...</span>    <span class="hljs-keyword">return</span> acc.push(anagrams(other).map(<span class="hljs-function"><span class="hljs-params">char</span>=&gt;</span>cur+char))    <span class="hljs-comment">// 递归至两位数数组颠倒排序,并将所有可能与当前处理元素组合</span>  &#125;,[])  <span class="hljs-comment">// 指定initialValue</span>&#125;anagrams(<span class="hljs-string">&#x27;abcd&#x27;</span>) =&gt; [  <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-string">&#x27;abdc&#x27;</span>, <span class="hljs-string">&#x27;acbd&#x27;</span>,  <span class="hljs-string">&#x27;acdb&#x27;</span>, <span class="hljs-string">&#x27;adbc&#x27;</span>, <span class="hljs-string">&#x27;adcb&#x27;</span>,  <span class="hljs-string">&#x27;bacd&#x27;</span>, <span class="hljs-string">&#x27;badc&#x27;</span>, <span class="hljs-string">&#x27;bcad&#x27;</span>,  <span class="hljs-string">&#x27;bcda&#x27;</span>, <span class="hljs-string">&#x27;bdac&#x27;</span>, <span class="hljs-string">&#x27;bdca&#x27;</span>,  <span class="hljs-string">&#x27;cabd&#x27;</span>, <span class="hljs-string">&#x27;cadb&#x27;</span>, <span class="hljs-string">&#x27;cbad&#x27;</span>,  <span class="hljs-string">&#x27;cbda&#x27;</span>, <span class="hljs-string">&#x27;cdab&#x27;</span>, <span class="hljs-string">&#x27;cdba&#x27;</span>,  <span class="hljs-string">&#x27;dabc&#x27;</span>, <span class="hljs-string">&#x27;dacb&#x27;</span>, <span class="hljs-string">&#x27;dbac&#x27;</span>,  <span class="hljs-string">&#x27;dbca&#x27;</span>, <span class="hljs-string">&#x27;dcab&#x27;</span>, <span class="hljs-string">&#x27;dcba&#x27;</span>]</code></pre></div><ul><li>Deep flatten array</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> deepFlatten = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">a, v</span>) =&gt;</span> a.concat(<span class="hljs-built_in">Array</span>.isArray(v) ? deepFlatten(v) : v), []);<span class="hljs-comment">// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5]</span></code></pre></div><ul><li>bifurcate</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bifurcate = <span class="hljs-function">(<span class="hljs-params">arr, filter</span>) =&gt;</span>  arr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, val, i</span>) =&gt;</span> (acc[filter[i] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>].push(val), acc), [    [],    [],  ]);bifurcate([<span class="hljs-string">&quot;beep&quot;</span>, <span class="hljs-string">&quot;boop&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>]);<span class="hljs-comment">// [ [&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;bar&#x27;], [&#x27;foo&#x27;] ]</span></code></pre></div><ul><li>阶乘</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> factorial = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> (n &lt;= <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : n * factorial(n - <span class="hljs-number">1</span>));<span class="hljs-comment">// factorial(6) -&gt; 720</span></code></pre></div><ul><li>斐波那契数组生成器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fibonacci = <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span>  <span class="hljs-built_in">Array</span>(n)    .fill(<span class="hljs-number">0</span>)    .reduce(      (acc, val, i) =&gt; acc.concat(i &gt; <span class="hljs-number">1</span> ? acc[i - <span class="hljs-number">1</span>] + acc[i - <span class="hljs-number">2</span>] : i),      []    );<span class="hljs-comment">// fibonacci(5) -&gt; [0,1,1,2,3]</span><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fib</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> [pre, cur] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];  <span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-comment">// 死循环的另一种写法</span>    <span class="hljs-comment">// while(true)</span>    [pre, cur] = [cur, cur + pre];    <span class="hljs-keyword">yield</span> cur;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> fib()) &#123;  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-built_in">console</span>.log(x);&#125;</code></pre></div><ul><li>数组中唯一值</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> filterNonUnique = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span>  arr.filter(<span class="hljs-function">(<span class="hljs-params">i</span>) =&gt;</span> arr.indexOf(i) === arr.lastIndexOf(i));<span class="hljs-comment">// filterNonUnique([1,2,2,3,4,4,5]) -&gt; [1,3,5]</span></code></pre></div><ul><li>最大公约数（GCD）</li></ul><p>使用递归。基本情况是当 y 等于 0 时。在这种情况下，返回 x。否则，返回 y 的 GCD 和 x / y 的其余部分。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> gcd = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> (!y ? x : gcd(y, x % y));<span class="hljs-comment">// gcd (8, 36) -&gt; 4</span></code></pre></div><ul><li>范围内生成数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> initializeArrayRange = <span class="hljs-function">(<span class="hljs-params">end, start = <span class="hljs-number">0</span></span>) =&gt;</span>  <span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, <span class="hljs-built_in">Array</span>(end - start)).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> i + start);<span class="hljs-comment">// initializeArrayRange(5) -&gt; [0,1,2,3,4]</span></code></pre></div><ul><li>function 计时</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> timeTaken = <span class="hljs-function">(<span class="hljs-params">callback</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;timeTaken&quot;</span>);  <span class="hljs-keyword">const</span> r = callback();  <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;timeTaken&quot;</span>);  <span class="hljs-keyword">return</span> r;&#125;;<span class="hljs-comment">// timeTaken(() =&gt; Math.pow(2, 10)) -&gt; 1024</span><span class="hljs-comment">// (logged): timeTaken: 0.02099609375ms</span></code></pre></div><ul><li>RGB 转十六进制</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> rgbToHex = <span class="hljs-function">(<span class="hljs-params">r, g, b</span>) =&gt;</span>  ((r &lt;&lt; <span class="hljs-number">16</span>) + (g &lt;&lt; <span class="hljs-number">8</span>) + b).toString(<span class="hljs-number">16</span>).padStart(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;0&quot;</span>);<span class="hljs-comment">// rgbToHex(255, 165, 1) -&gt; &#x27;ffa501&#x27;</span></code></pre></div><ul><li>字符串按字母排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sortCharactersInString = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span>  str    .split(<span class="hljs-string">&quot;&quot;</span>)    .sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.localeCompare(b))    .join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// sortCharactersInString(&#x27;cabbage&#x27;) -&gt; &#x27;aabbceg&#x27;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链与闭包</title>
    <link href="/2022/02/24/js%E9%97%AD%E5%8C%85/"/>
    <url>/2022/02/24/js%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><h2 id="作用域：变量可以起作用的范围"><a href="#作用域：变量可以起作用的范围" class="headerlink" title="作用域：变量可以起作用的范围"></a>作用域：变量可以起作用的范围</h2><ul><li><p>全局作用域</p><p>变量在函数外内声明</p><ul><li><code>全局变量</code>：在任何地方都可以访问到的变量，关闭网页或浏览器才会销毁</li></ul></li><li><p>函数作用域（局部作用域）</p><p>变量在函数内声明</p><ul><li><code>局部变量</code>：只在固定的代码片段内可访问到的变量,在函数开始执行时创建，函数执行完后<code>局部变量</code>会自动销毁。</li></ul></li><li><p>块级作用域（es5）</p><p>任何一对花括号<code>&#123;&#125;</code>中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为 <code>块级作用域</code></p></li><li><p>词法作用域</p><p>js的作用域范围在书写时就已经确定，不受代码执行的动态影响。（静态作用域）</p></li><li><p>自由变量</p><p>当前作用域没有定义的变量，这成为<code>自由变量</code>（既不是局部变量也不是函数参数）</p><ul><li>自由变量会向父级作用域中寻找</li><li><strong>自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时的作用域</strong></li></ul></li></ul><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p><p>js中的代码在执行时会创建执行上下文,而执行上下文中会包含对别的词法环境的引用从而对其访问,这样递归访问至全局作用域的链条成为<em>作用域链</em></p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul><li><p>函数与其词法环境共同构成 <em>闭包（closure）</em> 。</p></li><li><p>词法环境 = 代码内变量标识符与值之间的关联关系（环境记录）+ 对外部词法环境的引用</p></li><li><p>所有函数会自动通过隐藏的 [[Environment]] 属性记住创建它们的位置,保存对其创建位置的此法环境的引用.</p></li></ul><h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ul><li><p>实现数据(变量和方法)私有化</p></li><li><p>函数柯里化</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">func,...args1</span>)</span>&#123;  <span class="hljs-keyword">const</span> fnLen = func.length  <span class="hljs-keyword">const</span> argsArr = [...args1]  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_curry</span>(<span class="hljs-params">...args2</span>)</span>&#123;    argsArr = [argsArr,...args2]    <span class="hljs-keyword">return</span> argsArr.length &gt;= fnLen ? func.apply(<span class="hljs-built_in">this</span>,argsArr) : _curry  &#125;  <span class="hljs-keyword">return</span> _curry&#125;<span class="hljs-comment">// 传世经典累加函数add</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...args1</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = [...args1].reduce(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a+b)  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerAdd</span>(<span class="hljs-params">...args2</span>)</span>&#123;    res = [...res,...args2].reduce(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a+b)    <span class="hljs-keyword">return</span> innerAdd  &#125;  innerAdd.toString = <span class="hljs-function">() =&gt;</span> res  <span class="hljs-comment">// 打印方法会调用toString</span>  <span class="hljs-keyword">return</span> innerAdd&#125;</code></pre></div></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addCounter</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// 执行结束后不会被清除</span>  <span class="hljs-keyword">const</span> myFunction = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    counter = counter + <span class="hljs-number">1</span>; <span class="hljs-comment">// myFunction函数可以读取add函数内部的变量</span>    <span class="hljs-keyword">return</span> counter;  &#125;;  <span class="hljs-keyword">return</span> myFunction;&#125;<span class="hljs-keyword">const</span> increment = addCounter();<span class="hljs-keyword">const</span> c1 = increment();<span class="hljs-keyword">const</span> c2 = increment();<span class="hljs-keyword">const</span> c3 = increment();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;increment:&quot;</span>, c1, c2, c3);<span class="hljs-comment">// increment: 1 2 3</span></code></pre></div><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>老生常谈的for循环setTimeout打印问题<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i)  &#125;, <span class="hljs-number">1000</span> * i)&#125;<span class="hljs-comment">// 6 6 6 6 6 6</span><span class="hljs-comment">// 创建的6个setTimeout闭包共享一个词法作用域</span>**闭包只能取得包含函数中任何变量赋值最后一个值** <span class="hljs-comment">// 6</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  (<span class="hljs-function">(<span class="hljs-params">j</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-built_in">console</span>.log(j)    &#125;, <span class="hljs-number">1000</span> * j)  &#125;)(i)&#125;<span class="hljs-comment">// 1 2 3 4 5 6</span><span class="hljs-comment">// 6个setTimeout闭包有自己独立的词法环境</span><span class="hljs-comment">// 闭包读取到不同的i值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span> ;i&lt;<span class="hljs-number">7</span>;i++)&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(j);  &#125;,<span class="hljs-number">1000</span>*i,i)&#125;<span class="hljs-comment">// setTimeout 可以接受一个参数当函数调用时传入</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ;i&lt;<span class="hljs-number">7</span>;i++)&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(i);  &#125;,<span class="hljs-number">1000</span>*i)&#125;</code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">num2</span>) </span>&#123;  <span class="hljs-keyword">var</span> num = <span class="hljs-number">15</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abc</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 函数作为返回值</span>    num++;    <span class="hljs-keyword">return</span>(num + num2);  &#125;  <span class="hljs-keyword">return</span> abc;&#125;<span class="hljs-keyword">var</span> aa = fn(<span class="hljs-number">20</span>); <span class="hljs-comment">//  没有引用？？</span>aa(); <span class="hljs-comment">//16+20</span>aa(); <span class="hljs-comment">//17+20</span>fn(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span>fn(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2022/02/24/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/02/24/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>ref:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md">https://github.com/CyC2018</a></p><h2 id="面向对象的设计思想"><a href="#面向对象的设计思想" class="headerlink" title="面向对象的设计思想"></a>面向对象的设计思想</h2><p>面向对象的设计思想是从自然界中来的，因为在自然界中就存在类（Class）和实例（Instance）的概念。</p><ul><li><p>  Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，</p></li><li><p>  而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。</p></li><li><p>  面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现。</p></li><li><p>  面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p></li></ul><h2 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><ul><li>  减少耦合：可以独立地开发和测试</li><li>  减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能<br>  提高软件的可重用性</li><li>  降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</span><span class="hljs-comment">// 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    private <span class="hljs-built_in">String</span> name;    private int gender;    private int age;    <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getGender</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> gender == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;man&quot;</span> : <span class="hljs-string">&quot;woman&quot;</span>;    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">work</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="hljs-number">50</span>) &#123;            System.out.println(name + <span class="hljs-string">&quot; is working very hard!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.println(name + <span class="hljs-string">&quot; can&#x27;t work any more!&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>  子类可以访问父类非 private 属性</p></li><li><p>  里氏替换原则，子类对象必须能够替换掉父类对象。</p></li><li><p>  提高代码的复用性，继承是多态的前提。</p></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li><p>  父类或接口定义的引用变量可以指向子类或实例对象，即多种不同状态</p></li><li><p>  提高了程序的扩展性</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 的方法。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrument</span> </span>&#123;    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Instument is playing...&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span> </span>&#123;    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span> </span>&#123;    <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">play</span>(<span class="hljs-params"></span>)</span> &#123;        System.out.println(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;        List&lt;Instrument&gt; instruments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        instruments.add(<span class="hljs-keyword">new</span> Wind());        instruments.add(<span class="hljs-keyword">new</span> Percussion());        <span class="hljs-keyword">for</span>(Instrument instrument : instruments) &#123;            instrument.play();        &#125;    &#125;&#125;</code></pre></div><h2 id="六大基本原则："><a href="#六大基本原则：" class="headerlink" title="六大基本原则："></a>六大基本原则：</h2><ul><li><p><code>Single Responsibility Principle：单一职责原则</code></p><p>  一个类应该只有一个发生变化的原因，只负责一项职责</p></li><li><p><code>Open Closed Principle：开闭原则</code></p><p>  对修改封闭，对拓展开放</p></li><li><p><code>Liskov Substitution Principle：里氏替换原则</code></p><p>  子类能完全替代父类</p></li><li><p><code>Law of Demeter：迪米特法则</code></p><p>  功能模块之间尽量减少相互作用，保持相互独立</p></li><li><p><code>Interface Segregation Principle：接口隔离原则</code></p><p>  用多个借口将功能解耦</p></li><li><p><code>Dependence Inversion Principle：依赖倒置原则</code></p><p>  高层模块不应该依赖低层模块，二者都应该依赖其抽象，对抽象接口进行编程</p></li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><code>JavaScript</code> 是一种基于原型的语言 (prototype-based language)</p><p>区别于其他面向对象的语言实例中复制父类的全部属性，js 则使用原型去访问公有属性。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>每个构造函数都有一个原型对象，而每个实例都包含一个指向原型对象的内部指针<code>__proto__</code>。如果这个原型对象是另一个构造函数的实例，则这个原型对象也可以访问自己的原型对象，这样层层递进链式访问的关系就叫做<code>原型链</code>。</p><p>js 中查找属性时，先查找实例自身，后查找原型对象，再沿着原型链不断上溯，直到原型链的尽头.</p><h3 id="特殊的Object和Function"><a href="#特殊的Object和Function" class="headerlink" title="特殊的Object和Function"></a>特殊的<code>Object</code>和<code>Function</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>.prototype = <span class="hljs-string">&quot;function&quot;</span><span class="hljs-built_in">Function</span>.prototype = <span class="hljs-built_in">Function</span>.__proto__<span class="hljs-comment">//f()&#123;[native code]&#125;</span><span class="hljs-comment">// 所有引用类型都继承自Object</span><span class="hljs-built_in">Function</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype <span class="hljs-comment">// true</span></code></pre></div><h3 id="只有函数才有prototype"><a href="#只有函数才有prototype" class="headerlink" title="只有函数才有prototype"></a>只有函数才有<code>prototype</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;&#125;f1.__proto__ === <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-comment">// f1直接由Function构造而来</span><span class="hljs-keyword">const</span> obj1 = &#123;&#125;;obj1.prototype; <span class="hljs-comment">// undefined</span></code></pre></div><h3 id="原形链的终点"><a href="#原形链的终点" class="headerlink" title="原形链的终点"></a>原形链的终点</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.prototype === <span class="hljs-string">&#x27;object&#x27;</span><span class="hljs-comment">// 意味着Object的原型是也是一个对象</span><span class="hljs-comment">// 而对象的构造器也是Object，则会出现死循环</span>！【<span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype】！<span class="hljs-comment">// 为了让原型链有终点。Javascript规定，</span><span class="hljs-built_in">Object</span>.prototype.__proto__ === <span class="hljs-literal">null</span></code></pre></div><p><img src="../images/proto.png" alt="proto"></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;f1.__proto__ = <span class="hljs-built_in">Function</span>.prototype = <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123; [native code] &#125;f1.__proto__.__proto__ = <span class="hljs-built_in">Object</span>.prototype = &#123;<span class="hljs-attr">constructor</span>: ƒ, <span class="hljs-attr">__defineGetter__</span>: ƒ, <span class="hljs-attr">__defineSetter__</span>: ƒ, <span class="hljs-attr">hasOwnProperty</span>: ƒ, <span class="hljs-attr">__lookupGetter__</span>: ƒ, …&#125;f1.__proto__.__proto__.__proto__ = <span class="hljs-literal">null</span><span class="hljs-keyword">const</span> obj = &#123;&#125;obj.__proto__ = <span class="hljs-built_in">Object</span>.prototypeobj.__proto__.__proto__ = <span class="hljs-literal">null</span></code></pre></div><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><ul><li><p><code>Object.getPrototype()</code>/<code>__proto__</code></p><p>  返回指定对象的原型（隐式原型）</p><p>  <code>__proto__</code>虽然在绝大数浏览器都能正常工作，但官方不推荐且已标为废弃，使用<code>Object.getPrototypeOf()</code>替代</p></li><li><p><code>Object.prototype.isPrototypeOf()</code></p><p>  判断对象是否在另一个对象原型链上</p></li></ul><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><ol><li>函数的 <code>this</code> 指向函数运行时的执行上下文</li><li>当函数被当作对象的方法调用时,<code>this</code> 指向调用对象</li><li>new 操作符生成的对象 <code>this</code> 指向自己</li><li>箭头函数的<code>this</code>取决于外部函数体的<code>this</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js面试题集</title>
    <link href="/2022/02/24/js%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <url>/2022/02/24/js%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li>  实现 EventEmitter</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 请实现下面的自定义事件 Event 对象的接口，功能见注释(测试1)</span><span class="hljs-comment">// 该 Event 对象的接口需要能被其他对象拓展复用(测试2)</span><span class="hljs-comment">// 测试1</span>Event.on(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(result);&#125;);Event.on(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;test&quot;</span>);&#125;);Event.emit(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// 输出 &#x27;hello world&#x27; 和 &#x27;test&#x27;</span><span class="hljs-comment">// 测试2</span><span class="hljs-keyword">var</span> person1 = &#123;&#125;;<span class="hljs-keyword">var</span> person2 = &#123;&#125;;<span class="hljs-built_in">Object</span>.assign(person1, Event);<span class="hljs-built_in">Object</span>.assign(person2, Event);person1.on(<span class="hljs-string">&quot;call1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;person1&quot;</span>);&#125;);person2.on(<span class="hljs-string">&quot;call2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;person2&quot;</span>);&#125;);person1.emit(<span class="hljs-string">&quot;call1&quot;</span>); <span class="hljs-comment">// 输出 &#x27;person1&#x27;</span>person1.emit(<span class="hljs-string">&quot;call2&quot;</span>); <span class="hljs-comment">// 没有输出</span>person2.emit(<span class="hljs-string">&quot;call1&quot;</span>); <span class="hljs-comment">// 没有输出</span>person2.emit(<span class="hljs-string">&quot;call2&quot;</span>); <span class="hljs-comment">// 输出 &#x27;person2&#x27;</span><span class="hljs-keyword">var</span> Event = &#123;<span class="hljs-comment">// 通过on接口监听事件eventName</span><span class="hljs-comment">// 如果事件eventName被触发，则执行callback回调函数</span>on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName, callback</span>) </span>&#123;<span class="hljs-comment">//你的代码</span>&#125;,<span class="hljs-comment">// 触发事件 eventName</span>emit: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">eventName</span>) </span>&#123;<span class="hljs-comment">//你的代码</span>&#125;,&#125;;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Event = &#123;on: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, cb</span>) </span>&#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.handlers) &#123;<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;handlers&quot;</span>, &#123;value: &#123;&#125;,enumerable: <span class="hljs-literal">false</span>,configurable: <span class="hljs-literal">true</span>,writable: <span class="hljs-literal">true</span>,&#125;);&#125;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.handlers[name]) &#123;<span class="hljs-built_in">this</span>.handlers[name] = [];&#125;<span class="hljs-built_in">this</span>.handles[name].push(cb);&#125;,emit: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, ...args</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlers[name]) &#123;<span class="hljs-built_in">this</span>.handlers[name].forEach(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> &#123;cb(...args);&#125;);&#125;&#125;,&#125;;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Events</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-built_in">this</span>.events = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();&#125;<span class="hljs-function"><span class="hljs-title">addEvent</span>(<span class="hljs-params">key, fn, isOnce, ...args</span>)</span> &#123;<span class="hljs-keyword">const</span> curEvent = <span class="hljs-built_in">this</span>.events.get(key) ? <span class="hljs-built_in">this</span>.events.get(key) : <span class="hljs-built_in">this</span>.events.set(key, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()).get(key);curEvent.set(fn, <span class="hljs-function">(<span class="hljs-params">...args2</span>) =&gt;</span> &#123;fn(...args, ...args2);<span class="hljs-keyword">if</span> (isOnce) <span class="hljs-built_in">this</span>.off(key, fn);&#125;);&#125;<span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">key, fn, ...args</span>)</span> &#123;<span class="hljs-built_in">this</span>.addEvent(key, fn, <span class="hljs-literal">false</span>, ...args);&#125;<span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">key, fn, ...args</span>)</span> &#123;<span class="hljs-built_in">this</span>.addEvent(key, fn, <span class="hljs-literal">true</span>, ...args);&#125;<span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">key, fn</span>)</span> &#123;<span class="hljs-built_in">this</span>.events.get(key).delete(fn);&#125;<span class="hljs-function"><span class="hljs-title">fire</span>(<span class="hljs-params">key, ...args</span>)</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.events.get(key));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> cb <span class="hljs-keyword">of</span> <span class="hljs-built_in">this</span>.events.get(key).values()) &#123;cb(...args);&#125;&#125;&#125;<span class="hljs-comment">// 请使用原生代码实现一个Events模块，可以实现自定义事件的订阅、触发、移除功能</span><span class="hljs-keyword">const</span> fn1 = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I want sleep1&quot;</span>, ...args);<span class="hljs-keyword">const</span> fn2 = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I want sleep2&quot;</span>, ...args);<span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> Events();event.on(<span class="hljs-string">&quot;sleep&quot;</span>, fn1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.on(<span class="hljs-string">&quot;sleep&quot;</span>, fn2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.fire(<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">// I want sleep1 1 2 3 4 5 6</span><span class="hljs-comment">// I want sleep2 1 2 3 4 5 6</span>event.off(<span class="hljs-string">&quot;sleep&quot;</span>, fn1);event.once(<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I want sleep&quot;</span>));event.fire(<span class="hljs-string">&quot;sleep&quot;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span><span class="hljs-comment">// I want sleep</span>event.fire(<span class="hljs-string">&quot;sleep&quot;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span></code></pre></div><ul><li>  执行顺序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promishe&quot;</span>);&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;then&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;console&quot;</span>);<span class="hljs-comment">//执行结果</span><span class="hljs-comment">//promise</span><span class="hljs-comment">//console</span><span class="hljs-comment">//then</span><span class="hljs-comment">//setTimeout</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-comment">//2</span><span class="hljs-comment">//4</span><span class="hljs-comment">//3</span><span class="hljs-comment">//1</span><span class="hljs-comment">//then是Promise的微任务,new Promise</span></code></pre></div><ul><li>  实现<code>instance of</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// r是否在l原型链上游</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instance_of</span>(<span class="hljs-params">l, r</span>) </span>&#123;r = r.prototype;l = <span class="hljs-built_in">Object</span>.getPrototypeOf(l); <span class="hljs-comment">// l =  l.__proto__</span><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (l === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (r === l) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;l = <span class="hljs-built_in">Object</span>.getPrototypeOf(l);&#125;&#125;</code></pre></div><ul><li><p>手写<code>new</code>操作符</p><p>  new 执行了什么操作:</p><ul><li>  创建一个空对象</li><li>  将空对象连接上构造函数的原型</li><li>  将 this 指向新对象，执行构造函数</li><li>  如果该函数没有返回对象，则返回 this</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> isObject = <span class="hljs-function">(<span class="hljs-params">o</span>) =&gt;</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; o !== <span class="hljs-literal">null</span>;<span class="hljs-keyword">const</span> _new = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, ...args</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must new a function&quot;</span>);<span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">Object</span>.create(func.prototype);<span class="hljs-keyword">const</span> res = func.apply(instance, args);<span class="hljs-keyword">return</span> isObject(res) ? res : instance;&#125;;</code></pre></div><ul><li>  实现<code>Object.create</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>._create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">proto, propertiesObject</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> proto !== <span class="hljs-string">&quot; function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;Object prototype may only be an Object: &quot;</span> + proto);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;F.prototype = proto;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> F();<span class="hljs-keyword">if</span> (propertiesObject) &#123;<span class="hljs-built_in">Object</span>.defineProperty(res, propertiesObject);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><ul><li>  手写防抖/节流</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 防抖</span><span class="hljs-comment">// 连续触发函数只执行一次</span><span class="hljs-comment">// 连续触发过程中计时器被重置</span><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span>连续点击按钮(登陆),窗口resize,文本框实时保存,搜索框输入过程中的下拉候选项</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, delay, immediate = <span class="hljs-literal">true</span>, ...args1</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must apply to an Function&quot;</span>);<span class="hljs-keyword">let</span> timer;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_debounce</span>(<span class="hljs-params">...args2</span>) </span>&#123;<span class="hljs-keyword">if</span> (timer) &#123;<span class="hljs-built_in">clearTimeout</span>(timer);&#125;<span class="hljs-keyword">if</span> (immediate) &#123;<span class="hljs-keyword">const</span> callNow = !timer;timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;timer = <span class="hljs-literal">null</span>;&#125;, delay);<span class="hljs-keyword">if</span> (callNow) func.apply(<span class="hljs-built_in">this</span>, [...args1, ...args2]);&#125; <span class="hljs-keyword">else</span> &#123;timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;func.apply(<span class="hljs-built_in">this</span>, [...args1, ...args2]);<span class="hljs-built_in">clearTimeout</span>(timer);timer = <span class="hljs-literal">null</span>;&#125;, delay);&#125;&#125;_debounce.cancel = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">clearTimeout</span>(timer);timer = <span class="hljs-literal">null</span>;&#125;;<span class="hljs-keyword">return</span> _debounce;&#125;<span class="hljs-comment">// 节流</span><span class="hljs-comment">// 函数以间隔固定时间执行</span><span class="hljs-comment">// 连续触发过程中计时器不会被重置</span><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span>scrollEvent,clickEvent,resizeEvent,记录多媒体播放进度</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, delay, tail = <span class="hljs-literal">true</span>, ...args1</span>) </span>&#123;<span class="hljs-comment">//tail 使用定时器</span><span class="hljs-comment">//tail = false 使用时间戳</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;must apply to an Function&quot;</span>);<span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> pre = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (tail) &#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_throttle</span>(<span class="hljs-params">...args2</span>) </span>&#123;<span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>;timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;func.apply(<span class="hljs-built_in">this</span>, [...args1, ...args2]);<span class="hljs-built_in">clearTimeout</span>(timer);timer = <span class="hljs-literal">null</span>;&#125;, delay);&#125;_throttle.cancel = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">clearTimeout</span>(timer);timer = <span class="hljs-literal">null</span>;&#125;;<span class="hljs-keyword">return</span> _throttle;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<span class="hljs-keyword">const</span> now = +<span class="hljs-built_in">Date</span>.now();<span class="hljs-keyword">if</span> (now - pre &gt; delay) &#123;func.apply(<span class="hljs-built_in">this</span>, [...args1, ...args2]);pre = now;&#125;&#125;;&#125;&#125;</code></pre></div><ul><li>  并发/线程池</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncPool</span>(<span class="hljs-params">limit, arr, func</span>) </span>&#123;<span class="hljs-comment">// arr参数队列</span><span class="hljs-comment">// func执行函数</span><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> len = arr.length;<span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 所有任务</span><span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 运行中</span><span class="hljs-keyword">const</span> enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (i &gt; len - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve();<span class="hljs-keyword">const</span> item = arr[i++];<span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> func(item));<span class="hljs-keyword">const</span> e = p.then(<span class="hljs-function">() =&gt;</span> executing.splice(executing.indexOf(e), <span class="hljs-number">1</span>)); <span class="hljs-comment">// 自己resolve后从并发池中删除</span>ret.push(p);executing.push(e);<span class="hljs-built_in">console</span>.log(executing);<span class="hljs-keyword">let</span> r = <span class="hljs-built_in">Promise</span>.resolve();<span class="hljs-keyword">if</span> (executing.length &gt;= limit) &#123;r = <span class="hljs-built_in">Promise</span>.race(executing);<span class="hljs-comment">//使用race，并发池中只要有一个promise返回resolve，则继续调用enqueue方法添加新的进去</span>&#125;<span class="hljs-keyword">return</span> r.then(<span class="hljs-function">() =&gt;</span> enqueue());&#125;;<span class="hljs-keyword">return</span> enqueue().then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.all(ret));&#125;<span class="hljs-keyword">const</span> cb = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(str), <span class="hljs-number">2000</span>);<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">123</span>, <span class="hljs-number">124</span>, <span class="hljs-number">666</span>, <span class="hljs-number">777</span>, <span class="hljs-number">888</span>];asyncPool(<span class="hljs-number">2</span>, arr, cb);</code></pre></div><ul><li>  实现重试功能</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment"> *@functionName: retry</span><span class="hljs-comment"> *@fn: 执行函数</span><span class="hljs-comment"> *@interval: 重试间隔</span><span class="hljs-comment"> *@limit: 重试次数</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retry</span>(<span class="hljs-params">fn, interval, limit</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attempt</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> fn());p.then(resolve).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (limit-- &lt;= <span class="hljs-number">1</span>) &#123;reject(<span class="hljs-string">&quot;打到重试最大次数&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;attempt();<span class="hljs-built_in">clearTimeout</span>(timer);&#125;, interval);&#125;&#125;);&#125;attempt();&#125;);&#125;</code></pre></div><ul><li><p>浅拷贝</p><ol><li><code>Object.assign()</code></li><li>展开运算符</li></ol></li><li><p>深拷贝</p><ol><li><p><code>JSON.parse(JSON.stringify(source))</code></p><ul><li><p>先 JSON.stringify 转成字符串，再 JSON.parse 把字符串转换成新的对象</p></li><li><p><strong>遇到 Symbol 和函数则报错</strong></p></li></ul></li><li><p>手动实现 deepClone</p></li></ol>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-keyword">const</span> isObject = <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">source, cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()</span>) </span>&#123; <span class="hljs-keyword">if</span> (!isObject(source) || cache.has(source)) <span class="hljs-keyword">return</span> source; <span class="hljs-keyword">const</span> res = source.constructor === <span class="hljs-built_in">Object</span> ? &#123;&#125; : <span class="hljs-built_in">Object</span>.create(Source.constructor.prototype); <span class="hljs-comment">// 用constructor判断处理其他复杂类型的对象</span><span class="hljs-comment">// 例如Date对象如果使用typeof 返回object</span><span class="hljs-comment">// 加入缓存中</span><span class="hljs-comment">// 处理循环引用</span>cache.add(source) <span class="hljs-built_in">Reflect</span>.ownKeys(source).forEach(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> &#123; res[k] = deepClone(source[k], cache); &#125;); <span class="hljs-keyword">return</span> res; &#125;</code></pre></div></li><li><p>for…in /for…of</p><ul><li><p>for…in 语句以任意顺序遍历一个对象的除 Symbol 以外的<em>可枚举</em>属性,除了遍历对象中的元素之外，还回去遍历自定义的属性，甚至原型链上的属性</p><div class="hljs code-wrapper"><pre><code class="hljs">  <pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;<span class="hljs-built_in">Object</span>.defineProperty(o,<span class="hljs-string">&#x27;c&#x27;</span>,&#123;<span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>, <span class="hljs-attr">value</span>:<span class="hljs-number">30</span>&#125;)<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> o)&#123;<span class="hljs-built_in">console</span>.log(i)&#125;<span class="hljs-comment">// a</span><span class="hljs-comment">// b</span></code></pre></div></code></pre></li><li><p>  for…of 则只调用可迭代对象的[Symbol.Iterator]接口遍历对象</p></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.extraFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;extraFn&quot;</span>;&#125;;<span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&quot;1&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span> &#125;, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];myArray.name = <span class="hljs-string">&quot;啦啦啦&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> myArray) &#123;<span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">//1 &#123;name: &quot;mmm&quot;&#125; 3 4 5 6 7</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> myArray) &#123;<span class="hljs-built_in">console</span>.log(myArray[index]);&#125;<span class="hljs-comment">// 1</span><span class="hljs-comment">// &#123; name: &#x27;mmm&#x27; &#125;</span><span class="hljs-comment">// 4</span><span class="hljs-comment">// 5</span><span class="hljs-comment">// 6</span><span class="hljs-comment">// 7</span><span class="hljs-comment">// 啦啦啦</span><span class="hljs-comment">// [Function]</span></code></pre></div></li><li><p>  阻止冒泡和默认事件</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopBubble</span>(<span class="hljs-params">e</span>) </span>&#123;<span class="hljs-keyword">if</span> (e &amp;&amp; e.stopPropagation) &#123;e.stopPropagation();&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopDefault</span>(<span class="hljs-params">e</span>) </span>&#123;<span class="hljs-keyword">if</span> (e &amp;&amp; e.preventDefault) e.preventDefault();<span class="hljs-keyword">else</span> <span class="hljs-built_in">window</span>.event.returnValue = <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><ul><li>  手写 call/apply/bind</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype._call = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) </span>&#123;context = context || <span class="hljs-built_in">window</span>;<span class="hljs-keyword">const</span> caller = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);context[caller] = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">let</span> result = context[caller](...args);<span class="hljs-built_in">Reflect</span>.deleteProperty(context, caller);<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-built_in">Function</span>.prototype._apply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) </span>&#123;context = context || <span class="hljs-built_in">window</span>;<span class="hljs-keyword">const</span> caller = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);context[caller] = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">let</span> result = context[caller](...args);<span class="hljs-built_in">Reflect</span>.deleteProperty(context, caller);<span class="hljs-keyword">return</span> result;&#125;;<span class="hljs-comment">// 返回一个原函数的拷贝，并拥有指定的this值和初始参数。</span><span class="hljs-built_in">Function</span>.prototype._bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args1</span>) </span>&#123;context = context || <span class="hljs-built_in">window</span>;<span class="hljs-keyword">const</span> originFn = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">const</span> boundFn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<span class="hljs-keyword">return</span> originFn.apply(boundFn.prototype.isPrototypeOf(<span class="hljs-built_in">this</span>) ? <span class="hljs-built_in">this</span> : context, [<span class="hljs-comment">// 如果绑定函数被new调用</span><span class="hljs-comment">// 则this指向生的成新对象</span>...args1,...args2,]);&#125;;<span class="hljs-comment">// if (this.prototype) &#123;</span><span class="hljs-comment">//   notBFn.prototype = this.prototype;</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// boundFn.prototype = new notBFn();</span>boundFn.prototype = <span class="hljs-built_in">Object</span>.create(originFn.prototype);<span class="hljs-comment">// 使用notBFn间接连接boundFn和originFn原型链</span><span class="hljs-keyword">return</span> boundFn;&#125;;</code></pre></div><ul><li>  手动实现一个 es5 继承</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Human</span>(<span class="hljs-params">color</span>) </span>&#123;<span class="hljs-built_in">this</span>.skinColor = color;<span class="hljs-built_in">this</span>.creature = <span class="hljs-string">&quot;Human&quot;</span>;&#125;Human.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;在恰饭&quot;</span>);&#125;;<span class="hljs-comment">// 1.借用构造函数</span><span class="hljs-comment">// 只能继承构造函数中的属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Asian</span>(<span class="hljs-params">name</span>) </span>&#123;Human.call(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;yellow&quot;</span>);<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> Asian(<span class="hljs-string">&quot;李华&quot;</span>);<span class="hljs-comment">//a1.eat() // 报错</span><span class="hljs-comment">// Asian &#123; skinColor: &#x27;yellow&#x27;, type: &#x27;Human&#x27;, name: &#x27;李华&#x27; &#125;</span><span class="hljs-comment">// 2.原型继承</span><span class="hljs-comment">// 子类共享原型，修改互相影响</span><span class="hljs-comment">// 不能继承对父类构造函数的传参</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">African</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;African.prototype = <span class="hljs-keyword">new</span> Human();<span class="hljs-keyword">let</span> f1 = <span class="hljs-keyword">new</span> African(<span class="hljs-string">&quot;housaiin&quot;</span>);f1.eat();<span class="hljs-comment">// Human &#123; name: &#x27;housaiin&#x27; &#125;</span><span class="hljs-comment">// housaiin在恰饭</span><span class="hljs-comment">// 3.组合继承1+2</span><span class="hljs-comment">// 子类共享原型</span><span class="hljs-comment">// 父类构造函数调用两次</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Japanese</span>(<span class="hljs-params">name</span>) </span>&#123;Human.call(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;yellow&quot;</span>);<span class="hljs-built_in">this</span>.name = name;&#125;Japanese.prototype = <span class="hljs-keyword">new</span> Human();<span class="hljs-keyword">let</span> j1 = <span class="hljs-keyword">new</span> Japanese(<span class="hljs-string">&quot;tatekii&quot;</span>);j1.eat();<span class="hljs-comment">// Human &#123; skinColor: &#x27;yellow&#x27;, creature: &#x27;Human&#x27;, name: &#x27;tatekii&#x27; &#125;</span><span class="hljs-comment">// tatekii在恰饭</span><span class="hljs-comment">// 4.原型式继承</span><span class="hljs-comment">// 继承关系混乱，分不清是谁构造的</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Japanese</span>(<span class="hljs-params">name</span>) </span>&#123;Human.call(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;yellow&quot;</span>);<span class="hljs-built_in">this</span>.name = name;&#125;Japanese.prototype = Human.prototype;<span class="hljs-keyword">let</span> j2 = <span class="hljs-keyword">new</span> Japanese(<span class="hljs-string">&quot;wasabi&quot;</span>);j2.constructor; <span class="hljs-comment">//  Human</span><span class="hljs-comment">// 5.寄生继承</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">French</span>(<span class="hljs-params">name</span>) </span>&#123;Human.call(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;white&quot;</span>);<span class="hljs-built_in">this</span>.name = name;&#125;French.prototype = <span class="hljs-built_in">Object</span>.create(Human.prototype);French.prototype.constructor = French;<span class="hljs-comment">// 连接到父类原型链上但通过object.create将父子原型隔开</span><span class="hljs-comment">// 确保子类实例们不会互相影响</span><span class="hljs-comment">// 同时将构造函数指向自己</span><span class="hljs-keyword">let</span> f2 = <span class="hljs-keyword">new</span> French(<span class="hljs-string">&quot;Hugo&quot;</span>);f2.eat();<span class="hljs-comment">// Human &#123; skinColor: &#x27;white&#x27;, creature: &#x27;Human&#x27;, name: &#x27;Hugo&#x27; &#125;</span><span class="hljs-comment">// Hugo在恰饭</span>f2.constructor; <span class="hljs-comment">// French</span></code></pre></div><ul><li>  手动实现一个迭代器</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIterator</span>(<span class="hljs-params">array</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> &#123;<span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> &#123;value: array[i],done: i++ &gt;= array.length,&#125;;&#125;,[<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;,&#125;;&#125;</code></pre></div><ul><li><p>for 循环实现遍历方法</p><ul><li><p>for 循环实现 forEach</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, context</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;context = context || <span class="hljs-built_in">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;callback.call(context, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);&#125;&#125;&#125;;</code></pre></div></li><li><p>for 循环实现 map</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-keyword">const</span> result = [];thisArg = thisArg || <span class="hljs-built_in">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;result[i] = callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>);&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 filter</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._filter_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-keyword">const</span> result = [];thisArg = thisArg || <span class="hljs-built_in">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;<span class="hljs-keyword">if</span> (callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;result.push(<span class="hljs-built_in">this</span>[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 some</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._some = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;thisArg = thisArg || <span class="hljs-built_in">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;<span class="hljs-keyword">if</span> (callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 every</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._every = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;thisArg = thisArg || <span class="hljs-built_in">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(i)) &#123;<span class="hljs-keyword">if</span> (!callback.call(thisArg, <span class="hljs-built_in">this</span>[i], i, <span class="hljs-built_in">this</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 reduce</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initialValue</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-keyword">let</span> res;<span class="hljs-keyword">let</span> initialIndex = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!initialValue) &#123;<span class="hljs-keyword">for</span> (; initialIndex &lt; <span class="hljs-built_in">this</span>.length; initialIndex++) &#123;<span class="hljs-comment">// 未指定初始值则自行查找第一个非空下标</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hasOwnProperty(initialIndex)) &#123;res = <span class="hljs-built_in">this</span>[i];<span class="hljs-keyword">break</span>;&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;res = initialValue;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = initialIndex + <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">this</span>.length; j++) &#123;res = callback.call(<span class="hljs-literal">null</span>, res, <span class="hljs-built_in">this</span>[j], j, <span class="hljs-built_in">this</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div></li></ul></li><li><p>reduce 实现遍历方法</p><ul><li>  reduce 实现 forEach</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-built_in">this</span>.reduce(<span class="hljs-function">(<span class="hljs-params">pre, acc, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> [...pre, callback.call(thisArg, acc, index, <span class="hljs-built_in">this</span>)];&#125;, []);&#125;;</code></pre></div><ul><li>  reduce 实现 map</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//加上return</span></code></pre></div><ul><li>  reduce 实现 filter</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype._filter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback,thisArg</span>)</span>&#123;  ...  ...  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.reduce(<span class="hljs-function">(<span class="hljs-params">pre,acc</span>)=&gt;</span>&#123;    <span class="hljs-keyword">return</span> callback.call(thisArg,acc,index,<span class="hljs-built_in">this</span>)?[...pre,cur]:[...pre]  &#125;,[])&#125;</code></pre></div></li><li><p>  实现 object.assign</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Object</span>._assign = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, ...source</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!target) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Cannot convert undefined or null to object&#x27;</span>);  <span class="hljs-keyword">return</span> source.reduce(<span class="hljs-function">(<span class="hljs-params">acc, cur</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> acc;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> cur)&#123;      acc[key] = cur[key]    &#125;    <span class="hljs-keyword">return</span> acc;  &#125;, target);&#125;;</code></pre></div><ul><li>  手动实现 typeof</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> selfTypeof = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);<span class="hljs-keyword">return</span> ret.slice(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).toLowercase();&#125;;</code></pre></div><ul><li><p>数组的所有排列组合</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-comment">//[[1,2,3],[4,5,6],[7,8,9]]</span><span class="hljs-comment">// 每个数组中取一个值组成新的数字</span><span class="hljs-comment">// 列出所有的排列可能性</span><span class="hljs-keyword">let</span> len = arr.length;<span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">let</span> len1 = arr[<span class="hljs-number">0</span>].length;<span class="hljs-keyword">let</span> len2 = arr[<span class="hljs-number">1</span>].length;<span class="hljs-keyword">let</span> lenBoth = len1 * len2;<span class="hljs-keyword">let</span> items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(lenBoth);<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++) &#123;items[index] = [].concat(arr[<span class="hljs-number">0</span>][i]).concat(arr[<span class="hljs-number">1</span>][j]);index++;&#125;&#125;<span class="hljs-comment">// 求出前两个数组的组合</span><span class="hljs-comment">// 接下来调整数组，递归调用</span><span class="hljs-comment">// 拼接剩余参数数组</span><span class="hljs-keyword">return</span> exchange(items, ...arr.slice(<span class="hljs-number">2</span>));&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];&#125;&#125;</code></pre></div></li><li><p>  属性名表达式</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> obj = &#123;  a: <span class="hljs-number">10</span>,&#125;;obj[b] = <span class="hljs-number">20</span>;<span class="hljs-built_in">console</span>.log(obj[a]); <span class="hljs-comment">// 20</span><span class="hljs-comment">//obj.b和obj[b]的不同</span>obj[需要是已经声明的变量名]obj.则不受限制obj.c = <span class="hljs-number">20</span> ===&gt; obj:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">20</span>,<span class="hljs-attr">a</span>:<span class="hljs-number">10</span>&#125;obj[c] <span class="hljs-comment">//报错</span><span class="hljs-comment">//原题中obj[b]后打印得到</span>obj = &#123;  a:<span class="hljs-number">10</span>,  <span class="hljs-string">&#x27;[object:object]&#x27;</span> : <span class="hljs-number">20</span>  <span class="hljs-comment">//b = &#123; b: 10 &#125; ===&gt; &#x27;[object:object]&#x27;</span>&#125;后再访问obj[a]时也就是访问obj[<span class="hljs-string">&#x27;[object:object]&#x27;</span>] = <span class="hljs-number">20</span></code></pre></div><ul><li>  this 的指向</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">20</span>,say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);&#125;,&#125;;obj.say();<span class="hljs-comment">// 打印出10的方法</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">20</span>,say: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);&#125;,&#125;;obj.say();<span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">20</span>,say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);&#125;,&#125;;<span class="hljs-keyword">let</span> say = obj.say;say();<span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;a: <span class="hljs-number">20</span>,say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.a);&#125;,&#125;;obj.say.call(<span class="hljs-built_in">this</span>);</code></pre></div><ul><li>  js 执行顺序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// js执行顺序</span><span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;script start&quot;</span>); <span class="hljs-comment">// 1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;setTimeout&quot;</span>); <span class="hljs-comment">// 4</span>&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise1&quot;</span>); <span class="hljs-comment">//2</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;promise2&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-comment">// 2</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// 5</span>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//7</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>); <span class="hljs-comment">//6</span>resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">//8</span>&#125;);&#125;);process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span>resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span>resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);&#125;); <span class="hljs-comment">//12</span>&#125;);<span class="hljs-comment">// 3</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>); <span class="hljs-comment">//1</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">//2</span>&#125;);<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3-1&quot;</span>); <span class="hljs-comment">//6</span>&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3-2&quot;</span>); <span class="hljs-comment">//3</span>&#125;<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>); <span class="hljs-comment">//5</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>); <span class="hljs-comment">//7</span>&#125;);async1();<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>); <span class="hljs-comment">//4</span></code></pre></div><ul><li>  js 执行优先级</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;&#125;Foo.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;;Foo.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);&#125;;<span class="hljs-keyword">var</span> getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getName</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;Foo.getName();getName();Foo().getName();<span class="hljs-comment">// function changeThis()&#123;</span><span class="hljs-comment">//   return this</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// changeThis().fn666 = ()=&gt;&#123;</span><span class="hljs-comment">//   console.log(666);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// global.fn666()</span>getName();<span class="hljs-keyword">new</span> Foo.getName();<span class="hljs-keyword">new</span> Foo().getName();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Foo().getName();</code></pre></div><ul><li>  实现一个 setTimeout</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_setTimeout</span>(<span class="hljs-params">cb, timeout, ...args</span>) </span>&#123;<span class="hljs-keyword">const</span> start = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">window</span>.requestAnimationFrame(loop);<span class="hljs-keyword">const</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-keyword">if</span> (now - start &gt;= timeout) &#123;cb.apply(<span class="hljs-built_in">this</span>, args);<span class="hljs-built_in">window</span>.cancelAnimationFrame(timer);&#125;&#125;<span class="hljs-built_in">window</span>.requestAnimationFrame(loop);&#125;</code></pre></div><ul><li>  使用 setTimeout 模拟 setInterval</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// setInterval 的问题</span><span class="hljs-comment">// 定时往事件队列中添加回调函数，如果主线程运行时间过长到大量回调超时，则有可能同时执行大量异步回调，违背使用意图</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_setInterval</span>(<span class="hljs-params">fn,timeout,...args</span>)</span>&#123;  <span class="hljs-keyword">const</span> controller = &#123;    stop = <span class="hljs-literal">false</span>    <span class="hljs-comment">// 控制器</span>  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interval</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(!controller.stop)&#123;      fn.apply(<span class="hljs-built_in">this</span>,args)      <span class="hljs-built_in">setTimeout</span>(_interval,timeout)    &#125;  &#125;  <span class="hljs-built_in">setTimeout</span>(_interval,timeout)  <span class="hljs-keyword">return</span> controller&#125;</code></pre></div><ul><li>  模版字符串</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(w+)\&#125;\&#125;/g</span>;<span class="hljs-keyword">const</span> template = <span class="hljs-string">&quot;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&quot;</span>;<span class="hljs-keyword">const</span> data = &#123;name: <span class="hljs-string">&quot;森下上士&quot;</span>,age: <span class="hljs-number">18</span>,&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params">template, data</span>) </span>&#123;<span class="hljs-keyword">if</span> (reg.test(template)) &#123;<span class="hljs-keyword">const</span> tem = template.match(reg);tem.forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> p = key.slice(<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>);<span class="hljs-comment">// &#123;&#123;xxx&#125;&#125; ==&gt; xxx</span>template = template.replace(key, data[p]);&#125;);&#125;<span class="hljs-keyword">return</span> template;&#125;</code></pre></div><ul><li>  Ajax</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> request = <span class="hljs-function">(<span class="hljs-params">method, url, data</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.readyState !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === <span class="hljs-number">200</span>) &#123;resolve(<span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">this</span>.response));&#125; <span class="hljs-keyword">else</span> &#123;reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-built_in">this</span>.statusText));&#125;&#125;;xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;error&quot;</span>));&#125;;xhr.responseType = <span class="hljs-string">&quot;json&quot;</span>;xhr.setRequestHeader(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<span class="hljs-keyword">if</span> (method === <span class="hljs-string">&quot;GET&quot;</span>) &#123;xhr.open(<span class="hljs-string">&quot;GET&quot;</span>, url + <span class="hljs-string">&quot;?&quot;</span> + data, <span class="hljs-literal">true</span>);xhr.send();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method === <span class="hljs-string">&quot;POST&quot;</span>) &#123;xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencode&quot;</span>);xhr.open(<span class="hljs-string">&quot;POST&quot;</span>, url);xhr.send(<span class="hljs-built_in">encodeURIComponent</span>(data));&#125;&#125;);&#125;;</code></pre></div><ul><li>  js 获取文件扩展名</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExt</span>(<span class="hljs-params">filename</span>) </span>&#123;<span class="hljs-keyword">return</span> filename.split(<span class="hljs-string">&quot;.&quot;</span>).pop();&#125;<span class="hljs-comment">// 按.分割字符串为数组</span><span class="hljs-comment">// pop删除最后一项并返回</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getExt</span>(<span class="hljs-params">filename</span>) </span>&#123;<span class="hljs-keyword">return</span> filename.replace(<span class="hljs-regexp">/.+\./</span>, <span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><ul><li>  匿名函数自执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接在匿名函数之后加（）无效</span><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>])&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//加号</span>+<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//减号</span>-<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//感叹号</span>!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//括号</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;)(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>));</code></pre></div><ul><li>  实现一个 sleep 函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sleep = <span class="hljs-function">(<span class="hljs-params">ms</span>) =&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(resolve, ms);&#125;);</code></pre></div><ul><li>  数组的全排列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permute</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-comment">// 回溯算法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recursion</span>(<span class="hljs-params">path, set</span>) </span>&#123;<span class="hljs-keyword">if</span> (path.length === arr.length) &#123;<span class="hljs-keyword">return</span> res.push([...path]); <span class="hljs-comment">// 潜拷贝一次</span>&#125;<span class="hljs-comment">// 使用path记录回溯的路径</span><span class="hljs-comment">// [1,2,3,4]</span><span class="hljs-comment">// path[1,2]，set[1,2]</span><span class="hljs-comment">// 1,2,已经用过</span><span class="hljs-comment">// 分别遍历3，4</span><span class="hljs-comment">// 添加[1,2,3,4],[1,2,4,3]进结果</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> arr) &#123;<span class="hljs-keyword">if</span> (set.has(num)) <span class="hljs-keyword">continue</span>;path.push(num);set.add(num);recursion(path, set);path.pop();set.delete(num);&#125;&#125;recursion([], <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>());<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>二分查找元素<blockquote><p>试用于顺序数组</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryFind</span>(<span class="hljs-params">arr, target, s = <span class="hljs-number">0</span>, e = arr.length - <span class="hljs-number">1</span></span>) </span>&#123;<span class="hljs-keyword">const</span> i = <span class="hljs-built_in">Math</span>.floor((s + e) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (arr[i] === target) &#123;<span class="hljs-keyword">return</span> i;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; target) &#123;<span class="hljs-keyword">return</span> binaryFind(arr, target, s, i - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; target) &#123;<span class="hljs-keyword">return</span> binaryFind(arr, target, i + <span class="hljs-number">1</span>, e);&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binaryFind2</span>(<span class="hljs-params">arr, target</span>) </span>&#123;<span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span>,e = arr.length - <span class="hljs-number">1</span>,mid;<span class="hljs-keyword">while</span> (s &lt;= e) &#123;mid = <span class="hljs-built_in">Math</span>.floor((s + e) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (arr[mid] === target) &#123;<span class="hljs-keyword">return</span> mid;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; target) &#123;e = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;s = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><ul><li>  扁平化转换</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现一个 fn 函数</span><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-attr">d</span>: &#123; <span class="hljs-attr">e</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">f</span>: <span class="hljs-number">3</span> &#125;, <span class="hljs-attr">g</span>: <span class="hljs-literal">null</span> &#125;;<span class="hljs-comment">// fn(o) =&gt; 扁平化转换</span><span class="hljs-comment">// &#123; &quot;a&quot;: 1, &quot;b[0]&quot;: 1, &quot;b[1]&quot;: 2, &quot;b[2].c&quot;: true, &quot;d.e&quot;: 2, ... &#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFlat</span>(<span class="hljs-params">obj</span>) </span>&#123;<span class="hljs-keyword">const</span> res = &#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">obj, path</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span>) &#123;res[path] = obj;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj)) &#123;<span class="hljs-keyword">const</span> cur = obj[key];<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(cur)) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cur.length; i++) &#123;flat(cur[i], path ? path + <span class="hljs-string">&quot;.&quot;</span> + key + <span class="hljs-string">&quot;[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span> : key + <span class="hljs-string">&quot;[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj[key] === <span class="hljs-string">&quot;object&quot;</span>) &#123;flat(cur, path ? path + <span class="hljs-string">&quot;.&quot;</span> + key : key);&#125; <span class="hljs-keyword">else</span> &#123;res[path ? path + <span class="hljs-string">&quot;.&quot;</span> + key : key] = cur;&#125;&#125;&#125;&#125;flat(obj, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">console</span>.log(objectFlat(o));</code></pre></div><ul><li><p>变量连续赋值</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">a = b = <span class="hljs-number">3</span>;<span class="hljs-comment">// 一般来说执行顺序是</span>b = <span class="hljs-number">3</span>;a = b;<span class="hljs-comment">// 当遇到`.`操作符,操作优先级会高于赋值</span><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">666</span> &#125;;b = a;a.x = a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">222</span> &#125;;<span class="hljs-comment">// 先执行a.x = &#123;name:222&#125;</span><span class="hljs-comment">// 后改变a指针 a = &#123;name:222&#125;</span>a.x; <span class="hljs-comment">// &#123;name:222&#125; undefined</span>b.x; <span class="hljs-comment">// &#123;name:666,x:&#123;name:222&#125;&#125; &#123;name:222&#125;</span></code></pre></div></li><li><p>  0.1+0.2==0.3?</p></li></ul><p>js中一般数字精度有上限（双精度浮点），所以不能用<code>==</code>或者<code>===</code>来比较<code>Number</code>类型.<br>正确的比较方法：<code>Math.abs(0.1+0.2-0.3)&lt;=Number.EPSILON</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC/MVP/MVVM</title>
    <link href="/2022/02/24/mvcmvpmvvm/"/>
    <url>/2022/02/24/mvcmvpmvvm/</url>
    
    <content type="html"><![CDATA[<h3 id="MVCModel-View-Controller"><a href="#MVCModel-View-Controller" class="headerlink" title="MVCModel-View-Controller"></a>MVC<code>Model-View-Controller</code></h3><div class="hljs code-wrapper"><pre><code class="hljs js">View-&gt;Controller-&gt;Model^                     ||                     v&lt;---------------------&lt;</code></pre></div><ul><li><code>View</code>可以访问<code>Model</code>,不可避免的会包含一些业务逻辑，导致特定<code>View</code>依赖特定<code>Model</code></li><li>视图的更新逻辑由<code>View</code>自己完成</li><li><code>View</code>监听<code>Model</code>改变的的广播</li><li>用户可以操作<code>View</code>或者直接操作<code>Controller</code></li></ul><h3 id="MVPModel-View-Presenter"><a href="#MVPModel-View-Presenter" class="headerlink" title="MVPModel-View-Presenter"></a>MVP<code>Model-View-Presenter</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">View &lt;--&gt; Presenter &lt;==&gt; Model</code></pre></div><ul><li><p><code>View</code> 与 <code>Model</code> 之间通过 <code>Presenter</code>解偶</p></li><li><p>主要的程序逻都在<code>Presenter</code>中，接受<code>Model</code>层的数据，并且处理之后传递给<code>View</code>层，还需要处理<code>View</code>层的用户交互等操作。</p></li><li><p><code>View</code>不部署任何业务逻辑,被动视图，只提供接口</p></li><li><p><code>Model</code>改变的的广播由<code>Presenter</code>监听</p></li></ul><h3 id="MVVMModel-View-ViewModel"><a href="#MVVMModel-View-ViewModel" class="headerlink" title="MVVMModel-View-ViewModel"></a>MVVM<code>Model-View-ViewModel</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">View &lt;==&gt; ViewModel &lt;==&gt; Model</code></pre></div><ul><li><code>ViewModel</code>可以理解为是MVP中<code>View</code>的数据模型和<code>Presenter</code>的合体</li><li>以前全部由<code>Presenter</code>负责的<code>View</code>和<code>Model</code>之间数据同步操作交由框架实现双向绑定</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-diff</title>
    <link href="/2022/02/24/react_diff%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/24/react_diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node相关知识点</title>
    <link href="/2022/02/24/node%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/02/24/node%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ul><li>引用模块的目录分析<ol><li>在当前目录下查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。 　　</li><li>而如果main属性制定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.node、index.json. 　　</li><li>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败异常。</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-beginner</title>
    <link href="/2022/02/24/react_rookie/"/>
    <url>/2022/02/24/react_rookie/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><blockquote><p>构建用户页面的 javascript 库，并不是完整的 MVC 框架</p></blockquote><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a><code>React.createElement</code></h3><p>JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖</p><h3 id="ReactDOM-render-element-container-callback"><a href="#ReactDOM-render-element-container-callback" class="headerlink" title="ReactDOM.render(element, container[, callback)"></a><code>ReactDOM.render(element, container[, callback)</code></h3><p>在提供的 <code>container</code> 里渲染一个 React 元素，并返回对该组件的引用（或者针对无状态组件返回 null）。</p><p>如果 React 元素之前已经在 <code>container</code> 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 DOM 以映射最新的 React 元素。</p><p>如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。</p><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><ul><li>  语法糖，更能体现 react 的声明式特点，逻辑和页面标签写在一起</li><li>  jsx 不是标准的 ECMAScript 语法，babel 编译</li></ul><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> title = (<span class="hljs-comment">// 推荐使用小括号包裹</span>&lt;h1&gt;我是个title&lt;/h1&gt;);</code></pre></div><ul><li>  jsx 中的属性名驼峰命名</li><li>  <code>&#123;..中可以写js表达式，区别vue的双括号..&#125;</code></li></ul><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// if else</span><span class="hljs-keyword">if</span>()&#123;  <span class="hljs-keyword">return</span> xxx&#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-keyword">return</span> xxx&#125;<span class="hljs-comment">// 三元表达式</span><span class="hljs-keyword">return</span> flag ? (.&lt;dv&gt;..) : (..&lt;dv&gt;.)<span class="hljs-comment">// 逻辑与运算符</span><span class="hljs-keyword">return</span> flag &amp;&amp; (..&lt;dv&gt;.)</code></pre></div><h3 id="循环渲染"><a href="#循环渲染" class="headerlink" title="循环渲染"></a>循环渲染</h3><blockquote><p>key 的作用和 vue 一样用于 diff 时复用节点</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> data = [&#123;&#125;...&#123;&#125;...&#123;&#125;]<span class="hljs-keyword">const</span> list = (  &#123;data.map(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  &#125;)&#125;)</code></pre></div><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li><p>行内样式,双括号</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> title = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span>我是个title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;</code></pre></div></li><li><p>className</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> title = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>我是个title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;</code></pre></div><blockquote><p>组件是 react 一等公民</p></blockquote></li></ul><blockquote><p>组件：复用，独立，组合</p></blockquote><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="函数组件（使用函数创建）"><a href="#函数组件（使用函数创建）" class="headerlink" title="函数组件（使用函数创建）"></a>函数组件（使用函数创建）</h2><ul><li>  大写首字母</li><li>  必须 return</li><li>  包括箭头函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Com1</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是Com1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Com1</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;app&quot;</span>));</code></pre></div><blockquote><p>babel 转译后,function 运行在严格模式下,严格模式的 this 指向 null</p></blockquote><h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">-大写首字母 - <span class="hljs-keyword">extends</span>自<span class="hljs-string">`React.Component`</span> - 必须<span class="hljs-keyword">return</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCom2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是Com2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;&#125;</code></pre></div><h2 id="「state」"><a href="#「state」" class="headerlink" title="「state」"></a>「state」</h2><ul><li>  一般写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Com3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">xxx</span>:xxx&#125;    <span class="hljs-built_in">this</span>.func1 = <span class="hljs-built_in">this</span>.func1.bind(<span class="hljs-built_in">this</span>)  &#125;  <span class="hljs-function"><span class="hljs-title">func1</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.setState(xxx:xxx)    <span class="hljs-comment">// 需要手动派发 `setState()`</span>  &#125;  render() =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">xxx</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.func1&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xxx</span>&gt;</span></span>&#125;</code></pre></div><ul><li>  使用赋值语句简写</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Com3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;  state = &#123;<span class="hljs-attr">xxx</span>:xxx&#125;  func1 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">this</span>.setState(xxx:xxx)  &#125;  render() =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">xxx</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.func1&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xxx</span>&gt;</span></span>&#125;</code></pre></div><h2 id="「props」"><a href="#「props」" class="headerlink" title="「props」"></a>「props」</h2><p>组件内部不用声明<code>props</code>,组件实例持有有一个<code>props</code>数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> (    &lt;Com1 prop1=<span class="hljs-string">&#x27;&#x27;</span> prop2=&#123;<span class="hljs-number">666</span>&#125;/&gt;  )&#125;</code></pre></div><ul><li>  标签属性可以用展开运算符</li><li>  props 校验<a href="https://react.docschina.org/docs/typechecking-with-proptypes.html">https://react.docschina.org/docs/typechecking-with-proptypes.html</a></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">Com1.propTypes = &#123;  prop1:PropTypes.string.isRequired,<span class="hljs-comment">// isRequired</span>  prop2:PropTypes.number  prop3;PropTypes.func <span class="hljs-comment">// function</span>&#125;Com1.defaultProps = &#123;  prop1:<span class="hljs-string">&#x27;xxx&#x27;</span>,  prop2:<span class="hljs-number">123</span>&#125;</code></pre></div><ul><li>  同样也可以写在 class 内</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Com3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;  state = &#123;<span class="hljs-attr">xxx</span>:xxx&#125;  func1 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">this</span>.setState(xxx:xxx)  &#125;  <span class="hljs-keyword">static</span> propTypes = &#123;    prop1:PropTypes.string.isRequired,<span class="hljs-comment">// isRequired</span>    prop2:PropTypes.number    prop3:PropTypes.func <span class="hljs-comment">// function</span>  &#125;  <span class="hljs-keyword">static</span> defaultProps = &#123;    prop1:<span class="hljs-string">&#x27;xxx&#x27;</span>,    prop2:<span class="hljs-number">123</span>  &#125;&#125;</code></pre></div><ul><li>  <code>constructor</code>中要使用<code>this.props</code>就必须接收并<code>super</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;  <span class="hljs-built_in">super</span>(props)  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.props);&#125;</code></pre></div><h3 id="「refs」"><a href="#「refs」" class="headerlink" title="「refs」"></a>「refs」</h3><h4 id="1-字符串形式-过时-API"><a href="#1-字符串形式-过时-API" class="headerlink" title="1.字符串形式( 过时 API )"></a>1.字符串形式( <em>过时 API</em> )</h4><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;xxx ref=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</code></pre></div><h4 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;xxx ref=&#123;<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span><span class="hljs-built_in">this</span>.input1=c&#125;&gt;<span class="hljs-comment">// 就能挂载在 实例.input1 上</span></code></pre></div><blockquote><p>组件渲染时先会把 ref 清空(为 null),再赋值</p></blockquote><blockquote><p>使用 class 内绑定函数接收 node 可以避免上述</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript">saveNode = <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-built_in">this</span>.input1 = c<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> (    &lt;input ref=&#123;<span class="hljs-built_in">this</span>.saveNode&#125;&gt;&lt;/input&gt;  )&#125;</code></pre></div><h4 id="3-createRef"><a href="#3-createRef" class="headerlink" title="3.createRef"></a>3.createRef</h4><p>单一 ref 专用</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">input1 = React.createRef()<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> (    &lt;input ref=&#123;<span class="hljs-built_in">this</span>.input1&#125;&gt;&lt;/input&gt;  )&#125;<span class="hljs-comment">// this.input1.current</span></code></pre></div><h1 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h1><h2 id="🚮旧生命周期-lt-16"><a href="#🚮旧生命周期-lt-16" class="headerlink" title="🚮旧生命周期(&lt;=16)"></a>🚮旧生命周期(&lt;=16)</h2><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li>  <code>constructor</code></li><li>  <code>componentWillMount</code></li><li>  <code>render</code></li><li>  <code>componentDidMount</code></li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li>  <code>componentWillReceiveProps</code></li><li>  <code>shouldComponentUpdate</code>&lt;– setState()</li><li>  <code>componentWillUpdate</code>&lt;—- forceUpdate()</li><li>  <code>render</code></li><li>  <code>componentDidUpdate</code></li></ul><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ul><li>  <code>componentWillUnmount</code></li></ul><h2 id="💡新生命周期-gt-16"><a href="#💡新生命周期-gt-16" class="headerlink" title="💡新生命周期(&gt;16)"></a>💡新生命周期(&gt;16)</h2><p><img src="../images/react_new.png" alt="生命周期"><br>示意图:<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p><h3 id="过时钩子"><a href="#过时钩子" class="headerlink" title="过时钩子"></a>过时钩子</h3><ul><li><p><code>UNSAFE_componentWillMount</code></p><blockquote><p>在此方法中同步调用 setState() 不会触发额外渲染</p></blockquote></li><li><p><code>UNSAFE_componentWillReceiveProps</code></p><blockquote><p>在组件接受新的props之前调用</p></blockquote></li></ul><ul><li><code>UNSAFE_componentWillUpdate</code></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.</span><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)// 2.不常用,仅适用于<span class="hljs-title">props</span>派生<span class="hljs-title">state</span>的情况,但会在每次<span class="hljs-title">render</span>之前调用<span class="hljs-title">static</span> <span class="hljs-title">getDerivedStateFromProps</span>(<span class="hljs-params">prop,state</span>)// 3.纯函数<span class="hljs-title">render</span>// 4.组件挂载到<span class="hljs-title">DOM</span>后<span class="hljs-title">componentDidMount</span></code></pre></div><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 不常用</span><span class="hljs-keyword">static</span> getDerivedStateFromProps(prop,state)<span class="hljs-comment">//2.判断是否更新组件，</span><span class="hljs-comment">//  默认行为是true </span><span class="hljs-comment">//  当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用</span><span class="hljs-comment">// 使用forceUpdate可以跳过该方法</span>shouldComponentUpdate = ():boolean<span class="hljs-comment">//3.</span>render<span class="hljs-comment">//4.获取最近一次DOM更新前的DOM信息</span>getSnapshotBeforeUpdate = (prevProps,prevState):snapshot<span class="hljs-comment">//5.</span>componentDidUpdate(prevProps,preState,snapshot)</code></pre></div><h3 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h3><ul><li>  <code>componentWillUnmount</code></li></ul><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// /src/setupProxy.js</span><span class="hljs-comment">// CommonJS语法</span><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http-proxy-middleware&quot;</span>);<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">app</span>) </span>&#123;app.use(proxy(<span class="hljs-string">&quot;/api1&quot;</span>, &#123;target: <span class="hljs-string">&quot;http://xxxxxx&quot;</span>,changeOrigin: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Host字段</span>pathRewrite: &#123; <span class="hljs-string">&quot;/api1&quot;</span>: <span class="hljs-string">&quot;&quot;</span> &#125;,&#125;));&#125;;</code></pre></div><h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><ol><li><p><code>Props</code></p></li><li><p><code>PubSubJS</code>发布订阅模式<br><a href="https://github.com/mroderick/PubSubJS">https://github.com/mroderick/PubSubJS</a></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// create a function to subscribe to topics</span><span class="hljs-keyword">var</span> mySubscriber = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg, data</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(msg, data);&#125;;<span class="hljs-comment">// add the function to the list of subscribers for a particular topic</span><span class="hljs-comment">// we&#x27;re keeping the returned token, in order to be able to unsubscribe</span><span class="hljs-comment">// from the topic later on</span><span class="hljs-keyword">var</span> token = PubSub.subscribe(<span class="hljs-string">&quot;MY TOPIC&quot;</span>, mySubscriber);<span class="hljs-comment">// publish a topic asynchronously</span>PubSub.publish(<span class="hljs-string">&quot;MY TOPIC&quot;</span>, <span class="hljs-string">&quot;hello world!&quot;</span>);<span class="hljs-comment">// publish a topic synchronously, which is faster in some environments,</span><span class="hljs-comment">// but will get confusing when one topic triggers new topics in the</span><span class="hljs-comment">// same execution chain</span><span class="hljs-comment">// USE WITH CAUTION, HERE BE DRAGONS!!!</span>PubSub.publishSync(<span class="hljs-string">&quot;MY TOPIC&quot;</span>, <span class="hljs-string">&quot;hello world!&quot;</span>);</code></pre></div></li><li><p><code>Context</code></p><blockquote><p>类似 vue 的 provide 和 inject</p></blockquote> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//祖先组件中</span><span class="hljs-keyword">const</span> MyContext1 = React.createContext(defaultValue);<span class="hljs-keyword">const</span> MyContext2  = React.createContext(defaultValue);<span class="hljs-comment">// defaultValue在不传value时生效</span><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> (    <span class="hljs-comment">// value应使用state属性避免意外的consumer更新</span>    &lt;Mycontext1.Provider value=&#123;&#125;&gt;      &lt;MyContext2.Provider value=&#123;&#125;&gt;        ...&lt;children /&gt;      &lt;/MyContext2.Provider&gt;    &lt;/Mycontext1.Provider&gt;  )&#125;</code></pre></div> <div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 子组件中</span><span class="hljs-comment">// class</span><span class="hljs-keyword">static</span> contextType = MyContext1 <span class="hljs-comment">//只适用于消费一个context的情况</span><span class="hljs-built_in">this</span>.context<span class="hljs-comment">//取值</span><span class="hljs-comment">// class&amp;hooks</span>&lt;MyContext2.Consumer&gt;  &#123;    value=&gt;(      <span class="hljs-comment">// render...</span>    )  &#125;&lt;/MyContext2.Consumer&gt;</code></pre></div></li><li><p><code>Redux</code></p></li></ol><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="根路由标签"><a href="#根路由标签" class="headerlink" title="根路由标签"></a>根路由标签</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; BrowserRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<span class="hljs-keyword">import</span> &#123; HashRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;ReactDOM.render(&lt;React.StrictMode&gt;&lt;BrowserRouter&gt;&lt;App&gt;&lt;/App&gt;&lt;/BrowserRouter&gt;<span class="hljs-comment">/* &lt;HashRouter&gt;</span><span class="hljs-comment">&lt;App /&gt;</span><span class="hljs-comment">&lt;/HashRouter&gt; */</span>&lt;/React.StrictMode&gt;,<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>));</code></pre></div><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/xxx&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;ComXXX1&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;ComXXX2&#125;&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- ComXXX1 ComXXX2都渲染 --&gt;</span>&lt;/Route&gt;&lt;/Route&gt;</code></pre></div><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span>/* Switch标签内只会渲染第一个匹配成功的组件 */<span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;Home&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;About&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/:user&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;User&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;NoMatch&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></code></pre></div><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;ComXXX1&#125;&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 严格匹配 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></code></pre></div><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><ul><li><code>match</code><ul><li>  ⭐️<code>params</code> - (object) key／value 与动态路径的 URL 对应解析</li></ul></li><li><code>location</code><ul><li>  <code>pathname</code> - (string 类型) URL 路径</li><li>  ⭐️<code>search</code>- (string 类型) URL 中的查询字符串</li><li>  <code>hash</code> - (string 类型) URL 的哈希片段</li><li>  ⭐️<code>state </code>- (object 类型) 提供给例如使用 push(path, state) 操将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用。</li></ul></li><li>  <code>history</code></li></ul><h3 id="URL-传-params"><a href="#URL-传-params" class="headerlink" title="URL 传 params"></a>URL 传 params</h3><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=`/<span class="hljs-attr">xxx</span>/$&#123;<span class="hljs-attr">xxx.param1</span>&#125;`&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx/param1:param1&quot;</span>&gt;</span> // props.match.params // &#123;param1:xxx&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></code></pre></div><h3 id="URL-传-search"><a href="#URL-传-search" class="headerlink" title="URL 传 search"></a>URL 传 search</h3><p>使用<code>querrystring</code>处理 urlencode</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=`/<span class="hljs-attr">xxx</span>?<span class="hljs-attr">param1</span>=<span class="hljs-string">$&#123;xxx.param1&#125;&amp;param2</span>=<span class="hljs-string">$&#123;xxx.param2&#125;</span>`&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span>&gt;</span>// props.location.search // &quot;?param1=xxx&amp;param1=xxx&quot; //qs.parse(props.location.search.slice(1)) =&gt; &#123;...&#125;&lt;/Route&gt;</code></pre></div><h3 id="传-state"><a href="#传-state" class="headerlink" title="传 state"></a>传 state</h3><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#123;&#123;pathname:</span>&#x27;/<span class="hljs-attr">xxx</span>&#x27;,<span class="hljs-attr">state:</span>&#123;<span class="hljs-attr">param1:xxx.param1</span>&#125;&#125;&#125;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span>&gt;</span> // props.location.state<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></code></pre></div><h2 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h2><p><code>this.props.history</code></p><ul><li><code>history</code><ul><li>  <code>go</code>(n) - (function 类型) 将 history 堆栈中的指针调整 n</li><li>  <code>goBack</code>() - (function 类型) 等同于 go(-1)</li><li>  <code>goForward</code>() - (function 类型) 等同于 go(1)</li><li>  <code>push</code>(path, [state]) - (function 类型) 在 history 堆栈添加个新目</li><li>  <code>replace</code>(path, [state]) - (function 类型) 替换在 history 堆中的</li></ul></li></ul><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>可以通过 <code>withRouter</code> 高阶组件访问 <code>history</code> 对象的属性和最近的 <code>&lt;Route&gt;</code> 的 <code>match</code> 。 当路由渲染时， <code>withRouter</code> 会将已经更新的 <code>match</code> ， <code>location</code> 和 <code>history</code> 属性传递给被包裹的组件。</p><h1 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h1><ul><li><code>antd</code>的样式按需引入<br>  (<a href="https://3x.ant.design/docs/react/use-with-create-react-app-cn)[https://3x.ant.design/docs/react/use-with-create-react-app-cn]">https://3x.ant.design/docs/react/use-with-create-react-app-cn)[https://3x.ant.design/docs/react/use-with-create-react-app-cn]</a></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ./config-overrides.js</span><span class="hljs-keyword">const</span> &#123; override, fixBabelImports, addLessLoader &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">`customize-cra`</span>);<span class="hljs-built_in">module</span>.exports = override(fixBabelImports(<span class="hljs-string">&quot;import&quot;</span>, &#123;libraryName: <span class="hljs-string">&quot;antd&quot;</span>,libraryDirectory: <span class="hljs-string">&quot;es&quot;</span>,style: <span class="hljs-literal">true</span>,&#125;));</code></pre></div><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><ul><li><code>action</code><ul><li>  同步<code>action&lt;object&gt;</code></li><li>  异步<code>action&lt;function&gt;</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs">原生只能处理同步action,action中的switch机制</code></pre></div></li><li>  <code>reducer</code></li><li><code>store</code><ul><li>  <code>dispatch</code></li><li>  <code>subscribe</code></li></ul></li></ul><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><ul><li><p><code>reducer</code><br>  reducer 就是一个纯函数:</p><blockquote><p>纯函数:</p><ol><li>不修改参数</li><li>不产生副作用</li><li>不调用不纯的方法<code>Math.random()``new Date()</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> initState = <span class="hljs-number">0</span>;interface Action &#123;type: string;data: number;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countReducer</span>(<span class="hljs-params">preState = initState, action: Action</span>) </span>&#123;<span class="hljs-keyword">const</span> &#123; type, data &#125; = action;<span class="hljs-keyword">switch</span> (type) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:<span class="hljs-keyword">return</span> preState + data;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:<span class="hljs-keyword">return</span> preState - data;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> preState;&#125;&#125;</code></pre></div></li></ol></blockquote></li><li><p><code>container</code></p><p>  使用哟 container 包裹 ui 组件,container 负责与 store 的交互,操作和数据通过 props 传给 ui 组件.</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// container.ts</span><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<span class="hljs-keyword">import</span> XXXUI <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../XXX&quot;</span>;<span class="hljs-keyword">import</span> &#123;XXXaction,XXXaction&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../redux/ACTIONS&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapStateToProps</span>(<span class="hljs-params">state</span>) </span>&#123;  ...&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapDispatchToProps</span>(<span class="hljs-params">dispatch</span>)</span>&#123;  <span class="hljs-keyword">return</span>&#123;    ...  &#125;&#125;<span class="hljs-keyword">const</span> CountContainer = connect(mapStateToProps,mapDispatchToProps)(XXXUI);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> CountContainer;</code></pre></div></li><li><p><code>多个reducer</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// store.ts</span><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware, combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<span class="hljs-keyword">import</span> countReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reducers/count&quot;</span>;<span class="hljs-keyword">import</span> peopleReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reducers/peolple&quot;</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-thunk&quot;</span>;<span class="hljs-keyword">const</span> allReducer = combineReducers(&#123;count: countReducer,people: peopleReducer,&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(allReducer, applyMiddleware(thunk));</code></pre></div></li></ul><h2 id="redux-devtools"><a href="#redux-devtools" class="headerlink" title="redux-devtools"></a>redux-devtools</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">yarn add redux-devtools-extension<span class="hljs-comment">// store.ts</span><span class="hljs-keyword">import</span> &#123; composeWithDevtools&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-devtools-extension&#x27;</span>...<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(  allReducer, composeWithDevtools(applyMiddleware(thunk)))</code></pre></div><h2 id="减少样板代码"><a href="#减少样板代码" class="headerlink" title="减少样板代码"></a>减少样板代码</h2><ul><li><p>redux-actions<br>  <a href="https://github.com/redux-utilities/redux-actions">https://github.com/redux-utilities/redux-actions</a><br>  协助生成 action creator</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-actions&#x27;</span>...<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> increment = createAction(<span class="hljs-string">&#x27;INCREMENT&#x27;</span>)<span class="hljs-keyword">import</span> &#123; handleActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-action&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> handleActions(&#123;  INCREMENT:<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state + <span class="hljs-number">1</span>&#125;,<span class="hljs-number">0</span>)</code></pre></div></li><li><p>  cli(yeoman)</p></li></ul><h1 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h1><p>函数式组件获得类组件能力</p><h2 id="StateHook"><a href="#StateHook" class="headerlink" title="StateHook"></a>StateHook</h2><p><code>const [currentValue,setNewValue] = React.useState(initValue)</code><br><code>setNewValue(newValue) or setNewValue(value=&gt;&#123;...newValue&#125;)</code></p><h2 id="EffectHook"><a href="#EffectHook" class="headerlink" title="EffectHook"></a>EffectHook</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">React.useEffect(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 副作用操作</span><span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// willUnMount</span>&#125;;&#125;, [stateValue]); <span class="hljs-comment">// 为[]则相当于didMount</span></code></pre></div><p>三种情况</p><ol><li>useEffect(fn) -&gt; Mount+Update</li><li>useEffect(fn,[]) -&gt; Mount</li><li>useEffect(fn,[dep]) -&gt; Mount 和 dep 变化时</li></ol><h2 id="RefHook"><a href="#RefHook" class="headerlink" title="RefHook"></a>RefHook</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xxxRef = React.useRef();</code></pre></div><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><ul><li><p>对象式</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">setState(<span class="hljs-string">`stateChange(状态改变对象)`</span>, [callBack]);</code></pre></div></li><li><p>函数式</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">setState(<span class="hljs-string">`updater(返回stateChange对象的函数)`</span>,[callback])<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updater</span>(<span class="hljs-params">state,props</span>)</span>&#123;  ... 接收state和props参数&#125;</code></pre></div></li><li><p>  <code>callback</code>在<code>render()</code>后调用</p></li></ul><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p><code>React.lazy</code>使用 dynamic import 标准,返回一个 promise,在 pending 状态期间渲染 loading 组件</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;lazy,Suspense&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> Com1 = lazy(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Com1/index&#x27;</span>)&#125;)<span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> (    &lt;NavLink to=<span class="hljs-string">&quot;/com1&quot;</span>&gt;Com1&lt;/NavLink&gt;    &lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span>&#125;&gt;      &lt;Route path=<span class="hljs-string">&quot;/com1&quot;</span> component=&#123;Com1&#125; /&gt;    &lt;/Suspense&gt;  )&#125;</code></pre></div><h2 id="JSX-Fragment"><a href="#JSX-Fragment" class="headerlink" title="JSX Fragment"></a>JSX Fragment</h2><blockquote><p>代替根 div</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; Fragment &#125;&gt; from &#x27;react`<span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span><span class="hljs-comment">&lt;!-- 可以拥有key --&gt;</span><span class="hljs-comment">&lt;!-- 短语法 --&gt;</span><span class="hljs-tag">&lt;&gt;</span>...<span class="hljs-tag">&lt;/&gt;</span></code></pre></div><h2 id="子组件更新"><a href="#子组件更新" class="headerlink" title="子组件更新"></a>子组件更新</h2><blockquote><p>一般子组件即使 props 没改变或者没接受 props 也会随父组件 rerender</p></blockquote><p><code>PureComponent</code>**_<strong>浅层</strong>_**比较<code>props</code>和<code>state</code>,同时<code>shouldComponentUpdate</code> 将跳过所有子组件树的 <code>prop</code> 更新</p><h2 id="组件-composition"><a href="#组件-composition" class="headerlink" title="组件 composition"></a>组件 composition</h2><blockquote><p>组件可以接受任意 props，包括基本数据类型</p></blockquote><blockquote><p>将 jsx 元素以及函数通过 props 传递实现类似 vue slot 效果</p></blockquote><blockquote><p>向组件内部动态传入内容</p></blockquote><ol><li><code>.children</code>获得组件标签内内容</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FancyBorder</span>(<span class="hljs-params">props</span>) </span>&#123;<span class="hljs-keyword">return</span> (&lt;div className=&#123;<span class="hljs-string">&quot;FancyBorder FancyBorder-&quot;</span> + props.color&#125;&gt;&#123;props.children&#125;&lt;/div&gt;);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WelcomeDialog</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> (&lt;FancyBorder color=<span class="hljs-string">&quot;blue&quot;</span>&gt;&lt;h1 className=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;Welcome&lt;/h1&gt;&lt;p className=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;Thank you <span class="hljs-keyword">for</span> visiting our spacecraft!&lt;/p&gt;&lt;/FancyBorder&gt;);&#125;</code></pre></div><ol start="2"><li>或者使用约定名称</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SplitPane</span>(<span class="hljs-params">props</span>) </span>&#123;<span class="hljs-keyword">return</span> (&lt;div className=<span class="hljs-string">&quot;SplitPane&quot;</span>&gt;&lt;div className=<span class="hljs-string">&quot;SplitPane-left&quot;</span>&gt;&#123;props.left&#125;&lt;/div&gt;&lt;div className=<span class="hljs-string">&quot;SplitPane-right&quot;</span>&gt;&#123;props.right&#125;&lt;/div&gt;&lt;/div&gt;);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SplitPane</span> <span class="hljs-attr">left</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Contacts</span> /&gt;</span>&#125; right=&#123;<span class="hljs-tag">&lt;<span class="hljs-name">Chat</span> /&gt;</span>&#125; /&gt;</span>;&#125;</code></pre></div><ol start="3"><li>通过 props 传递携带另一个 props 的函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">A</span> <span class="hljs-attr">customizeFn</span>=<span class="hljs-string">&#123;(p1)</span>=&gt;</span>&#123;<span class="hljs-tag">&lt;<span class="hljs-name">B</span> <span class="hljs-attr">p1</span>=<span class="hljs-string">&#123;p1&#125;/</span>&gt;</span>&#125;&#125;/&gt;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> [state,changeState] = React.useState(<span class="hljs-number">123</span>)  <span class="hljs-keyword">return</span> (    &lt;div&gt;我是A组件&lt;/div&gt;    &#123;props.customizeFn(state)&#125;  )&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">props</span>)</span>&#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;我是B我收到了&#123;props.p1&#125;&lt;/div&gt;  )&#125;</code></pre></div><h2 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h2><p>错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI，而并不会渲染那些发生崩溃的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">getDerivedStateFromError</span>(<span class="hljs-params">error</span>)</span> &#123;  <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;&#125;<span class="hljs-function"><span class="hljs-title">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>)</span> &#123;  <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>  logErrorToMyService(error, errorInfo);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react拾遗</title>
    <link href="/2022/02/24/react%E6%8B%BE%E9%81%97/"/>
    <url>/2022/02/24/react%E6%8B%BE%E9%81%97/</url>
    
    <content type="html"><![CDATA[<h1 id="⭐️-生命周期"><a href="#⭐️-生命周期" class="headerlink" title="⭐️ 生命周期"></a>⭐️ 生命周期</h1><h2 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h2><blockquote><p>将状态变化渲染到视图中</p></blockquote><ol><li>beforeMutation</li><li>mutation</li><li>layout</li></ol><h1 id="⭐️Hooks"><a href="#⭐️Hooks" class="headerlink" title="⭐️Hooks"></a>⭐️Hooks</h1><h1 id="⭐️Redux"><a href="#⭐️Redux" class="headerlink" title="⭐️Redux"></a>⭐️Redux</h1><h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a><code>createStore</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment">* @param &#123;Function&#125; reducer</span><span class="hljs-comment">* @param &#123;any&#125; preloadedState 初始化的state</span><span class="hljs-comment">* @param &#123;Function&#125; enhancer 中间件</span><span class="hljs-comment">*/</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStore</span>(<span class="hljs-params">reducer,preloadedState,enhancer</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> preloadedState === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> enhancer === <span class="hljs-string">&#x27;undefined&#x27;</span>)&#123;    <span class="hljs-comment">// 如果preloadedState是个中间件</span>    enhancer = preloadedState    preloadedState = <span class="hljs-literal">undefined</span>  &#125;  <span class="hljs-keyword">let</span> currentReducer = reducer  <span class="hljs-keyword">let</span> currentState = preloadedState <span class="hljs-comment">// 保存state</span>  <span class="hljs-keyword">let</span> currentListeners = [] <span class="hljs-comment">// 监听者数组</span>  <span class="hljs-keyword">let</span> nextListeners = currentListeners  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getState</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> currentState  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribe</span>(<span class="hljs-params">listener</span>)</span>&#123;    <span class="hljs-keyword">if</span>(nextListeners === currentListeners)&#123;      nextListeners = [...currentListeners]      <span class="hljs-comment">// 浅拷贝一次,避免影响别的地方修改currentListeners</span>    &#125;    nextListeners.push(listener)    <span class="hljs-comment">// 添加监听</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unsubscribe</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">if</span>(nextListeners === currentListeners)&#123;        nextListeners = [...currentListeners]      &#125;      <span class="hljs-keyword">const</span> index = nextListeners.indexOf(listener)      nextListeners.splice(index,<span class="hljs-number">1</span>)      <span class="hljs-comment">// 移除监听</span>    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">action</span>) </span>&#123;    currentState = currentReducer(currentState,action) <span class="hljs-comment">// 计算新state</span>    <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners) <span class="hljs-comment">// 更新currentListeners数组</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i&lt;listener.length;i++&gt;)&#123;      listeners[i]()    &#125;    <span class="hljs-keyword">return</span> action  &#125;  dispatch(&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;INIT&#x27;</span>&#125;)  <span class="hljs-comment">// 手动触发一次dispatch,初始化state</span>  <span class="hljs-keyword">return</span>&#123;    getState,    subscribe,    dispatch  &#125;&#125;</code></pre></div><h1 id="⭐️React-redux"><a href="#⭐️React-redux" class="headerlink" title="⭐️React-redux"></a>⭐️React-redux</h1><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a><code>connect</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// connect(...)(UI组件)</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params">mapStateToProps = state =&gt; state,mapDispatchToToProps = ()=&gt;&#123;&#125;</span>) =&gt; (<span class="hljs-params">WrapComponent</span>) =&gt; </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;    <span class="hljs-keyword">static</span> contextTypes = &#123;      store:PropTypes.object    &#125;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props,context</span>)</span>&#123;      <span class="hljs-comment">// context由上层Provider传下</span>      <span class="hljs-built_in">super</span>(props,context)      <span class="hljs-built_in">this</span>.state = &#123;        props:&#123;&#125;      &#125;    &#125;    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">const</span> &#123; store &#125; = <span class="hljs-built_in">this</span>.context      store.subscribe(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">this</span>.update()) <span class="hljs-comment">// store添加加update这个回调</span>      <span class="hljs-comment">// store中state改变时触发这个update方法</span>      <span class="hljs-built_in">this</span>.update()    &#125;    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-comment">// update方法将最新的store属性收集并传给ui组件</span>      <span class="hljs-keyword">const</span> &#123; store &#125; = <span class="hljs-built_in">this</span>.context      <span class="hljs-keyword">const</span> stateProps = mapStateToProps(store.getState())      <span class="hljs-keyword">const</span> dispatchProps = mapDispatchToToProps(store.dispatch)      <span class="hljs-comment">// 取得store中的state和dispatch</span>      <span class="hljs-built_in">this</span>.setState(&#123;        props:&#123;          ...this.state.props,          ...stateProps,          ...dispatchProps        &#125;      &#125;)      <span class="hljs-comment">// setState导致render(),更新子组件props</span>    &#125;    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">return</span> (        <span class="hljs-comment">// 作为正常props一股脑丢给UI组件</span>        &lt;WrapComponent &#123;...this.state.props&#125; /&gt;      )    &#125;  &#125;&#125;</code></pre></div><h1 id="⭐️-面试题"><a href="#⭐️-面试题" class="headerlink" title="⭐️ 面试题"></a>⭐️ 面试题</h1><ul><li><p><code>useEffec</code>(fn,[])和 componentDidMount 的区别</p><ol><li><code>useEffec</code>(fn,[])在<code>commit</code>执行完之后异步执行 fn 回调</li><li><code>componentDidMount</code>在<code>commit中的mutation</code>执行完时候和<code>layout</code>同步执行</li><li><code>useLayoutEffec</code>能实现和<code>👆</code>一样的效果</li></ol></li><li><p><code>react-redux</code>如何将 store 的 state 注入组件</p><p>  通过<code>connect</code>函数在 ui 组件上套壳,将来自 provider 的 context 中取出 store 并将其属性作为 props 传给 ui 组件,同时订阅 store 的更新保证 props 数据也是最新的</p></li><li><p><code>redux-thunk</code>中间件</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-thunk&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> createStore(xxx-reducer, applyMiddleware(thunk));</code></pre></div><p>  后就可以使用 function 作为 action</p></li><li><p><code>setState同步异步</code></p><ol><li>合成事件和生命周期中的<code>setState</code>是异步的</li><li>原生事件和<code>setTimeout</code>中的<code>setState</code>是同步的</li><li>使用<code>setState</code>的<code>callback</code>总能拿到最新的值</li><li>setState自带批处理优化，多次调用只会执行最新的一次</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>require.context()</title>
    <link href="/2022/02/24/require.context%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/02/24/require.context%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>自动化注册组件</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// global.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> upperFirst <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/upperFirst&#x27;</span><span class="hljs-keyword">import</span> camelCase <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/camelCase&#x27;</span><span class="hljs-keyword">const</span> requireComponent = <span class="hljs-built_in">require</span>.context(  <span class="hljs-comment">// 其组件目录的相对路径</span>  <span class="hljs-comment">// 全局注册的目录</span>  .,  <span class="hljs-comment">// 是否查询其子目录</span>  <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 匹配基础组件文件名的正则表达式</span>  <span class="hljs-comment">// /Base[A-Z]\w+\.(vue|js)$/</span>  /\.vue$/)requireComponent.keys().forEach(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> &#123;  <span class="hljs-comment">// 获取组件配置</span>  <span class="hljs-keyword">const</span> componentConfig = requireComponent(fileName)  <span class="hljs-comment">// 获取组件的 PascalCase 命名</span>  <span class="hljs-keyword">const</span> componentName = upperFirst(    camelCase(      <span class="hljs-comment">// 获取和目录深度无关的文件名</span>      fileName        <span class="hljs-comment">// .split(&#x27;/&#x27;)</span>        <span class="hljs-comment">// .pop()</span>        .replace(<span class="hljs-regexp">/^\.\//</span>,<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// ‘./ComA.vue’ =&gt; &#x27;ComA.vue&#x27;</span>        .replace(<span class="hljs-regexp">/\.\w+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// =&gt; &#x27;ComA&#x27;</span>    )  )  <span class="hljs-comment">// 全局注册组件</span>  Vue.component(    componentName,    <span class="hljs-comment">// 如果这个组件选项是通过 `export default` 导出的，</span>    <span class="hljs-comment">// 那么就会优先使用 `.default`，</span>    <span class="hljs-comment">// 否则回退到使用模块的根。</span>    componentConfig.default || componentConfig  )&#125;)</code></pre></div></li><li><p>自动化注册路由</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// router.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> Router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>Vue.use(Router)<span class="hljs-keyword">const</span> routerList = []<span class="hljs-keyword">const</span> importAllRouter = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;  r.keys().forEach(<span class="hljs-function"><span class="hljs-params">key</span>=&gt;</span>&#123;    routerList.push(r[key].default  <span class="hljs-comment">/*export default*/</span>)  &#125;)&#125;importAllRouter(<span class="hljs-built_in">require</span>.context(.<span class="hljs-comment">/* 查询目录*/</span>,<span class="hljs-literal">true</span><span class="hljs-comment">/*是否包含子目录*/</span>,<span class="hljs-regexp">/\.router\.js/</span><span class="hljs-regexp">/*匹配正则*/</span>))<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  ...routerList&#125;)</code></pre></div></li><li><p>管理 graph 文件（同理）</p><p>  <img src="https://s2.loli.net/2022/01/04/YoxB7hS6sZDEapr.png"></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> context = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.gql$|\.graphql$/</span>);<span class="hljs-keyword">const</span> map = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> context.keys()) &#123;  <span class="hljs-keyword">const</span> keyArr = key.split(<span class="hljs-string">&quot;/&quot;</span>);  keyArr.shift();  <span class="hljs-keyword">const</span> _key = keyArr[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 删掉文件夹名</span>  map[_key.replace(<span class="hljs-regexp">/\.gql$|\.graphql$/g</span>, <span class="hljs-string">&quot;&quot;</span>)] = context(key);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> map;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>svg图标封装组件</title>
    <link href="/2022/02/24/svg%E5%9B%BE%E6%A0%87%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/02/24/svg%E5%9B%BE%E6%A0%87%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>VUE项目中将svg图标封装为组件,后续拷贝进svg文件直接使用</p></blockquote><h3 id="icon组件"><a href="#icon组件" class="headerlink" title="icon组件"></a>icon组件</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;  &lt;svg :<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;svgClass&quot;</span> aria-hidden=<span class="hljs-string">&quot;true&quot;</span>   <span class="hljs-comment">// /* aria-hidden=&quot;true&quot;将元素从可访问树上移除 */</span>  v-on=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;    &lt;use :xlink:href=<span class="hljs-string">&quot;iconName&quot;</span> /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">&#x27;SvgIcon&#x27;</span>,  props: &#123;    iconClass: &#123;      type: <span class="hljs-built_in">String</span>,      required: <span class="hljs-literal">true</span>    &#125;,    className: &#123;      type: <span class="hljs-built_in">String</span>,      <span class="hljs-keyword">default</span>: <span class="hljs-string">&#x27;&#x27;</span>    &#125;  &#125;,  computed: &#123;    <span class="hljs-function"><span class="hljs-title">iconName</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">`#icon-<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.iconClass&#125;</span>`</span>    &#125;,    <span class="hljs-function"><span class="hljs-title">svgClass</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.className) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;svg-icon &#x27;</span> + <span class="hljs-built_in">this</span>.className      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;svg-icon&#x27;</span>      &#125;    &#125;  &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.svg-icon &#123;  width: 1em;  height: 1em;  vertical-align: -<span class="hljs-number">0.</span>15em;  fill: currentColor;  overflow: hidden;&#125;&lt;/style&gt;</code></pre></div><h3 id="配置自动引入svg文件"><a href="#配置自动引入svg文件" class="headerlink" title="配置自动引入svg文件"></a>配置自动引入svg文件</h3><p>使用<code>webpack</code>的<code>require.context</code>API，两种方法</p><blockquote><p><code>assets/icon</code>是存放<code>svg</code>图标文件的路径</p></blockquote><ol><li>在<code>assets/icon</code>新建<code>index.js</code></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> SvgIcon <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/SvgIcon&#x27;</span>Vue.component(<span class="hljs-string">&#x27;svg-icon&#x27;</span>, SvgIcon)<span class="hljs-keyword">const</span> importAll = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.keys().forEach(r)<span class="hljs-keyword">const</span> svgContext = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#x27;@/assets/icon&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>);<span class="hljs-comment">// 获取该目录下所有.svg的context</span>importAll(svgContext)<span class="hljs-comment">//在main.js中导入</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/assets/icon/index&#x27;</span></code></pre></div><ol start="2"><li>或者直接在<code>main.js</code>中</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> SvgIcon <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/SvgIcon&#x27;</span><span class="hljs-keyword">const</span> importAll = <span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.keys().forEach(r)<span class="hljs-keyword">const</span> svgContext = <span class="hljs-built_in">require</span>.context(<span class="hljs-string">&#x27;@/assets/icon&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>);<span class="hljs-comment">// 获取该目录下所有.svg的context</span>importAll(svgContext)Vue.component(<span class="hljs-string">&#x27;svg-icon&#x27;</span>,SvgIcon) <span class="hljs-comment">// 全局注册</span></code></pre></div><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><ul><li><code>svg-baker-runtime</code></li><li><code>svg-sprite-loader</code></li><li>配置<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// vue.config.js</span>chainWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> svgRule = config.module.rule(<span class="hljs-string">&quot;svg&quot;</span>);  svgRule.uses.clear();  svgRule    .rule(<span class="hljs-string">&quot;icons&quot;</span>)    .test(<span class="hljs-regexp">/\.svg$/</span>)    .include.add(resolve(<span class="hljs-string">&quot;src/assets/icon&quot;</span>))    .end()    .use(<span class="hljs-string">&quot;svg-sprite-loader&quot;</span>)    .loader(<span class="hljs-string">&quot;svg-sprite-loader&quot;</span>)    .options(&#123;      symbolId: <span class="hljs-string">&quot;[name]&quot;</span>,    &#125;);&#125;,</code></pre></div></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>尺寸可以自己覆盖样式</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;svg-icon  :icon-<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;cardData.platform&quot;</span>  style=<span class="hljs-string">&quot;width: 2em; height: 2em;vertical-align:middle&quot;</span>&gt;&lt;/svg-icon&gt;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>topK问题</title>
    <link href="/2022/02/24/topK/"/>
    <url>/2022/02/24/topK/</url>
    
    <content type="html"><![CDATA[<h2 id="最大-小的-K-个数，第-K-个最大-最小值"><a href="#最大-小的-K-个数，第-K-个最大-最小值" class="headerlink" title="最大/小的 K 个数，第 K 个最大/最小值"></a>最大/小的 K 个数，第 K 个最大/最小值</h2><ul><li><p>局部冒泡<br>！！输出结果无序</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;    <span class="hljs-comment">// 冒泡执行k次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.length - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;        [arr[j], arr[j - <span class="hljs-number">1</span>]] = [arr[j - <span class="hljs-number">1</span>], arr[j]];      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// K相当于冒泡次数</span><span class="hljs-comment">//前k个小值</span>data.slice(<span class="hljs-number">0</span>, k);<span class="hljs-comment">//第k小的值</span>data[k - <span class="hljs-number">1</span>];</code></pre></div></li><li><p>堆排序</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// topk</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapObj</span>(<span class="hljs-params">items,k</span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,...items.slice(<span class="hljs-number">0</span>,k)]  <span class="hljs-keyword">const</span> heapSize = k  buildHeap(heap,heapSize)  <span class="hljs-comment">// 求大值，建立最小堆</span>  <span class="hljs-comment">// 后续与最小堆堆顶比较</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt; items.length ; j++)&#123;    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; items[j])&#123;      <span class="hljs-comment">// 如果大于最小</span>      <span class="hljs-comment">// 作为堆顶的新值，调整堆</span>      heap[<span class="hljs-number">1</span>] = items[j]      heapify(heap,heapSize,<span class="hljs-number">1</span>)    &#125;  &#125;  <span class="hljs-keyword">return</span> heap.slice(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 前k个大值</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)</span>&#123;  <span class="hljs-keyword">if</span>(heapSize === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt; <span class="hljs-number">0</span> ; i --)&#123;    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i] &lt; items[i]) minIndex = <span class="hljs-number">2</span>*i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; items[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span>(minIndex===i) <span class="hljs-keyword">break</span>    [items[i],items[minIndex]] = [items[minIndex],items[i]]    i = minIndex  &#125;&#125;</code></pre></div><ul><li>快速选择<blockquote><p>快排的改装</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 第k大的元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr,k</span>)</span>&#123;  <span class="hljs-keyword">return</span> quick(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>,k)  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quick</span>(<span class="hljs-params">arr,l,r,k</span>)</span>&#123;    <span class="hljs-keyword">const</span> index = partition(arr,l,r)    <span class="hljs-comment">// 这里开始和一般快排不同</span>    <span class="hljs-comment">// 第k大的值，索引为k-1</span>    <span class="hljs-comment">// partition选出的位置与这个k比较</span>    <span class="hljs-comment">// 根据pivot与k-1的相对位置，每次只用继续partition一半</span>    <span class="hljs-keyword">if</span>(index === k-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> arr[index]    &#125;    <span class="hljs-keyword">if</span>(index &gt; k-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> quick(arr,l,index-<span class="hljs-number">1</span>,k)    &#125;    <span class="hljs-keyword">if</span>(index &lt; k-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> quick(arr,index+<span class="hljs-number">1</span>,r,k)    &#125;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr,l,r</span>)</span>&#123;  <span class="hljs-keyword">const</span> pivot = arr[r]  <span class="hljs-keyword">let</span> i = l  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = l;j&lt;r;j++)&#123;    <span class="hljs-keyword">if</span>(arr[j]&lt;pivot)&#123;      [arr[j],arr[i]] = [arr[i],arr[j]]      i++    &#125;  &#125;  [arr[i],arr[r]] = [arr[r],arr[i]]  <span class="hljs-keyword">return</span> i &#125;</code></pre></div></li></ul><h2 id="出现最多-最少的-K-个元素"><a href="#出现最多-最少的-K-个元素" class="headerlink" title="出现最多/最少的 K 个元素"></a>出现最多/最少的 K 个元素</h2><ul><li>傻瓜 map 映射一个 arr 进行排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-keyword">const</span> ret = [...new <span class="hljs-built_in">Set</span>(arr)];  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  ret.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> map.get(b) - map.get(a));  <span class="hljs-keyword">return</span> ret.slice(<span class="hljs-number">0</span>, k);&#125;</code></pre></div><ul><li>map 映射堆排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr, k</span>) </span>&#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();  <span class="hljs-keyword">const</span> heap = [,];  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span> (map.size &lt;= k) <span class="hljs-keyword">return</span> [...map.keys()];  <span class="hljs-comment">//k大于元素数，直接输出</span>  <span class="hljs-keyword">let</span> times = <span class="hljs-number">1</span>;  <span class="hljs-comment">//记数器</span>  <span class="hljs-comment">//小于k的部分直接建立堆，大于的部分开始与堆top比较</span>  map.forEach(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (times &lt;= k) &#123;      heap.push(key);      <span class="hljs-keyword">if</span> (times === k) &#123;        <span class="hljs-comment">//堆化</span>        buildHeap(heap, map, k);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.get(heap[<span class="hljs-number">1</span>]) &lt; value) &#123;      <span class="hljs-comment">// 与小顶堆顶交换</span>      heap[<span class="hljs-number">1</span>] = key;      heapify(heap, map, k, <span class="hljs-number">1</span>);    &#125;    times++;  &#125;);  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">heap, map, heapSize</span>) </span>&#123;    <span class="hljs-keyword">if</span> (k === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">1</span>; i--) &#123;      heapify(heap, map, heapSize, i);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">heap, map, heapSize, i</span>) </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">let</span> minIndex = i;      <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i &lt;= heapSize &amp;&amp; map.get(heap[<span class="hljs-number">2</span> * i]) &lt; map.get(heap[minIndex]))        minIndex = <span class="hljs-number">2</span> * i;      <span class="hljs-keyword">if</span> (        <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;= heapSize &amp;&amp;        map.get(heap[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>]) &lt; map.get(heap[minIndex])      )        minIndex = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      swap(heap, minIndex, i);      i = minIndex;    &#125;  &#125;  heap.shift();  <span class="hljs-keyword">return</span> heap;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">data, l, r</span>) </span>&#123;  <span class="hljs-keyword">let</span> temp = data[l];  data[l] = data[r];  data[r] = temp;&#125;</code></pre></div><ul><li>桶排序</li></ul><p>出现次数最多的前k个数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMost</span>(<span class="hljs-params">arr,k</span>)</span>&#123;  <span class="hljs-comment">// 记录各数字出现次数</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.has(num)) &#123;      map.set(num, map.get(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.set(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span>(map.size&lt;=k) <span class="hljs-keyword">return</span> [...map.keys()]  <span class="hljs-keyword">return</span> buckerSort(map,k)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buckerSort</span>(<span class="hljs-params">map,k</span>)</span>&#123;  <span class="hljs-comment">// 按照出现次数作为arr数组下标划分桶</span>  <span class="hljs-comment">// 将数字放入桶中</span>  <span class="hljs-keyword">let</span> arr = []  <span class="hljs-keyword">let</span> res = []  map.forEach(<span class="hljs-function">(<span class="hljs-params">value,key</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!arr[value])&#123;      arr[value] = [key]    &#125;<span class="hljs-keyword">else</span>&#123;      arr[value].push(key)    &#125;    <span class="hljs-comment">// 出现了value次的数字有...</span>  &#125;)  <span class="hljs-comment">// 逆向遍历桶数组</span>  <span class="hljs-comment">// </span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = arr.length - <span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> &amp;&amp; res.length &lt; k ; i--)&#123;    <span class="hljs-comment">// 从出现最多的数字开始收集直到收集到k个</span>    <span class="hljs-keyword">if</span>(arr[i])&#123;      res.push(...arr[i])    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue拾遗</title>
    <link href="/2022/02/24/vue%E6%8B%BE%E9%81%97/"/>
    <url>/2022/02/24/vue%E6%8B%BE%E9%81%97/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> <span class="hljs-function"><span class="hljs-title">initLifecycle</span>(<span class="hljs-params">vm</span>)</span>&#123; <span class="hljs-comment">// 初始化生命周期</span><span class="hljs-comment">//关联`$parent`,并将自己添加进父组件的`$children`数组,生成自己的`$children`数组和`$refs`对象,并指定`$root`指针</span>  <span class="hljs-keyword">var</span> parent = options.parent;  parent.$children.push(vm);  vm.$parent = parent;  vm.$root = parent ? parent.$root : vm;  vm.$children = [];  vm.$refs = &#123;&#125;;  vm._watcher = <span class="hljs-literal">null</span>;  vm._inactive = <span class="hljs-literal">null</span>;  vm._directInactive = <span class="hljs-literal">false</span>;  vm._isMounted = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 判断是否mount的flag</span>  vm._isDestroyed = <span class="hljs-literal">false</span>;  vm._isBeingDestroyed = <span class="hljs-literal">false</span>;&#125;<span class="hljs-number">2.</span> <span class="hljs-function"><span class="hljs-title">initEvents</span>(<span class="hljs-params">vm</span>)</span>&#123;<span class="hljs-comment">// 初始化组件级别的监听者</span>  <span class="hljs-keyword">var</span> listeners = vm.$options._parentListeners;  <span class="hljs-keyword">if</span> (listeners) &#123;    updateComponentListeners(vm, listeners);  &#125;&#125;<span class="hljs-number">3.</span> <span class="hljs-function"><span class="hljs-title">initRender</span>(<span class="hljs-params">vm</span>)</span>&#123;<span class="hljs-comment">//绑定createElement方法，绑定$attrs,$listeners,初始化插槽</span>    vm.$slots = resolveSlots(options._renderChildren, renderContext);    vm.$scopedSlots = emptyObject;    <span class="hljs-comment">// bind the createElement fn to this instance</span>    <span class="hljs-comment">// so that we get proper render context inside it.</span>    <span class="hljs-comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span>    <span class="hljs-comment">// internal version is used by render functions compiled from templates</span>    vm._c = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d</span>) </span>&#123; <span class="hljs-keyword">return</span> createElement(vm, a, b, c, d, <span class="hljs-literal">false</span>); &#125;;    <span class="hljs-comment">// normalization is always applied for the public version, used in</span>    <span class="hljs-comment">// user-written render functions.</span>    vm.$createElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d</span>) </span>&#123; <span class="hljs-keyword">return</span> createElement(vm, a, b, c, d, <span class="hljs-literal">true</span>); &#125;;    defineReactive$$1(vm, <span class="hljs-string">&#x27;$attrs&#x27;</span>, parentData &amp;&amp; parentData.attrs || emptyObject, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      !isUpdatingChildComponent &amp;&amp; warn(<span class="hljs-string">&quot;$attrs is readonly.&quot;</span>, vm);    &#125;, <span class="hljs-literal">true</span>);    defineReactive$$1(vm, <span class="hljs-string">&#x27;$listeners&#x27;</span>, options._parentListeners || emptyObject, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      !isUpdatingChildComponent &amp;&amp; warn(<span class="hljs-string">&quot;$listeners is readonly.&quot;</span>, vm);    &#125;, <span class="hljs-literal">true</span>);&#125;<span class="hljs-number">4.</span> callHook(vm, <span class="hljs-string">&#x27;⭐️beforeCreate&#x27;</span>);<span class="hljs-number">5.</span> initInjections(vm); <span class="hljs-comment">// resolve injections before data/props</span><span class="hljs-number">6.</span> initState(vm);<span class="hljs-comment">//初始化状态</span><span class="hljs-comment">//包括props，methods，data，computed，watch</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initState</span> (<span class="hljs-params">vm</span>) </span>&#123;      initProps(vm, opts.props);      initMethods(vm, opts.methods);      initData(vm);      initComputed(vm, opts.computed);      initWatch(vm, opts.watch);    &#125;<span class="hljs-comment">//</span><span class="hljs-number">7.</span> initProvide(vm); <span class="hljs-comment">// resolve provide after data/props</span><span class="hljs-number">8.</span> callHook(vm, <span class="hljs-string">&#x27;⭐️created&#x27;</span>);<span class="hljs-number">9.</span> mountComponent () &#123;      <span class="hljs-number">10.</span> callHook(vm, <span class="hljs-string">&#x27;⭐️beforeMount&#x27;</span>);      <span class="hljs-keyword">let</span> updateComponent;      updateComponent = <span class="hljs-function">() =&gt;</span> &#123;        vm._update(vm._render(), hydrating);        ------update函数        Vue.prototype._update = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vnode, hydrating</span>) </span>&#123;          <span class="hljs-keyword">if</span> (!prevVnode) &#123;            <span class="hljs-comment">// initial render</span>            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="hljs-literal">false</span> <span class="hljs-comment">/* removeOnly */</span>);          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// updates</span>            vm.$el = vm.__patch__(prevVnode, vnode);        &#125;;        ------      &#125;;      ------更新逻辑      <span class="hljs-keyword">new</span> Watcher(vm, updateComponent, noop, &#123;          before: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">before</span> (<span class="hljs-params"></span>) </span>&#123;          <span class="hljs-keyword">if</span> (vm._isMounted) &#123;            callHook(vm, <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>);          &#125;        &#125;      subs[i].notify  ---&gt; Watcher.prototype.update()      callHook(vm, <span class="hljs-string">&#x27;⭐️beforeDestroy&#x27;</span>);      ------  &#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>);      vm._isMounted = <span class="hljs-literal">true</span>;      callHook(vm, <span class="hljs-string">&#x27;mounted&#x27;</span>);    &#125;<span class="hljs-number">14.</span> Vue.prototype.$destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-number">15.</span> callHook(vm, <span class="hljs-string">&#x27;⭐️beforeDestroy&#x27;</span>);    <span class="hljs-comment">// 销毁实例，子实例，从父组件children中删除，销毁所有事件和指令</span>    remove(parent.$children, vm);    vm._watcher.teardown();    vm.__patch__(vm._vnode, <span class="hljs-literal">null</span>);    <span class="hljs-comment">// fire destroyed hook</span>    <span class="hljs-number">16.</span> callHook(vm, <span class="hljs-string">&#x27;⭐️destroyed&#x27;</span>);    vm.$off();    vm.$el.__vue__ = <span class="hljs-literal">null</span>;    vm.$vnode.parent = <span class="hljs-literal">null</span>;  &#125;;&#125;<span class="hljs-comment">// keep-alive</span>callHook(vm, <span class="hljs-string">&#x27;⭐️activated&#x27;</span>);callHook(vm, <span class="hljs-string">&#x27;⭐️deactivated&#x27;</span>);</code></pre></div><h3 id="beforeCreate-之前做了什么"><a href="#beforeCreate-之前做了什么" class="headerlink" title="beforeCreate 之前做了什么"></a>beforeCreate 之前做了什么</h3><ul><li>  绑定<code>$root</code></li><li>  绑定<code>$parent</code></li><li>  将实例 push 进父组件<code>$children</code></li><li>  绑定<code>$attrs</code>和<code>$listener</code></li></ul><h3 id="created-之前做了什么"><a href="#created-之前做了什么" class="headerlink" title="created 之前做了什么"></a>created 之前做了什么</h3><ul><li>  绑定<code>injections</code></li><li>  初始化<code>props,data,methods,watch,computed</code></li><li>  绑定<code>provider</code></li></ul><h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a><code>defineReactive</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">defineReactive (  ...) &#123;  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()  ...  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;    enumerable: <span class="hljs-literal">true</span>,    configurable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// render函数接触data触发getter</span>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">if</span> (Dep.target) &#123;        <span class="hljs-comment">// 此时Dep.target已经是渲染watcher</span>        <span class="hljs-comment">// 执行depend</span>⭐️        dep.depend()        <span class="hljs-keyword">if</span> (childOb) &#123;          ...        &#125;      &#125;      <span class="hljs-keyword">return</span> value    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        <span class="hljs-keyword">return</span>      &#125;      val = newVal🔥    dep.notify()    &#125;  &#125;)&#125;</code></pre></div><h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent "></a><code>mountComponent </code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">mountComponent (...): Component &#123;  callHook(vm, <span class="hljs-string">&#x27;beforeMount&#x27;</span>)  <span class="hljs-keyword">let</span> updateComponent;⭐️ <span class="hljs-comment">// render函数生成虚拟DOM，期间会访问数据</span>  updateComponent = <span class="hljs-function">() =&gt;</span> &#123;    vm._update(vm._render(), hydrating);  &#125;;⭐️ <span class="hljs-comment">//组件`mount`过程中会实例化一个渲染`watcher`，传入updateComponent函数</span>  vm._watcher = <span class="hljs-keyword">new</span> Watcher(vm, updateComponent, noop, &#123;    before () &#123;      <span class="hljs-keyword">if</span> (vm._isMounted) &#123;        callHook(vm, <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)      &#125;    &#125;  &#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>)  <span class="hljs-keyword">if</span> (vm.$vnode == <span class="hljs-literal">null</span>) &#123;    vm._isMounted = <span class="hljs-literal">true</span>    callHook(vm, <span class="hljs-string">&#x27;mounted&#x27;</span>)  &#125;&#125;</code></pre></div><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a><code>Watcher</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span><span class="hljs-params">    vm,</span><span class="hljs-params">    expOrFn,</span><span class="hljs-params">    cb,</span><span class="hljs-params">    options</span><span class="hljs-params">  </span>) &#123;    <span class="hljs-built_in">this</span>.vm = vm;    vm._watchers.push(<span class="hljs-built_in">this</span>);    <span class="hljs-built_in">this</span>.deps = [];    <span class="hljs-built_in">this</span>.newDeps = [];    <span class="hljs-built_in">this</span>.depIds = <span class="hljs-keyword">new</span> _Set();    <span class="hljs-built_in">this</span>.newDepIds = <span class="hljs-keyword">new</span> _Set();    <span class="hljs-comment">// parse expression for getter</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;⭐️ <span class="hljs-comment">// getter此时为传入的updateComponent函数</span>      <span class="hljs-built_in">this</span>.getter = expOrFn;    &#125;  &#125;  get () &#123;⭐️  <span class="hljs-comment">//首先触发watcher中的get（）</span>    <span class="hljs-comment">// pushTarget方法</span>    pushTarget(<span class="hljs-built_in">this</span>)    <span class="hljs-keyword">let</span> value⭐️  <span class="hljs-comment">// 调用getter</span>    value = <span class="hljs-built_in">this</span>.getter.call(vm, vm)    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.deep) &#123;      traverse(value)    &#125;⭐️ <span class="hljs-comment">// 当前组件收集完成后清理</span>    popTarget()    <span class="hljs-built_in">this</span>.cleanupDeps()    <span class="hljs-keyword">return</span> value  &#125;  addDep (dep: Dep) &#123;    <span class="hljs-keyword">const</span> id = dep.id    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(id)) &#123;      <span class="hljs-built_in">this</span>.newDepIds.add(id)      <span class="hljs-built_in">this</span>.newDeps.push(dep)      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.depIds.has(id)) &#123;⭐️ <span class="hljs-comment">//执行addSub</span>        dep.addSub(<span class="hljs-built_in">this</span>)      &#125;    &#125;  &#125;⭐️<span class="hljs-comment">// 对比新旧订阅列表，清空依赖</span>  cleanupDeps () &#123;    <span class="hljs-keyword">let</span> i = <span class="hljs-built_in">this</span>.deps.length    <span class="hljs-keyword">while</span> (i--) &#123;      <span class="hljs-keyword">const</span> dep = <span class="hljs-built_in">this</span>.deps[i]      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.newDepIds.has(dep.id)) &#123;        <span class="hljs-comment">//清空依赖</span>        dep.removeSub(<span class="hljs-built_in">this</span>)      &#125;    &#125;    <span class="hljs-comment">// 每次更新页面，render依赖收集的时候</span>    <span class="hljs-comment">// 将不展示于页面上的数据的依赖移除</span>    <span class="hljs-comment">// 考虑v-if</span>    [<span class="hljs-built_in">this</span>.depIds,<span class="hljs-built_in">this</span>.newDepIds]=[<span class="hljs-built_in">this</span>.newDepIds,<span class="hljs-built_in">this</span>.depIds]    <span class="hljs-built_in">this</span>.newDepIds.clear()    [<span class="hljs-built_in">this</span>.deps,<span class="hljs-built_in">this</span>.newDeps] = [<span class="hljs-built_in">this</span>.newDeps,<span class="hljs-built_in">this</span>.deps]    <span class="hljs-built_in">this</span>.newDeps.length = <span class="hljs-number">0</span>  &#125;🔥  update () &#123;    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.lazy) &#123;      <span class="hljs-built_in">this</span>.dirty = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sync) &#123;      <span class="hljs-comment">// 同步立即run</span>      <span class="hljs-built_in">this</span>.run();    &#125; <span class="hljs-keyword">else</span> &#123;🔥    queueWatcher(<span class="hljs-built_in">this</span>);    &#125;  &#125;  <span class="hljs-comment">// ...</span>&#125;</code></pre></div><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a><code>Dep</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;  <span class="hljs-keyword">static</span> target: ?Watcher;  id: number;  subs: <span class="hljs-built_in">Array</span>&lt;Watcher&gt;;  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-built_in">this</span>.id = uid++    <span class="hljs-built_in">this</span>.subs = []  &#125; <span class="hljs-comment">// 将watcher加入subs</span>  addSub (sub: Watcher) &#123;    <span class="hljs-built_in">this</span>.subs.push(sub)  &#125;⭐️  removeSub (sub: Watcher) &#123;    remove(<span class="hljs-built_in">this</span>.subs, sub)  &#125;⭐️   depend () &#123;    <span class="hljs-keyword">if</span> (Dep.target) &#123; <span class="hljs-comment">// 执行当前watcher中的addDep函数</span>      Dep.target.addDep(<span class="hljs-built_in">this</span>)    &#125;  &#125;🔥  notify () &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;      subs[i].update()    &#125;  &#125;&#125;⭐️ <span class="hljs-comment">// target置空</span>Dep.target = <span class="hljs-literal">null</span><span class="hljs-keyword">const</span> targetStack = []⭐️ <span class="hljs-comment">// 将Dep.target 指向当前watcher</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushTarget</span> (<span class="hljs-params">_target: ?Watcher</span>) </span>&#123;  <span class="hljs-keyword">if</span> (Dep.target) targetStack.push(Dep.target)  Dep.target = _target&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popTarget</span> (<span class="hljs-params"></span>) </span>&#123;  Dep.target = targetStack.pop()&#125;</code></pre></div><h2 id="⭐️-收集依赖-⭐️"><a href="#⭐️-收集依赖-⭐️" class="headerlink" title="⭐️ 收集依赖 ⭐️"></a>⭐️ 收集依赖 ⭐️</h2><ol><li>实例 initState 阶段为 data 数据添加 getter,setter 绑定,并为每个数据生成一个<code>Dep</code>实例</li><li>mountComponent 执行过程中，组件实例化一个渲染<code>Watcher</code>，并指定为<code>Dep.target</code></li><li><code>render</code>函数执行访问数据触发数据的 getter，将当前组件渲染<code>Watcher</code>添加到该数据持有的<code>Dep.subs</code>数组中</li><li>同时渲染<code>Watcher</code>也有一个<code>deps</code>数组保存自己订阅了谁，这样做的意义是在下次<code>Watcher.update</code>时将不再显示页面上的数据绑定移除(对比新旧<code>deps</code>数组)<blockquote><p>可以理解成 data 数据的 subs 数组中每个 watcher 即代表一个受该数据响应式影响的组件实例</p></blockquote></li></ol><h2 id="🔥-派发更新-🔥"><a href="#🔥-派发更新-🔥" class="headerlink" title="🔥 派发更新 🔥"></a>🔥 派发更新 🔥</h2><ol><li>修改数据触发 setter，执行该数据持有的<code>Dep.notify</code>方法</li><li>遍历当前数据<code>Dep.subs</code>中的每一个<code>Watcher</code>，执行其<code>Watcher.update()</code></li><li>vue 不会每次数据更新就立刻去更新视图，而是用队列管理这些回调任务<code>queueWatcher</code></li><li>队列会判断 watcher 是否重复，并且进行排序【先父后子】【自定义 watcher&gt;渲染 watcher】</li><li>在下一个 tick 执行这个队列的回调<code>updateComponent</code>函数，<code>patch</code>实例</li></ol><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><code>nextTick</code></h1><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> callbacks = []<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushCallbacks</span> (<span class="hljs-params"></span>) </span>&#123;  pending = <span class="hljs-literal">false</span>  <span class="hljs-keyword">const</span> copies = callbacks.slice(<span class="hljs-number">0</span>)  callbacks.length = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; copies.length; i++) &#123;    copies[i]()  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTick</span> (<span class="hljs-params">cb?: <span class="hljs-built_in">Function</span>, ctx?: <span class="hljs-built_in">Object</span></span>) </span>&#123;  <span class="hljs-keyword">let</span> _resolve  callbacks.push(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cb) &#123;      <span class="hljs-keyword">try</span> &#123;        cb.call(ctx)      &#125; <span class="hljs-keyword">catch</span> (e) &#123;        handleError(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>)      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;      _resolve(ctx)    &#125;  &#125;)  <span class="hljs-keyword">if</span> (!pending) &#123;    pending = <span class="hljs-literal">true</span>⭐️    timerFunc() <span class="hljs-comment">// &lt;---------------</span>  &#125;&#125;<span class="hljs-comment">// promise</span>timerFunc = <span class="hljs-function">() =&gt;</span> &#123;p.then(flushCallbacks);&#125;;<span class="hljs-comment">// MutationObserver</span><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks);<span class="hljs-keyword">const</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter));observer.observe(textNode, &#123;characterData: <span class="hljs-literal">true</span>,&#125;);timerFunc = <span class="hljs-function">() =&gt;</span> &#123;counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;textNode.data = <span class="hljs-built_in">String</span>(counter);&#125;;<span class="hljs-comment">// setImmediate</span>timerFunc = <span class="hljs-function">() =&gt;</span> &#123;setImmediate(flushCallbacks);&#125;;<span class="hljs-comment">// setTimeout</span>timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>);&#125;;</code></pre></div><p>派发更新时<code>queueWatcher</code>使用<code>nextTick()</code>来执行<code>watcher</code>队列,则手动调用<code>nextTick()</code>也会将自己的cb加入callbacks数组中,<code>timerFunc</code>执行时我们的cb是在所有watcher执行完后执行的,所以拿到了最新的DOM</p><h1 id="组件生命周期关系"><a href="#组件生命周期关系" class="headerlink" title="组件生命周期关系"></a>组件生命周期关系</h1><ul><li>  组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</li><li>  组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</li></ul><h3 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h3><p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount- &gt;子 mounted-&gt;父 mounted</p><h3 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h3><p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p><h1 id="计算属性和侦听属性"><a href="#计算属性和侦听属性" class="headerlink" title="计算属性和侦听属性"></a>计算属性和侦听属性</h1><h2 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a><code>Computed</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">initComputed (vm: Component, <span class="hljs-attr">computed</span>: <span class="hljs-built_in">Object</span>) &#123;  <span class="hljs-keyword">const</span> watchers = vm._computedWatchers = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)  <span class="hljs-keyword">const</span> isSSR = isServerRendering()  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;    <span class="hljs-keyword">const</span> userDef = computed[key]    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.get    ...⭐️<span class="hljs-number">1</span>      watchers[key] = <span class="hljs-keyword">new</span> Watcher(        vm,        getter || noop,        noop,        &#123; <span class="hljs-attr">computed</span>: <span class="hljs-literal">true</span> &#125;      )    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;⭐️<span class="hljs-number">2</span>      defineComputed(vm, key, userDef)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;      <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> vm.$data) &#123;        <span class="hljs-comment">// ... key名称被data或者prop占用的警告</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript">createComputedGetter (key) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computedGetter</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> watcher = <span class="hljs-built_in">this</span>._computedWatchers &amp;&amp; <span class="hljs-built_in">this</span>._computedWatchers[key]    <span class="hljs-keyword">if</span> (watcher) &#123;⭐️<span class="hljs-number">2</span>      watcher.depend()      <span class="hljs-keyword">return</span> watcher.evaluate()    &#125;  &#125;&#125;</code></pre></div><ol><li>实例 initState 阶段遍历 Computed 内的 key，为每个 key 创建 computed watcher</li><li>利用 Object.defineProperty 给 key 值添加 getter</li><li>渲染函数访问到 computed 内的属性时候触发 getter，生成一个 Dep 实例，并且此时 Dep.target 是渲染 watcher，渲染 watcher 就订阅了这个 key 的变化</li><li>执行这个 compute key 的计算逻辑，访问依赖的数据会触发其中响应式数据的 getter，则 computed watcher 也就订阅了 data 的变化，最后也返回计算值并缓存起来</li><li>当依赖的响应式数据变化时，响应的 computed watcher 会收到通知</li><li>computed watcher 会重新求值，比较两次运算结果，结果改变时才会通知渲染 watcher 更新</li></ol><h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a><code>Watch</code></h2><ul><li>  deep</li><li>  immediate</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">initWatch (vm: Component, <span class="hljs-attr">watch</span>: <span class="hljs-built_in">Object</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> watch) &#123;    <span class="hljs-keyword">const</span> handler = watch[key]    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(handler)) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; handler.length; i++) &#123;        <span class="hljs-comment">// 遍历handlers</span>        createWatcher(vm, key, handler[i])      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      createWatcher(vm, key, handler)    &#125;  &#125;&#125;</code></pre></div><ol><li>遍历 Watch 内的 key</li><li>遍历每一个 handler，为每一个 handler 创建 user watcher</li><li>user watcher 会被添加进订阅响应数据的 subs 数组完成订阅</li><li>响应式数据的变化会通知到 user watcher</li><li>渲染函数如果访问这个 watch 属性，也同理会被推入该 watch 属性的 subs 数组,订阅其变化</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3proxy</title>
    <link href="/2022/02/24/vue3/"/>
    <url>/2022/02/24/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE冲冲冲"><a href="#VUE冲冲冲" class="headerlink" title="VUE冲冲冲"></a>VUE冲冲冲</h1><h2 id="代替defineProperty的Proxy"><a href="#代替defineProperty的Proxy" class="headerlink" title="代替defineProperty的Proxy"></a>代替defineProperty的Proxy</h2><h3 id="vue2-X存在的缺陷"><a href="#vue2-X存在的缺陷" class="headerlink" title="vue2.X存在的缺陷"></a>vue2.X存在的缺陷</h3><ul><li><p>无法检测对象中 <code>property</code> 的添加或移除</p></li><li><p>通过下标操作数组，例如：<code>vm.items[indexOfItem] = newValue （性能考虑放弃）</code></p></li><li><p>修改数组的长度时，例如：<code>vm.items.length = newLength</code></p></li><li><p>变通</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Object新增元素</span>Vue.set(object, propertyName, value)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.someObject,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">// 下标修改数组</span>Vue.set(vm.array1, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.$set(<span class="hljs-built_in">this</span>.array1, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-built_in">this</span>.array1.splice(indexOfItem, <span class="hljs-number">1</span>, newValue)<span class="hljs-comment">// 修改数组长度</span><span class="hljs-built_in">this</span>.array1.splice(newLength)</code></pre></div></li><li><p>包裹数组部分方法以支持响应式</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">pop()push()shift()unshift()splice()sort()reverse()</code></pre></div><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a><code>defineProperty</code></h3></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(obj<span class="hljs-comment">/* 对象*/</span>, prop<span class="hljs-comment">/* 属性*/</span>, descriptor<span class="hljs-comment">/*描述符*/</span>)&#123;  <span class="hljs-comment">//对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。</span>  <span class="hljs-comment">//数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。</span>  <span class="hljs-comment">//存取描述符是由 getter 函数和 setter 函数所描述的属性。</span>  <span class="hljs-comment">//一个描述符只能是这两者其中之一；不能同时是两者。</span>  configurable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。</span>  enumerable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。</span>  value: <span class="hljs-literal">true</span>,  writable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//当 writable 属性设置为 false 时，该属性被称为“不可写的”。它不能被重新赋值。</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// 或者</span>  <span class="hljs-comment">//</span>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123; ... &#125;,  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123; ... &#125;,  enumerable : <span class="hljs-literal">true</span>,  configurable : <span class="hljs-literal">true</span>&#125;</code></pre></div><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>兼容<code>IE9</code></li><li>劫持了对象上的<code>属性</code></li><li>数据结构越复杂初始性能会越差,需要递归遍历绑定<code>defineProperty</code></li><li>为保持响应式还需要为新增数据再次绑定<code>defineProperty</code></li><li>原数据的修改触发拦截器</li></ol><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><code>proxy</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)handler.getPrototypeOf()<span class="hljs-comment">//Object.getPrototypeOf 方法的捕捉器。</span>handler.setPrototypeOf()<span class="hljs-comment">//Object.setPrototypeOf 方法的捕捉器。</span>handler.isExtensible()<span class="hljs-comment">//Object.isExtensible 方法的捕捉器。</span>handler.preventExtensions()<span class="hljs-comment">//Object.preventExtensions 方法的捕捉器。</span>handler.getOwnPropertyDescriptor()<span class="hljs-comment">//Object.getOwnPropertyDescriptor 方法的捕捉器。</span>handler.defineProperty()<span class="hljs-comment">//Object.defineProperty 方法的捕捉器。</span>handler.has()<span class="hljs-comment">//in 操作符的捕捉器。</span>handler.get()<span class="hljs-comment">//属性读取操作的捕捉器。</span>handler.set()<span class="hljs-comment">//属性设置操作的捕捉器。</span>handler.deleteProperty()<span class="hljs-comment">//delete 操作符的捕捉器。</span>handler.ownKeys()<span class="hljs-comment">//Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</span>handler.apply()<span class="hljs-comment">//函数调用操作的捕捉器。</span>handler.construct()<span class="hljs-comment">//new 操作符的捕捉器。</span></code></pre></div><ol><li>不兼容<code>IE</code></li><li>劫持<code>整个对象</code>，无需对对象本体作出修改</li><li>拦截器响应的是<code>proxy</code>生成的代理对象，原数据的修改将不会触发拦截器</li><li>拦截器种类繁多</li></ol><h2 id="简单实现reactive"><a href="#简单实现reactive" class="headerlink" title="简单实现reactive"></a>简单实现reactive</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// monkeyVersionReactivity.js猴版响应式框架</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();<span class="hljs-keyword">const</span> effectStack = [];<span class="hljs-keyword">const</span> isObject = <span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">const</span> baseHandler = &#123;  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target, key</span>)</span> &#123;    <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">Reflect</span>.get(target, key);    track(target, key);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&quot;object&quot;</span>) &#123;      <span class="hljs-keyword">return</span> reactive(ret);    &#125;    <span class="hljs-keyword">return</span> ret;  &#125;,  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, key, val</span>)</span> &#123;    <span class="hljs-built_in">Reflect</span>.set(target, key, val);    trigger(target, key, val);  &#125;,&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">track</span>(<span class="hljs-params">target, key</span>) </span>&#123;  <span class="hljs-keyword">let</span> activeEffect = effectStack[effectStack.length - <span class="hljs-number">1</span>];  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">let</span> depsMap = targetMap.get(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    targetMap.set(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()));  &#125;  <span class="hljs-keyword">let</span> dep = depsMap.get(key);  <span class="hljs-keyword">if</span> (!dep) &#123;    depsMap.set(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()));  &#125;  <span class="hljs-keyword">if</span> (!dep.has(activeEffect)) &#123;    dep.add(activeEffect);    <span class="hljs-comment">// TODO</span>    activeEffect.deps.push(dep);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trigger</span>(<span class="hljs-params">target, key, val</span>) </span>&#123;  <span class="hljs-keyword">const</span> depsMap = targetMap.get(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    <span class="hljs-comment">// never been tracked</span>    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">const</span> effects = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();  <span class="hljs-keyword">if</span> (key) &#123;    <span class="hljs-keyword">const</span> dep = depsMap.get(key);    dep.forEach(<span class="hljs-function">(<span class="hljs-params">effect</span>) =&gt;</span> &#123;      effects.add(effect);    &#125;);  &#125;  effects.forEach(<span class="hljs-function">(<span class="hljs-params">ef</span>) =&gt;</span> ef());&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createReactiveEffect</span>(<span class="hljs-params">fn,options</span>)</span>&#123;  <span class="hljs-keyword">const</span> effect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveEffect</span>(<span class="hljs-params"></span>)</span>&#123;      <span class="hljs-keyword">try</span> &#123;        effectStack.push(effect)        <span class="hljs-keyword">return</span> fn()      &#125; <span class="hljs-keyword">finally</span> &#123;        effectStack.pop()      &#125;  &#125;  effect.deps = []  effect.options = options  <span class="hljs-keyword">return</span> effect&#125;<span class="hljs-comment">// ---------</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span>(<span class="hljs-params">target</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, baseHandler);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">effect</span>(<span class="hljs-params">fn, options=&#123;&#125;</span>) </span>&#123;  <span class="hljs-keyword">const</span> effect = createReactiveEffect(fn, options);  <span class="hljs-keyword">if</span> (!options.lazy) &#123;    effect();  &#125;  <span class="hljs-keyword">return</span> effect;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computed</span>(<span class="hljs-params">fn</span>)</span>&#123;  <span class="hljs-keyword">const</span> runner = effect(fn,&#123;<span class="hljs-attr">computed</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">lazy</span>:<span class="hljs-literal">true</span>&#125;)  <span class="hljs-keyword">return</span> &#123;    effect:runner,    <span class="hljs-keyword">get</span> <span class="hljs-title">val</span>()&#123;      <span class="hljs-keyword">return</span> runner()    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue组件之间通信方式</title>
    <link href="/2022/02/24/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/02/24/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="ref和-refs"><a href="#ref和-refs" class="headerlink" title="ref和$refs"></a><code>ref和$refs</code></h3><ul><li><p><code>ref</code>挂载在普通HTML组件上访问它得到DOM</p></li><li><p><code>ref</code>挂载在VUE组件上访问它得到组件实例</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;usernameInput&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$refs.usernameInput</code></pre></div><h3 id="emit和prop"><a href="#emit和prop" class="headerlink" title="$emit和prop"></a><code>$emit</code>和<code>prop</code></h3><ul><li>子组件<code>props</code>接收父组件传递的数据</li><li>动态数据加冒号<code>:</code></li><li>子组件可对收到的<code>props</code>设置校验</li><li>子组件定义<code>$emit</code>自定义方法<br><code>this.$emit(&#39;childToParentMsg&#39;,this.childInfo,this.type)</code></li><li>父组件就可以<code>v-on</code>监听该方法</li><li>该方法绑定父组件的<code>methods</code></li><li>获得方法中传递的参数</li></ul><h3 id="parent和-children"><a href="#parent和-children" class="headerlink" title="$parent和$children"></a><code>$parent</code>和<code>$children</code></h3><ul><li>$parent得到  <strong>对象</strong></li><li>$children得到子组件实例对象 <strong>数组</strong></li></ul><h3 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a><code>provide</code>和<code>inject</code></h3><ul><li><p>父组件向<code>任意深度</code>子组件传值</p></li><li><p>父组件中通过<code>provide</code>来提供变量</p></li><li><p>子组件中通过<code>inject</code>来注入变量</p></li><li><p>不论子组件有多深，只要调用了<code>inject</code>那么就可以注入<code>provider</code>中的数据。只要在父组件的生命周期内，子组件都可以调用。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">Vue.component(<span class="hljs-string">&#x27;child&#x27;</span>,&#123;    <span class="hljs-comment">// </span>    inject:[<span class="hljs-string">&#x27;for&#x27;</span>],      <span class="xml">&lt;------------------将for变量插入本实例</span><span class="xml">    data()&#123;</span><span class="xml">        return &#123;</span><span class="xml">            mymessage:this.for</span><span class="xml">        &#125;</span><span class="xml">    &#125;</span><span class="xml">&#125;)</span><span class="xml">Vue.component(&#x27;parent&#x27;,&#123;</span>    provide:&#123;    &lt;---------------------------提供了for变量        for:&#x27;test&#x27;    &#125;&#125;)</code></pre></div></li></ul><h3 id="attrs-amp-amp-listeners"><a href="#attrs-amp-amp-listeners" class="headerlink" title="$attrs &amp;&amp; $listeners"></a><code>$attrs</code> &amp;&amp; <code>$listeners</code></h3><ul><li><p><code>$attrs</code>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外),通过<code>v-bind=&quot;$attrs&quot;</code> 传入内部组件</p></li><li><p><code>$listeners</code>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// A-&gt;B-&gt;C</span>  <span class="hljs-comment">// 二级子组件C</span>  Vue.component(<span class="hljs-string">&#x27;C&#x27;</span>,&#123;          template:<span class="hljs-string">`</span><span class="hljs-string">              &lt;div&gt;</span><span class="hljs-string">                  &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt; &lt;/div&gt;</span><span class="hljs-string">          `</span>,          methods:&#123;              <span class="hljs-function"><span class="hljs-title">passCData</span>(<span class="hljs-params">val</span>)</span>&#123;                  <span class="hljs-comment">//触发父组件A中的事件</span>                  <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;getCData&#x27;</span>,val)              &#125;          &#125;      &#125;)  <span class="hljs-comment">// 一级子组件B</span>  Vue.component(<span class="hljs-string">&#x27;B&#x27;</span>,&#123;      <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;          <span class="hljs-keyword">return</span> &#123;              mymessage:<span class="hljs-built_in">this</span>.message          &#125;      &#125;,      template:<span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; </span><span class="hljs-string">              &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string">      `</span>,      props:[<span class="hljs-string">&#x27;message&#x27;</span>],<span class="hljs-comment">//props中取走了A传下来的一个attr</span>      <span class="hljs-comment">// 另外一个使用:bind=&quot;$attrs&quot;继续向下传递给C</span>      methods:&#123;          <span class="hljs-function"><span class="hljs-title">passData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-comment">//触发父组件中的事件</span>              <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;getChildData&#x27;</span>,val)          &#125;      &#125;  &#125;)  <span class="hljs-comment">// 父组件A</span>  Vue.component(<span class="hljs-string">&#x27;A&#x27;</span>,&#123;      template:<span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;p&gt;this is parent compoent!&lt;/p&gt;</span><span class="hljs-string">              &lt;B :messagec=&quot;messagec&quot; :message=&quot;message&quot; v-on:getCData=&quot;getCData&quot; v-on:getChildData=&quot;getChildData(message)&quot;&gt;&lt;/B&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string">      `</span>,      <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;          <span class="hljs-keyword">return</span> &#123;              message:<span class="hljs-string">&#x27;hello&#x27;</span>,              messagec:<span class="hljs-string">&#x27;hello c&#x27;</span> <span class="hljs-comment">//传递给c组件的数据</span>          &#125;      &#125;,      methods:&#123;          <span class="hljs-function"><span class="hljs-title">getChildData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是来自B组件的数据&#x27;</span>)          &#125;,          <span class="hljs-comment">//执行C子组件触发的事件</span>          <span class="hljs-function"><span class="hljs-title">getCData</span>(<span class="hljs-params">val</span>)</span>&#123;              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;这是来自C组件的数据：&quot;</span>+val)          &#125;      &#125;  &#125;)</code></pre></div></li></ul><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> EventBus  = <span class="hljs-keyword">new</span> Vue()<span class="hljs-comment">// componentA</span><span class="hljs-keyword">import</span> EventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;eventBus.js&#x27;</span>methods:&#123;    <span class="hljs-function"><span class="hljs-title">someFunc</span>(<span class="hljs-params"></span>)</span>&#123;        EventBus.$emit(<span class="hljs-string">&#x27;funcName&#x27;</span>,&#123;            <span class="hljs-comment">//props</span>        &#125;)    &#125;&#125;<span class="hljs-comment">// componentsB</span><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span>&#123;    EventBus.$on(<span class="hljs-string">&#x27;funcName&#x27;</span>,<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;        <span class="hljs-comment">//params取得传过来的参数</span>    &#125;)&#125;</code></pre></div><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue的diff算法</title>
    <link href="/2022/02/24/vue_diff%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/24/vue_diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>diff算法，包含渲染器如何对各种类型的vNode的属性，text，fragment进行patch更新，以及判断是patch vNode，还是新增还是删除</li><li>采用同级比较</li></ul><h3 id="基础的diff"><a href="#基础的diff" class="headerlink" title="基础的diff"></a>基础的diff</h3><ul><li>新节点没有子节点-&gt;删除全部旧的子节点</li><li>新节点只有一个子节点-&gt;删除旧的并添加新的</li></ul><h3 id="核心diff"><a href="#核心diff" class="headerlink" title="核心diff"></a>核心diff</h3><ul><li>新旧节点都有多个子节点时，新旧子节点间的diff<div class="hljs code-wrapper"><pre><code class="hljs javascript">oldChildrenNode :[a,x,c,f]newChildrenNode :[a,c,f,r]</code></pre></div></li></ul><h4 id="没有key"><a href="#没有key" class="headerlink" title="没有key"></a>没有key</h4><ul><li>就地更新策略</li></ul><p>取出新旧vNode数组中较短的一个为基准长度从头开始进行一对一比较，新的比旧的长则添加新node部分，否则删除旧node部分，这个比较是相同位置就地比较</p><h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4><ul><li>vNode中的唯一标识符</li><li>用于保存新旧vNode的映射关系</li><li>找到可复用的vNode</li><li>用移动节点达到更新目的⭐️</li></ul><h4 id="React-最大递增索引值k"><a href="#React-最大递增索引值k" class="headerlink" title="React 最大递增索引值k"></a>React 最大递增索引值k</h4><ul><li>两次循环，遍历新node去旧node中寻找新vnode位置</li><li>如果索引呈现递增趋势<div class="hljs code-wrapper"><pre><code class="hljs javascript">old: key1 key2 key3<span class="hljs-keyword">new</span>: key1 key2 key3</code></pre></div>（newA-&gt;oldA=&gt;0,newB-&gt;oldB=&gt;1,newC-&gt;oldC=&gt;2）则说明新旧 children 中节点顺序相同，不需要移动操作。相反的，如果在寻找的过程中遇到的索引值不呈现递增趋势，则说明需要移动操作</li><li>如果匹配过程中递增规律被打破</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">old: key2 key3 key1<span class="hljs-keyword">new</span>: key1 key2 key3k = <span class="hljs-number">2</span> 之前的所有节点都需要移动</code></pre></div><p>  <code>k</code>为在旧 children 中所遇到的最大索引值，则后续匹配的索引小于这个值意味着都需要移动</p><h3 id="Vue2的双端比较"><a href="#Vue2的双端比较" class="headerlink" title="Vue2的双端比较"></a>Vue2的双端比较</h3><blockquote><p>借鉴<code>snabbdom.js</code></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript">(oStart)               [oEnd] oldA   oldB   oldC    oldD newB   newC   newD    newA(nStart)               [nEnd]<span class="hljs-comment">// oStart与nEnd匹配上了key，将oldA的DOM移动到新dom最后</span>      (oStart)        [oEnd] oldA   oldB   oldC    oldD ｜  ----------------------&gt;                        ｜ newB   newC   newD    newA(nStart)      [nEnd]</code></pre></div><ul><li><p>vue同时从新旧children的两端开始比较</p></li><li><p>四个指针，分别查找是否key相同</p></li><li><p>匹配到了相同的key，则将真实dom移动,同时四个指针对撞移动</p></li><li><p>如果第一轮四次匹配不上，则遍历旧node寻找<code>nStart</code></p></li><li><p>if 找到将其真实DOM移动到<code>oStart</code>之前，并在原vnode位置置空undefined，后序比较会跳过他</p></li><li><p>else 找不到则添加新增新元素<code>nStart</code>到<code>oStart</code>之前</p></li><li><p>匹配结束后<code>oEnd&lt;oStart</code>,新增<code>nStart到nEnd</code>新元素到<code>oStart</code>之前</p></li><li><p>匹配结束后<code>nStart&gt;nEnd</code>,删除<code>oStart到oEnd</code>之间元素</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isUndef</span> (<span class="hljs-params">v</span>) </span>&#123;  <span class="hljs-keyword">return</span> v === <span class="hljs-literal">undefined</span> || v === <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDef</span> (<span class="hljs-params">v</span>) </span>&#123;  <span class="hljs-keyword">return</span> v !== <span class="hljs-literal">undefined</span> &amp;&amp; v !== <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameVnode</span> (<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    a.key === b.key &amp;&amp; (      (        a.tag === b.tag &amp;&amp;        a.isComment === b.isComment &amp;&amp;        isDef(a.data) === isDef(b.data) &amp;&amp;        !childrenIgnored(a) &amp;&amp; !childrenIgnored(b) &amp;&amp;        sameInputType(a, b)      ) || (        isTrue(a.isAsyncPlaceholder) &amp;&amp;        a.asyncFactory === b.asyncFactory &amp;&amp;        isUndef(b.asyncFactory.error)      )    )  )&#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateChildren</span> (<span class="hljs-params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]    <span class="hljs-keyword">let</span> newEndIdx = newCh.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]    <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;      <span class="hljs-keyword">if</span> (isUndef(oldStartVnode)) &#123;        oldStartVnode = oldCh[++oldStartIdx] <span class="hljs-comment">// Vnode has been moved left</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isUndef(oldEndVnode)) &#123;        oldEndVnode = oldCh[--oldEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)        oldStartVnode = oldCh[++oldStartIdx]        newStartVnode = newCh[++newStartIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)        oldEndVnode = oldCh[--oldEndIdx]        newEndVnode = newCh[--newEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span>      <span class="hljs-comment">// 说明oldStartVnode节点更新后要移动去末尾位置</span>        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))        oldStartVnode = oldCh[++oldStartIdx]        newEndVnode = newCh[--newEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span>      <span class="hljs-comment">// 说明oldEndVnode节点更新后要移动到最前方</span>        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)        oldEndVnode = oldCh[--oldEndIdx]        newStartVnode = newCh[++newStartIdx]      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)        <span class="hljs-comment">// oldKeyToIndex是旧节点的key2index映射map</span>        idxInOld = isDef(newStartVnode.key)          ? oldKeyToIdx[newStartVnode.key]          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)          <span class="hljs-comment">// 去旧节点中寻找newStartVnode</span>        <span class="hljs-keyword">if</span> (isUndef(idxInOld)) &#123; <span class="hljs-comment">// 找不到则新增newStartVnode元素到oldStart之前</span>          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="hljs-literal">false</span>, newCh, newStartIdx)        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 找得到则进行移动</span>          vnodeToMove = oldCh[idxInOld]          <span class="hljs-keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)            oldCh[idxInOld] = <span class="hljs-literal">undefined</span>            <span class="hljs-comment">// 将旧节点中匹配到的位置置空，以后的查找会跳过</span>            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)            <span class="hljs-comment">// 匹配到的节点移动到oldStart之前</span>          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// key相同但不是同一种元素</span>            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="hljs-literal">false</span>, newCh, newStartIdx)          &#125;        &#125;        newStartVnode = newCh[++newStartIdx]      &#125;    &#125;    <span class="hljs-comment">// 跳出匹配后</span>    <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;      refElm = isUndef(newCh[newEndIdx + <span class="hljs-number">1</span>]) ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].elm      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)    &#125;  &#125;</code></pre></div><h3 id="Vue3-借鉴inferno和ivi的算法"><a href="#Vue3-借鉴inferno和ivi的算法" class="headerlink" title="Vue3 借鉴inferno和ivi的算法"></a>Vue3 借鉴<code>inferno</code>和<code>ivi</code>的算法</h3></li><li><p>排除相同的首位节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[j]             [preEnd] |                  | a   e   f  k   b   c |                  |--------------------- |                  | a   f   k  e   b   c |                  |   [j]             [nextEnd]    [j] [preEnd]     |      | a   e   f  k   b   c     |      |---------------------     |      | a   f   k  e   b   c     |      |       [j] [nextEnd]</code></pre></div><ul><li>分别从新旧节点的头和尾出发</li><li>依次遍历到key值不一样时停止 </li><li>这样匹配成功后剩下的部分就是需要新增/删除的vNode们</li></ul></li><li><p>使用剩余新children的长度建立source索引数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">  oldChildren = [e,f,k]  newChildren = [f,k,e]  source = [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]- 为新vnode建立key，index索引表  <span class="hljs-string">``</span><span class="hljs-string">`js</span><span class="hljs-string">  keyIndex = &#123;f:0,k:1,e:2&#125;</span></code></pre></div></li><li><p>遍历旧children中key去keyIndex中查找<code>k = kenIndex[oldChildren[i]]</code>，有这个k则把<code>source</code>数组该位置的-1改为旧vNode的索引，并且patch该节点 ;<code>k=undefined</code>则说明该节点已经被删除，而source中依旧为-1的节点为新增节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">source = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</code></pre></div></li><li><p>判断是否需要移动</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">source = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<span class="hljs-comment">//source中，最大索引为2，2之后有小于2的索引，说明需要移动</span><span class="hljs-comment">//根据source数组求出最长递增子序列</span>LIS = [<span class="hljs-number">1</span>，<span class="hljs-number">2</span>]<span class="hljs-comment">// LIS中存储的是source索引</span><span class="hljs-comment">// 表示新旧children中这几个节点位置保持递增关系</span></code></pre></div></li><li><p>根据LIS得出不进行移动的节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">newChildren[LIS] = [f,k]</code></pre></div></li><li><p>从LIS和新children尾处建立两个指针处理余下节点</p></li><li><p>比较指针的索引是是否相同，不同则移动DOM位置到上个指针的真实DOM之前</p><blockquote><p>oldVnode.el = 真实DOM，同时source.key = -1的节点直接创建了新的真实DOM</p></blockquote></li></ul><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><ul><li>子序列：不要求连续</li><li>字串：要求连续</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">const</span> longestChildSequence = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> dp = <span class="hljs-built_in">Array</span>(len).fill(<span class="hljs-number">1</span>)  <span class="hljs-comment">// dp[i]代表原始数组该位置的最长子序列长度</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;      <span class="hljs-comment">// j遍历之前遍历过的所有元素</span>      <span class="hljs-comment">// 可能存在大小不一的递增序列，使用max取得最大值</span>      <span class="hljs-keyword">if</span>(arr[i] &gt; arr [j])&#123;        dp[i] = <span class="hljs-built_in">Math</span>.max(dp[i],dp[j]+<span class="hljs-number">1</span>)        <span class="hljs-comment">// [1,2,3,4,1,2,5]</span>        <span class="hljs-comment">// 如果只使用dp[j]+1 ，dp[6]会在[1,2,5]中得出结果3</span>        <span class="hljs-comment">// 使用max比较之前更长的序列[1，2，3，4，5]得到5</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(...dp)&#125;<span class="hljs-comment">// 贪心+二分</span><span class="hljs-keyword">const</span> longestChildSequence = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> len = arr.length  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> res = [arr[<span class="hljs-number">0</span>]]  <span class="hljs-comment">//将arr中后续元素arr[i]与res末尾元素比较</span>  <span class="hljs-comment">//大于则push进res</span>  <span class="hljs-comment">//小于则查找res中第一个比arr[i]大的元素并替换</span>  <span class="hljs-comment">//由于存在替换，子序列值不一定正确，但长度是正确的</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt; len ;i++)&#123;    <span class="hljs-keyword">if</span>(arr[i]&gt;res[res.length-<span class="hljs-number">1</span>])&#123;      res.push(arr[i])    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// res中左右指针的index</span>      <span class="hljs-comment">// 二分查找</span>      <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>      <span class="hljs-keyword">let</span> right = res.length - <span class="hljs-number">1</span>      <span class="hljs-keyword">while</span>(left&lt;right)&#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((left+right)/<span class="hljs-number">2</span>)        <span class="hljs-comment">// let mid = ((left+right)/2) | 0</span>        <span class="hljs-comment">// 浮点小数向下求整</span>        <span class="hljs-keyword">if</span>(arr[i]&gt;res[mid])&#123;          left = mid + <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;          right = mid        &#125;      &#125;      res[left] = arr[i]    &#125;  &#125;  <span class="hljs-keyword">return</span> res.length &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/02/24/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/02/24/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h2><ul><li><p>  节点不能闭环</p></li><li><p>  只有一个根节点</p></li><li><p>  除了根节点，每个节点有且只有一个父节点</p></li><li><p>  深度：节点到根节点的最长路径经过节点个数</p></li><li><p>  高度：节点到叶节点最长路径经过节点个数</p></li><li><p>  树的高度：根节点到叶节点的最长路径经过节点个数</p></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>最多只有两个子节点的树结构</p><p>二叉树是 n 个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>任意节点的左右子树高度差不大于 1</p><h4 id="满二叉树：每一层节点数都达到最大值"><a href="#满二叉树：每一层节点数都达到最大值" class="headerlink" title="满二叉树：每一层节点数都达到最大值"></a>满二叉树：每一层节点数都达到最大值</h4><ul><li>  一个层数为 k 的满二叉树总结点数为：2^k-1</li><li>  第 i 层上的结点数为：2^(i-1)</li><li>  一个层数为 k 的满二叉树的叶子结点个数（也就是最后一层）：2^(k-1)</li></ul><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为 k 的, 有 n 个结点的二叉树, 当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应时, 称之为完全二叉树。</p><h4 id="二叉搜索树【BST】：右子大于父大于左子"><a href="#二叉搜索树【BST】：右子大于父大于左子" class="headerlink" title="二叉搜索树【BST】：右子大于父大于左子"></a>二叉搜索树【BST】：右子大于父大于左子</h4><blockquote><p>二叉搜索树的中序遍历得到升序排列</p></blockquote><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BinaryTree</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<span class="hljs-built_in">this</span>.val = val;<span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;<span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;&#125;;<span class="hljs-keyword">let</span> root = <span class="hljs-literal">null</span>;&#125;</code></pre></div><ul><li>前序遍历<blockquote><p>root -&gt; left -&gt; right</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preOrderTraverse</span>(<span class="hljs-params">node</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> stack = [node];<span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">let</span> curNode = stack.pop();res.push(curNode.val);curNode.left &amp;&amp; stack.push(curNode.left);curNode.right &amp;&amp; stack.push(curNode.right);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>中序遍历<blockquote><p>left -&gt; root -&gt; right</p></blockquote></li><li>后序遍历<blockquote><p>left -&gt; right -&gt; root</p></blockquote></li></ul><h2 id="二叉树算法题"><a href="#二叉树算法题" class="headerlink" title="二叉树算法题"></a>二叉树算法题</h2><ul><li>  计算路径</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pathSum</span>(<span class="hljs-params">root, sum</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">if</span> (root.value === sum) <span class="hljs-keyword">return</span> [root.value];<span class="hljs-keyword">const</span> paths = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">searchPath</span>(<span class="hljs-params">node, target, prePath</span>) </span>&#123;<span class="hljs-keyword">const</span> target = sum - node.val;<span class="hljs-keyword">const</span> curPath = [...prePath, node.val];<span class="hljs-keyword">if</span> (!node.left &amp;&amp; !node.right &amp;&amp; target === <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 一直要到叶子结点</span>paths.push(curPath);<span class="hljs-keyword">return</span>;&#125;node.left &amp;&amp; searchPath(node.left, target, curPath);node.right &amp;&amp; searchPath(node.right, target, curPath);&#125;searchPath(root, sum, []);<span class="hljs-keyword">return</span> paths;&#125;</code></pre></div><ul><li>  二叉树镜像 / 翻转二叉树</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mirror</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>    [node.left,node.right] = [node.right,node.left]    mirror(node.left)    mirror(node.right)  &#125;  mirror(root）  <span class="hljs-keyword">return</span> root&#125;<span class="hljs-comment">// stack</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mirrorTree</span>(<span class="hljs-params">root</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root  <span class="hljs-keyword">const</span> swap = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> [node.left,node.right] = [node.right,node.left]  <span class="hljs-keyword">const</span> stack = [root]  <span class="hljs-keyword">while</span>(stack.length&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">const</span> node = stack.pop()    swap(node)    node.left &amp;&amp; stack.push(node.left)    node.right &amp;&amp; stack.push(node.right)  &#125;  <span class="hljs-keyword">return</span> root&#125;</code></pre></div><ul><li>  计算二叉树的最大深度</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">val</span>) </span>&#123;<span class="hljs-built_in">this</span>.val = val;<span class="hljs-built_in">this</span>.left = <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 后序遍历</span><span class="hljs-comment">// DFS</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">return</span> root ? <span class="hljs-built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">// 递归深度加1</span><span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> left = maxDepth(root.left);<span class="hljs-keyword">const</span> right = maxDepth(root.right);<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// BFS</span><span class="hljs-comment">//递归实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> max;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BFS</span>(<span class="hljs-params">node, dep</span>) </span>&#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;max = <span class="hljs-built_in">Math</span>.max(max, ++dep);BFS(node.left, dep);BFS(node.right, dep);&#125;BFS(root, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> max;&#125;<span class="hljs-comment">// 栈实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxDepth</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">0</span>]];<span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> [node, dep] = stack.pop();max = <span class="hljs-built_in">Math</span>.max(max, dep + <span class="hljs-number">1</span>);node.left &amp;&amp; stack.push(node.left, dep + <span class="hljs-number">1</span>);node.right &amp;&amp; stack.push(node.right, dep + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> max;&#125;</code></pre></div><ul><li>二叉搜素树中第 k 大的值<blockquote><p>二叉搜索树 + 逆向中序遍历 =&gt; 降序排列 val</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">kthLargest</span>(<span class="hljs-params">root, k</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">let</span> res = root.val;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DFS</span>(<span class="hljs-params">node</span>) </span>&#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;DFS(node.right);<span class="hljs-keyword">if</span> (--k === <span class="hljs-number">0</span>) &#123;res = node.val;<span class="hljs-keyword">return</span>;&#125;DFS(node.right);&#125;DFS(root);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>二叉树的最近公共祖先<br>  对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (root === p || root === q) <span class="hljs-keyword">return</span> root;<span class="hljs-keyword">const</span> l = lowerCommonAncestor(root.left, p, q);<span class="hljs-keyword">const</span> r = lowerCommonAncestor(root.right, p, q);l &amp;&amp; r ? root : l || r;&#125;</code></pre></div><ul><li>二叉搜索树的最近公共祖先<br>  二叉搜索树中 rightTree &gt; root &gt; leftTree</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lowestCommonAncestor</span>(<span class="hljs-params">root, p, q</span>) </span>&#123;<span class="hljs-keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;<span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);&#125;<span class="hljs-keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;<span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);&#125;<span class="hljs-keyword">return</span> root;&#125;</code></pre></div><ul><li>  二叉搜索树节点间最小差</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 中序排列后，最小差就是该数组中相邻元素最小差</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minDiffInBST</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DFS</span>(<span class="hljs-params">node</span>) </span>&#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;DFS(node.left);<span class="hljs-keyword">if</span> (pre === <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// init阶段</span>pre = node.val;&#125; <span class="hljs-keyword">else</span> &#123;min = <span class="hljs-built_in">Math</span>.min(min, node.val - pre);pre = node.val;&#125;<span class="hljs-comment">// 中序列遍历，pre存储上一个值，由于BST特性，cur.val永远大于pre</span>DFS(node.right);&#125;&#125;<span class="hljs-comment">// 使用辅助栈</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minDiffInBST</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER;<span class="hljs-keyword">const</span> stack = [];<span class="hljs-keyword">while</span> (root || stack.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">while</span> (root) &#123;stack.push(root);root = root.left;&#125;<span class="hljs-keyword">const</span> node = stack.pop();<span class="hljs-keyword">if</span> (pre === <span class="hljs-literal">null</span>) &#123;pre = node.val;&#125; <span class="hljs-keyword">else</span> &#123;min = <span class="hljs-built_in">Math</span>.min(min, node.val - pre);pre = node.val;&#125;root = node.right;&#125;<span class="hljs-keyword">return</span> min;&#125;</code></pre></div><ul><li>层序遍历，打印二叉树<br>  [[第一层],[第二层],[第三层]]</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>  <span class="hljs-title">levelOrder</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">0</span>]];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> [node, level] = stack.shift();<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span> (!res[level]) res[level] = [];res[level].push(node.val);node.left &amp;&amp; stack.push([node.left, level + <span class="hljs-number">1</span>]);node.right &amp;&amp; stack.push(node.right, level + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">const</span> levelOrder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">if</span> (root) &#123;<span class="hljs-keyword">while</span> (stack.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> preLevelSize = stack.length;<span class="hljs-keyword">const</span> curLevel = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; preLevelSize; i++) &#123;<span class="hljs-keyword">const</span> n = stack.shift();<span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">break</span>;curLevel.push(n.val);n.left &amp;&amp; stack.push(n.left);n.right &amp;&amp; stack.push(n.right);&#125;res.push(curLevel);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><ul><li>判断平衡二叉树<br>  平衡二叉树，左右子树深度差不大于 1</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBalanced</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">let</span> res = <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">node</span>) </span>&#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> left = dfs(node.left);<span class="hljs-keyword">let</span> right = dfs(node.right);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(left - right) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>;&#125;dfs(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isBalanced</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">node</span>) </span>&#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">const</span> left = dfs(node.left);<span class="hljs-keyword">const</span> right = dfs(node.right);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(left - right) &gt; <span class="hljs-number">1</span> || left === -<span class="hljs-number">1</span> || right === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(left, right) + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> dfs(root) !== -<span class="hljs-number">1</span>;&#125;</code></pre></div><ul><li>  判断对称二叉树</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 对称的二叉树</span><span class="hljs-comment">// l = r</span><span class="hljs-comment">// l.right = r.left &amp;&amp; l.left = r.right</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isMirrorTree</span>(<span class="hljs-params">root</span>) </span>&#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">recur</span>(<span class="hljs-params">l, r</span>) </span>&#123;<span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span> &amp;&amp; r == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span> || r == <span class="hljs-literal">null</span> || l !== r) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> recur(l.left, r.right) &amp;&amp; recur(l.right, l, left);&#125;<span class="hljs-keyword">return</span> recur(root.left, root.right);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端涉及到的数据存储</title>
    <link href="/2022/02/24/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    <url>/2022/02/24/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LocalStorage-h5-web-storage"><a href="#LocalStorage-h5-web-storage" class="headerlink" title="LocalStorage[h5 web storage]"></a><code>LocalStorage</code>[h5 web storage]</h3><ul><li><p>不会过期</p></li><li><p>数据大小5MB</p></li><li><p>同源共享同一份<code>localStorage</code></p></li><li><p>只能为<code>string</code>类型,注意需要<code>JSON</code>转换</p></li></ul><h3 id="SessionStorage-h5-web-storage"><a href="#SessionStorage-h5-web-storage" class="headerlink" title="SessionStorage[h5 web storage]"></a><code>SessionStorage</code>[h5 web storage]</h3><ul><li><p>会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）</p></li><li><p>数据大小5MB</p></li><li><p>不跨窗口共享,就算同一url的多个tab<code>sessionStorage</code>各自独立</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h3></li><li><p>手动设置过期时间，否则浏览器关闭失效</p></li><li><p>数据大小 4KB</p></li><li><p>参与每次http请求</p></li><li><p>有路径概念，可以限制不同路径下的 cookie 互相是访问</p></li><li><p>某些浏览器对单网站cookie数目有限制(不超过20个)</p></li><li><p>cookie字段</p><ul><li><p><code>name</code></p></li><li><p><code>value</code></p></li><li><p><code>domain</code>　        可以访问此cookie的域，默认为该请求源的域</p></li><li><p><code>path</code>　        　 可以访问此cookie的页面路径</p></li><li><p><code>expires / max-age</code> 过期时间，如没设置则与会话时效相同（关闭浏览器窗口失效）</p></li><li><p><code>HttpOnly</code>　      只能传输不能查看</p></li><li><p><code>Secure</code>          只使用HTTPS传输</p></li><li><p><code>sameSite = </code> 防止【XSRF】攻击</p><ul><li><code>Strict</code>  跨域时不允许带上任何cookie</li><li><code>Lax</code>  只有三种情况可以带上cookie[a连接,get提交的表单,预加载link]<blockquote><p>现代浏览器会将没有声明 SameSite 值的 cookie 默认设置为Lax</p></blockquote></li><li><code>None</code> 需配合<code>secure</code>使用用 <code>Set-Cookie: widget_session=xxxxx; SameSite=None; Secure</code></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; HttpOnly<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=Strict<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=Lax<span class="hljs-built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; SameSite=None; Secure</code></pre></div><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a><code>IndexedDB</code></h3></li><li><p>除非被清理否则一直存在</p></li><li><p>数据大小无限制</p></li><li><p>IndexedDB 是一个基于 JavaScript 的面向对象数据库，相比webStorage提供存储大量结构化数据的能力</p></li></ul><h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a><code>manifest</code></h2><p><code>manifest.json</code>在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。</p><p>Web应用程序清单是被称为<code>渐进式Web应用程序(PWA)</code>的Web技术集合的一部分, 它们是可以安装到设备的主屏幕的网络应用程序，而不需要用户通过应用商店，伴随着其他功能, 比如离线可用和接收推送通知。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2022/02/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/02/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h1><h2 id="打包时间"><a href="#打包时间" class="headerlink" title="打包时间"></a>打包时间</h2><ul><li>loader的作用范围<code>include</code>,<code>exclude</code></li><li>模块搜索机制<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  resolve: &#123;    modules: [path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>), <span class="hljs-string">&#x27;node_modules&#x27;</span>], <span class="hljs-comment">// 搜索位置</span>    extensions:[<span class="hljs-string">&quot;.js&quot;</span>,<span class="hljs-string">&quot;.jsx&quot;</span>] <span class="hljs-comment">// 搜索的后缀名,虽然写的时候可以省略,但会增加搜索的性能损耗</span>  &#125;&#125;;</code></pre></div><h2 id="打包量"><a href="#打包量" class="headerlink" title="打包量"></a>打包量</h2></li><li>tree shaking</li></ul><h1 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h1><ul><li><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  chainWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;      config.optimizationsplitChunks(&#123;        chunks: <span class="hljs-string">&#x27;all&#x27;</span>,        cacheGroups: &#123;          vendors: &#123;            name: <span class="hljs-string">&#x27;chunk-vendors&#x27;</span>,            test: <span class="hljs-regexp">/[\\/]node_module[\\/]/</span>,            priority: <span class="hljs-number">10</span>,            chunks: <span class="hljs-string">&#x27;initial&#x27;</span>          &#125;,          echarts: &#123;            name: <span class="hljs-string">&#x27;chunk-echarts&#x27;</span>,            priority: <span class="hljs-number">20</span>,            test: <span class="hljs-regexp">/[\\/]node_module[\\/]_?echarts(.*)/</span>          &#125;        &#125;      &#125;)    &#125;&#125;</code></pre></div></li><li><h3 id="配合拆包的缓存策略"><a href="#配合拆包的缓存策略" class="headerlink" title="配合拆包的缓存策略"></a>配合拆包的缓存策略</h3></li></ul><hr><h1 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h1><ul><li><h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><ol><li><h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> imgList = [...document.querySelectAll(<span class="hljs-string">&#x27;img&#x27;</span>)]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyLoad</span>(<span class="hljs-params">imgList</span>)</span>&#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> len = imgList.length  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> doneList = []    imgList.forEach(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>&#123;      <span class="hljs-keyword">const</span> react = img.getBoundingClientRect()      <span class="hljs-comment">// Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置</span>      <span class="hljs-keyword">if</span>(react.top&lt;<span class="hljs-built_in">window</span>.innerHeight)&#123;        img.src = img.dataset.src  <span class="hljs-comment">// 在这里赋值图片src</span>        doneList.push(index)        count++        <span class="hljs-keyword">if</span>(count === len)&#123;          <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,lazyLoad)        &#125;      &#125;    &#125;)    imgList = imgList.filter(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>!doneList.includes(i))  &#125;&#125;<span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,_.debounce(lazyLoad))<span class="hljs-comment">// 加上节流</span></code></pre></div></li><li><h3 id="精灵图和icon-font"><a href="#精灵图和icon-font" class="headerlink" title="精灵图和icon-font"></a>精灵图和icon-font</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">svg-sprite-loader</code></pre></div></li></ol></li><li><h2 id="请求数量"><a href="#请求数量" class="headerlink" title="请求数量"></a>请求数量</h2><ol><li><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol><li>安装<code>html-webpack-plugin</code></li><li>修改<code>public/index.html</code><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    &lt;meta      name=&quot;viewport&quot;      content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;    /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.css) &#123; %&gt;    &lt;link      href=&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;      rel=&quot;preload&quot;      as=&quot;style&quot;    /&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>      &lt;strong        &gt;We&#x27;re sorry but moviapp doesn&#x27;t work properly without JavaScript        enabled. Please enable it to continue.&lt;/strong      &gt;    <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.js) &#123; %&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li></ol><ul><li>配置<code>vue.config.js</code></li></ul> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 判断生产环境</span><span class="hljs-keyword">const</span> isProduction = process.env.NODE_ENV === <span class="hljs-string">&quot;production&quot;</span>;<span class="hljs-keyword">const</span> cdn = &#123;  <span class="hljs-comment">// 随便抓几个</span>  js: [    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.0/vue.runtime.esm.js&quot;</span>,    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.1.3/vue-router.esm.js&quot;</span>  ],&#125;;<span class="hljs-built_in">module</span>.exports = &#123;  configureWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.externals = &#123;        <span class="hljs-comment">// 排除的依赖，不从bundle中引入的依赖</span>        <span class="hljs-string">&quot;vue&quot;</span>: <span class="hljs-string">&quot;Vue&quot;</span>,        <span class="hljs-string">&quot;vue-router&quot;</span>: <span class="hljs-string">&quot;VueRouter&quot;</span>      &#125;;    &#125;  &#125;,  chainWebpack: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.plugin(<span class="hljs-string">&quot;html&quot;</span>).tap(<span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 传递给 html-webpack-plugin&#x27;s 构造函数的新参数</span>        args[<span class="hljs-number">0</span>].cdn = cdn;        <span class="hljs-keyword">return</span> args;      &#125;);    &#125;  &#125;,&#125;;</code></pre></div></li></ol><ul><li><h3 id="第三方库按需加载"><a href="#第三方库按需加载" class="headerlink" title="第三方库按需加载"></a>第三方库按需加载</h3><ol><li>elementui官网配置方法不适用</li><li>vuecli中babel配置文件为<code>babel.config.js</code></li><li>安装<code>babel-plugin-component</code></li><li>配置<code>babel.config.js</code></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">module</span>.exports = &#123;  presets: [    <span class="hljs-string">&#x27;@vue/cli-plugin-babel/preset&#x27;</span>  ],  plugins: [    [      <span class="hljs-string">&quot;component&quot;</span>,<span class="hljs-comment">// 插件位置</span>      &#123;        <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,        <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span>      &#125;    ]  ]&#125;</code></pre></div><ul><li>修改<code>main.js</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> [MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination,Button]) &#123;  Vue.use(item);&#125;</code></pre></div></li><li>也可以单独独立出自定义组件,二次封装<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// eleui.js</span><span class="hljs-keyword">import</span> &#123; MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;element-ui&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  install : <span class="hljs-function">(<span class="hljs-params">Vue</span>) =&gt;</span> &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> co <span class="hljs-keyword">of</span> [MenuItem,Container,Header,Aside,Main,Input,Footer,Avatar, Menu, Table, TableColumn, Pagination ,Button])&#123;      Vue.use(co)    &#125;  &#125;&#125;<span class="hljs-comment">// main.js</span><span class="hljs-keyword">import</span> eleUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eleUI.js&#x27;</span>Vue.use(eleUI)</code></pre></div></li></ul></li></ul></li></ul><ul><li><h3 id="前端路由懒加载"><a href="#前端路由懒加载" class="headerlink" title="前端路由懒加载"></a>前端路由懒加载</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Router(&#123;  routes: [    &#123;      path: <span class="hljs-string">&#x27;/home&#x27;</span>,      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/home&#x27;</span>),    &#125;,    &#123;      path: <span class="hljs-string">&#x27;/about&#x27;</span>,      component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/home&#x27;</span>),    &#125;,  ],&#125;)</code></pre></div></li></ul><h2 id="资源大小"><a href="#资源大小" class="headerlink" title="资源大小"></a>资源大小</h2><h3 id="代码混淆压缩"><a href="#代码混淆压缩" class="headerlink" title="代码混淆压缩"></a>代码混淆压缩</h3><ul><li>uglyjs<h3 id="服务器gzip"><a href="#服务器gzip" class="headerlink" title="服务器gzip"></a>服务器gzip</h3><h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3></li><li><code>tinify</code></li><li><code>base64</code></li><li><code>webp</code></li></ul><h2 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载"></a>非核心代码异步加载</h2><ul><li><p>异步加载的方式</p><ol><li>动态创建script标签</li><li>script<code>defer</code></li><li>script<code>async</code></li></ol></li><li><p>script/script async/script defer的区别</p><ul><li>普通的<code>script</code>，html解析暂停，立即下载和执行这个脚本</li><li><code>&lt;script async&gt;</code>，html解析和该脚本的加载同时进行，下载完后执行脚本时暂停html解析</li><li><code>&lt;script defer&gt;</code>，html解析和该脚本的加载同时进行，脚本在页面解析完成后才执行—&gt;<code>DOMContentLoaded</code> 之前执行</li></ul><p>  <img src="../images/script.png" alt="script"></p></li></ul><h2 id="预解析DNS"><a href="#预解析DNS" class="headerlink" title="预解析DNS"></a>预解析DNS</h2><p><code>DNS Prefetch</code> 是一种DNS 预解析技术，当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。</p><ol><li><p><code>HTTP</code>中浏览器会对<code>&lt;a&gt;标签</code>自动开启dns预解析</p><blockquote><p>对于https页面，大部分浏览器是关闭a标签的dns预解析的</p></blockquote></li><li><p><code>HTTPS</code>用meta信息来告知浏览器, 当前页面要做DNS预解析:<br><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</code></p></li><li><p>在页面<code>&lt;head&gt;</code>中使用<code>&lt;link&gt;标签</code>来强制对DNS预解析:</p></li></ol><p><code> &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</code></p><h2 id="预渲染和服务端渲染"><a href="#预渲染和服务端渲染" class="headerlink" title="预渲染和服务端渲染"></a>预渲染和服务端渲染</h2><ul><li><code>SSR:server side render</code></li><li><code>prerender-spa-plugin</code>不适用于个性化的，内容变化大，多路由的页面<br>可以用来优化单页应用</li></ul><hr><h1 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h1><ol><li>DOM样式通过class修改</li><li>DOM离线后修改（<code>display:none</code>,<code>Document Fragment</code>）或者使用虚拟DOM</li><li>减少获取DOM样式属性像offsetHeight（导致立即重排），和加入循环。。。</li><li>避免table布局</li><li>合理使用GPU加速<ul><li> <code>translate</code>代替修改几何信息<code>left,top...</code></li><li> <code>opacity</code>代替<code>visibility</code></li><li> 复杂动画元素脱离文档流<code>position:absolute/fixed</code></li><li> 加上<code>will-change</code>属性</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web安全</title>
    <link href="/2022/02/24/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <url>/2022/02/24/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>两个URl <strong>!同协议 !同域名 !同端口</strong></li><li>同源策略限制了同一个源加载的脚本和文档如何与其他源的资源进行交互，包括js脚本，缓存的读取，cookie，ajax等</li><li>三种标签不受同源限制<code>script</code> <code>link</code> <code>img</code></li></ul><h3 id="跨域的方法"><a href="#跨域的方法" class="headerlink" title="跨域的方法"></a>跨域的方法</h3><ul><li><p>代理服务器<code>nginx,各种devServer</code></p></li><li><p><code>document.domain</code></p><p>前提是两个页面主要域相同</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;someWebSite.com/dir1/pageA.html&#x27;</span><span class="hljs-string">&#x27;someWebSite.com/dir2/pageB.html&#x27;</span>都设置<span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;someWebSite.com&#x27;</span>则他们之间通信将通过同源检测，并都访问父源的cookie</code></pre></div></li><li><p><code>window.name</code>  </p></li><li><p><code>postMessage</code></p><p>对新打开的窗口或者iframe的contentWindow属性、执行window.open返回的窗口对象</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-comment">// pageA中代码</span><span class="hljs-built_in">window</span>.iframe[i].postMessage(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;pageB的URL&#x27;</span>)<span class="hljs-comment">// pageB中的代码</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(e.data)     <span class="hljs-comment">// data</span>    <span class="hljs-built_in">console</span>.log(e.source)   <span class="hljs-comment">// a中window的引用</span>    <span class="hljs-built_in">console</span>.log(e.origin)  <span class="hljs-comment">// pageA的URL</span>&#125;,<span class="hljs-literal">false</span>)<span class="hljs-comment">// 反过来pageB向pageA发送数据</span><span class="hljs-comment">// 在pageA中加入window.addEventListener</span><span class="hljs-comment">// 在pageB中e.source.postMessage</span></code></pre></div></li><li><p><code>iframe</code>+<code>hash</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-keyword">var</span> B = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&quot;iframe&quot;</span>);B.src = B.src + <span class="hljs-string">&quot;#&quot;</span> + <span class="hljs-string">&quot;data&quot;</span>;<span class="hljs-comment">// pageB中的代码</span><span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;data = <span class="hljs-built_in">window</span>.location.hash; <span class="hljs-comment">//  &lt;-  pageB就获取到了hash值</span>&#125;;</code></pre></div></li><li><p><code>jsonp</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) </span>&#123;  <span class="hljs-keyword">const</span> attrs = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(params))&#123;    attrs.push(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>)  &#125;  attrs.push(<span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>)  url+= attrs.join(<span class="hljs-string">&#x27;&amp;&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)    script.src = url    <span class="hljs-built_in">document</span>.body.appendChild(script);    <span class="hljs-keyword">try</span>&#123;      <span class="hljs-built_in">window</span>[callback] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;        resolve(data)        <span class="hljs-built_in">document</span>.removeChild(script)      &#125;    &#125;<span class="hljs-keyword">catch</span>(err)&#123;      reject(err)    &#125;  &#125;)&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 发送</span>jsonp(&#123;url: <span class="hljs-string">&quot;http://localhost:3000/jsptest&quot;</span>,params: &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;jsptestmessage&quot;</span> &#125;,callback: <span class="hljs-string">&quot;jsonpCallback&quot;</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<span class="hljs-comment">//处理data</span>    &#125;);</code></pre></div></li><li><p><code>imgPing</code><strong>添加img标签src中放入get请求</strong></p><p>只能发送GET请求，无法接受返回</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();img.onload = img.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;已发送&quot;</span>);&#125;;img.src = <span class="hljs-string">&quot;http://xxx.xxx.com/query?key=value&quot;</span>;<span class="hljs-comment">// 设置完src属性那一刻开始请求就发送了</span></code></pre></div></li><li><p><code>CORS</code>跨域资源共享（详见下文）</p></li><li><p><code>websocket</code>协议</p></li><li><p><code>Fetch</code>API</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postData</span>(<span class="hljs-params">url, data</span>) </span>&#123;<span class="hljs-comment">// Default options are marked with *</span>  <span class="hljs-keyword">return</span> fetch(url, &#123;      body: <span class="hljs-built_in">JSON</span>.stringify(data), <span class="hljs-comment">// must match &#x27;Content-Type&#x27; header</span>      cache: <span class="hljs-string">&quot;no-cache&quot;</span>, <span class="hljs-comment">// *default, no-cache, reload, force-cache, only-if-cached</span>      credentials: <span class="hljs-string">&quot;same-origin&quot;</span>, <span class="hljs-comment">// include, same-origin, *omit</span>      headers: &#123;        <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/4.0 MDN Example&quot;</span>,      <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span>      &#125;,      method: <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-comment">// *GET, POST, PUT, DELETE, etc.</span>      mode: <span class="hljs-string">&quot;cors&quot;</span>, <span class="hljs-comment">// no-cors, cors, *same-origin</span>      redirect: <span class="hljs-string">&quot;follow&quot;</span>, <span class="hljs-comment">// manual, *follow, error</span>      referrer: <span class="hljs-string">&quot;no-referrer&quot;</span> <span class="hljs-comment">// *client, no-referrer</span>      &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json()); <span class="hljs-comment">// parses response to JSON</span>  &#125;</code></pre></div></li></ul><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a><code>CORS</code>跨域</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul><li>方法<code>POST</code> <code>GET</code> <code>HEAD</code>,</li><li><code>Content-Type</code>：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><ul><li><code>request header</code>中添加<code>Origin</code>字段</li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul><li><p><code>Access-Control-Allow-Origin</code>:允许跨域访问的域，可以是一个域的列表，也可以是通配符”*“</p></li><li><p><code>Access-Control-Allow-Credentials</code>:是否允许请求带有 cookie</p><p>如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</p><p>并且 ajax 中要打开</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.withCredentials = <span class="hljs-literal">true</span>;  <span class="xml">&lt;-------</span></code></pre></div></li><li><p><code>Access-Control-Expose-Headers</code>: 自定义字段</p></li></ul><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><ul><li>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code></li><li>正式通信前会先发起”预检”请求</li><li>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样</li></ul><h5 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h5><ul><li><code>OPTIONS</code>请求发送预检请求</li><li><code>Origin</code>来源域</li><li><code>Access-Control-Request-Method</code>接下来请求的方法</li><li><code>Access-Control-Request-Headers</code>自定义首部</li></ul><h5 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h5><ul><li><code>Access-Control-Allow-Origin</code>允许跨域访问的域</li><li><code>Access-Control-Allow-Methods</code>服务器支持的所有跨域请求的方法</li><li><code>Access-Control-Max-Age</code>预检请求有效期</li><li><code>Access-Control-Allow-Credentials</code>与简单请求相同</li></ul><h2 id="XSS跨域脚本攻击"><a href="#XSS跨域脚本攻击" class="headerlink" title="XSS跨域脚本攻击"></a>XSS跨域脚本攻击</h2><p><code>Cross-site scripting</code></p><blockquote><p>浏览器渲染过程中执行了预期外的恶意代码</p></blockquote><blockquote><p>XSS利用web开发过程中的漏洞执行攻击</p></blockquote><ul><li><p>存储型XSS</p><p>  input, textarea等）中写入恶意脚本上传到服务器，其他人下载带有该脚本的html页面至浏览器时脚本运行</p></li><li><p>反射型XSS</p><p>  将恶意代码加入<code>URL</code>中提交给服务器，服务器返回内容就带上了恶意代码，浏览器下载页面则执行了恶意代码，服务器不存储恶意代码</p></li><li><p>DOM XSS</p><ul><li>JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等函数</li><li><code>&lt;a&gt;</code>标签的<code>href</code>属性</li><li>DOM中的内联事件监视器,<code>location</code>,<code>onclick</code>,<code>onerror</code>,<code>onload</code>等</li><li>都可以将字符串作为代码执行</li></ul></li></ul><h3 id="防范XSS"><a href="#防范XSS" class="headerlink" title="防范XSS"></a>防范XSS</h3><ul><li><p>使用内容安全策略CSP<code>Content Security Policy</code>,限制该页面可以获取的资源和来源</p></li><li><p>对所有用户提交内容进行可靠的输入验证，包括URL、查询关键字、HTTP头、REFER、POST数据等</p></li><li><p>任何内容输出到页面之前都必须加以<code>en-code</code>编码，避免生成意外的html标签；</p></li><li><p><code>cookie</code> 内不存储敏感信息如账号密码等，并设施<code>http only</code></p></li></ul><h2 id="CSRF跨域请求伪造"><a href="#CSRF跨域请求伪造" class="headerlink" title="CSRF跨域请求伪造"></a>CSRF跨域请求伪造</h2><p><code>Cross-site request forgery</code></p><blockquote><p>利用用户登录态</p></blockquote><h3 id="防御CSRF"><a href="#防御CSRF" class="headerlink" title="防御CSRF"></a>防御CSRF</h3><ul><li>验证<code>http</code>请求的来源<code>origin</code>和<code>referrer</code></li><li>设置<code>cookie</code>的<code>SameSite</code>属性，使<code>cookie</code>只可被第一方使用</li><li>设置客户端请求携带<code>session token</code>，并在服务器端验证<code>token</code></li><li>验证码 </li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="SQl注入"><a href="#SQl注入" class="headerlink" title="SQl注入"></a>SQl注入</h4><ol><li><p>黑客提交畸形数据改变语义提交sql查询得到非法数据</p></li><li><p>防御</p><ol><li>过滤sql保留字</li><li>减少抛出不必要的数据库错误信息</li><li>禁止动态拼接sql语句访问数据库</li></ol></li></ol><h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><ol><li>点击透明iframe</li><li>监听鼠标移动位置</li><li>H5拖拽</li><li>防御：<ol><li>服务端添加 <code>X-Frame-Options</code> 响应头</li><li>js判断顶层视口是否同源</li><li>敏感操作复杂操作（验证码，二次确认</li></ol></li></ol><h4 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a><code>window.opener</code></h4><ol><li>修改<code>window.opener.location</code>可以改写来源站点的地址</li><li>防御：<ol><li>设置a标签的rel属性<code>rel=noopener</code>,禁止新页面传递源页面地址</li><li>外部链接改为经由服务器跳转</li><li>使用window.open打开外链</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生js</title>
    <link href="/2022/02/24/%E5%8E%9F%E7%94%9Fjs/"/>
    <url>/2022/02/24/%E5%8E%9F%E7%94%9Fjs/</url>
    
    <content type="html"><![CDATA[<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><blockquote><p>js 是一门函数优先的轻量级解释型语言，基于原型编程的动态脚本语言</p></blockquote><ol><li>函数是一等公民（变量提升，函数可以作为函数的参数，返回值，可以赋值给变量，【函数式编程的条件】</li><li>面向对象编程</li><li>弱类型语言（变量的类型在运行时会变化，强类型语言的变量类型编译时就确定且不会改变</li><li>基于原型（区别于基于类[类和实例]，js 中万物皆为[对象]<blockquote><p>基于原型的语言具有所谓原型对象（prototypical object）的概念。原型对象可以作为一个模板，新对象可以从中获得原始的属性。任何对象都可以指定其自身的属性，任何对象都可以作为另一个对象的原型（prototype），从而允许后者共享前者的属性。</p></blockquote></li></ol><h2 id="BOM（Browser-Object-Model）-浏览器对象模型"><a href="#BOM（Browser-Object-Model）-浏览器对象模型" class="headerlink" title="BOM（Browser Object Model） 浏览器对象模型"></a>BOM（Browser Object Model） 浏览器对象模型</h2><ul><li><p><code>navigator</code>    用户信息</p><ul><li><code>Navigator.geolocation</code>地理位置</li><li><code>NavigatorID.userAgent</code>用户代理信息</li></ul></li><li><p><code>location</code>    文档位置</p><ul><li><code>location.href/hash/search/domain/path/port/protcol</code></li><li><code>location.reload()</code></li><li><code>location.replace()</code></li></ul></li><li><p><code>history</code>    窗口浏览器历史</p><ul><li><code>history.go()</code></li><li><code>history.back()</code></li><li><code>history.forward()</code></li><li><blockquote><p>window.go(-1) = window.back() + f5 // 丢失表单</p></blockquote></li></ul></li><li><p><code>screen</code> 屏幕信息</p></li></ul><h2 id="DOM-（Document-Object-Model）-文档对象模型"><a href="#DOM-（Document-Object-Model）-文档对象模型" class="headerlink" title="DOM （Document Object Model） 文档对象模型"></a>DOM （Document Object Model） 文档对象模型</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(id);<span class="hljs-built_in">document</span>.getElementsByTagName(name);<span class="hljs-built_in">document</span>.createElement(name);parentNode.appendChild(node);element.innerHTML;<span class="hljs-comment">//innerHTML 从对象起始位置到终止位置的全部内容（包括html标签</span><span class="hljs-comment">//outerHTML 包括对象自身标签</span><span class="hljs-comment">//innerText innerHTML但不包括html标签，</span><span class="hljs-comment">//textContent 所有文本内容，包括script和style标签内</span>element.style.left;element.setAttribute();element.getAttribute();element.addEventListener();<span class="hljs-built_in">window</span>.content;<span class="hljs-built_in">window</span>.onload;<span class="hljs-built_in">window</span>.dump();<span class="hljs-built_in">window</span>.scrollTo();</code></pre></div><h2 id="js严格模式use-strict"><a href="#js严格模式use-strict" class="headerlink" title="js严格模式use strict"></a>js严格模式<code>use strict</code></h2><ol><li>无法意外创建全局变量</li><li>静默失败将会被抛出异常(给不可写属性赋值, 给只读属性赋值, 给不可扩展对象的新属性赋值,删除必可删除的属性…etc)</li><li>函数参数名唯一</li><li>禁止使用<code>with</code></li><li><code>eval()</code>有自己的作用域</li><li>禁止删除声明变量</li><li>禁止使用<code>.callee</code>和<code>.arguments</code></li><li>保留关键字</li><li>禁止了不在脚本或者函数层面的函数声明 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// !!! 语法错误</span>  f();&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// !!! 语法错误</span>  f2();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baz</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 合法</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eit</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// 同样合法</span>&#125;</code></pre></div></li></ol><h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h2><ul><li><code>charAt()</code> 返回索引位置字符</li><li><code>charCodeAt()</code>返回索引位置字符UTF16代码</li><li></li><li><code>concat()</code> 拼接</li><li><code>indexOf()</code>, <code>lastIndexOf()</code> 返回索引</li><li><code>includes()</code> 返回Boolean</li><li><code>match()</code> 匹配正则</li><li><code>replace()</code> 替换</li><li><code>split()</code> 分割字符串</li><li><code>slice()</code> 截取返回新字符串，以索引</li><li><code>substring()</code> //截取返回新字符串，以长度</li><li><code>trim()</code> //删除空格</li><li><code>toLowerCase(), toUpperCase()</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件夹内批量映射为模块</title>
    <link href="/2022/02/24/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/02/24/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="1-批量注册中间件"><a href="#1-批量注册中间件" class="headerlink" title="1. 批量注册中间件"></a>1. 批量注册中间件</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers中controllerA.jscontrollerB.jscontrollerC.js</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers/index.js<span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 映射文件夹下的文件为模块</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> mapDir = <span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> tree = &#123;&#125;    <span class="hljs-comment">// 获得当前文件夹下的所有的文件夹和文件</span>    <span class="hljs-keyword">const</span> [dirs, files] = _(fs.readdirSync(d))        .partition(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> fs.statSync(path.join(d, p)).isDirectory())    <span class="hljs-comment">// _(value)</span>    <span class="hljs-comment">// 创建一个经 lodash 包装后的对象会启用隐式链。返回的数组、集合、方法相互之间能够链式调用</span>    <span class="hljs-comment">// 递归映射文件夹</span>    dirs.forEach(<span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> &#123;        tree[dir] = mapDir(path.join(d, dir))    &#125;)    <span class="hljs-comment">// 映射文件</span>    files.forEach(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.extname(file) === <span class="hljs-string">&#x27;.js&#x27;</span>) &#123;            tree[path.basename(file, <span class="hljs-string">&#x27;.js&#x27;</span>)] = <span class="hljs-built_in">require</span>(path.join(d, file))        &#125;    &#125;)    <span class="hljs-keyword">return</span> tree&#125;<span class="hljs-comment">// 默认导出当前文件夹下的映射</span><span class="hljs-built_in">module</span>.exports = mapDir(path.join(__dirname))</code></pre></div><ul><li>  使用</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controllers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../controllers&quot;</span>);router.get(<span class="hljs-string">&quot;/A&quot;</span>, controllers.controllerA);router.post(<span class="hljs-string">&quot;/B&quot;</span>, controllers.controllerB);router.post(<span class="hljs-string">&quot;/C&quot;</span>, controllers.controllerC);</code></pre></div><h2 id="2-批量注册路由"><a href="#2-批量注册路由" class="headerlink" title="2. 批量注册路由"></a>2. 批量注册路由</h2><ul><li>  <code>/routes/...</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">/a.js&#123;    <span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-router&#x27;</span>)()    router.get(<span class="hljs-string">&#x27;/xxx&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;        ctx.....    &#125;)    <span class="hljs-keyword">return</span> router&#125;...b.jsc.jsd.js</code></pre></div><ul><li>  <code>/router/index.js</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa-router&quot;</span>)();<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<span class="hljs-keyword">const</span> mapRoutes = <span class="hljs-function">(<span class="hljs-params">filePath</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> files = fs.readdirSync(filePath); <span class="hljs-comment">//将当前目录下 都读出来</span>files.filter(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<span class="hljs-comment">// 过滤</span><span class="hljs-keyword">if</span> (filePath !== __dirname &amp;&amp; file === <span class="hljs-string">&quot;index.js&quot;</span>) &#123;<span class="hljs-comment">//读取的时候会将当前目录的 index.js 也读取出来，这个不需要，如果拿到别的地方可以不加这个判断</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;routes module must not be &#x27;index.js&#x27; &quot;</span>);&#125;<span class="hljs-keyword">return</span> file !== <span class="hljs-string">&quot;index.js&quot;</span>;&#125;) <span class="hljs-comment">// 将 index.js 过滤掉，路由名字一律不能用 index.js 命名，否则不生效，我这里边的 index.js 如果拿到外面就不用添加这个判断了 ...</span>.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> newFilePath = path.join(filePath, file);<span class="hljs-keyword">if</span> (fs.statSync(newFilePath).isDirectory()) &#123;<span class="hljs-comment">// 是目录</span>loadRoutes(newFilePath); <span class="hljs-comment">// 递归</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 是文件</span><span class="hljs-keyword">let</span> route = <span class="hljs-built_in">require</span>(newFilePath);<span class="hljs-comment">//注册路由</span>router.use(route.routes());router.use(route.allowedMethods());&#125;&#125;);&#125;;mapRoutes(path.join(__dirname));<span class="hljs-built_in">module</span>.exports = router;</code></pre></div><ul><li>  <code>app.js</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/index&quot;</span>);app.use(routes.routes(), routes.allowedMethods());</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆及相关算法</title>
    <link href="/2022/02/24/%E5%A0%86/"/>
    <url>/2022/02/24/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>堆就是完全二叉树</p><div class="hljs code-wrapper"><pre><code class="hljs">完全二叉树：除了深度最深的一层外所有层节点数都满员深度：从根节点到该节点经历的节点个数</code></pre></div></li><li><p>每一个节点都比左右子节点大–&gt;最大堆，最大值在根节点</p></li><li><p>每一个节点都比左右子节点小–&gt;最小堆，最小值在根节点</p></li><li><p>完全二叉树可以使用数组来存储</p></li></ul><h3 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h3><ul><li>将节点与父节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//小顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)</span>&#123;  <span class="hljs-keyword">while</span>(heapSize&lt;items.length - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// items 第一个是&lt;empty item&gt;</span>    heapSize++    heapify(items,heapSize)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span> &amp;&amp; items[i] &lt; items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;    [items[i],items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] =  [items[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],items[i]]    <span class="hljs-comment">// 交换位置</span>    i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)  &#125; &#125;</code></pre></div><ul><li>将节点与子节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//大顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items</span>)</span>&#123;  <span class="hljs-keyword">const</span> heapSize = items.length - <span class="hljs-number">1</span>  <span class="hljs-comment">// &lt;-- items.length - 1 !</span>  <span class="hljs-comment">// 最后叶子节点的索引值</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123; <span class="hljs-comment">// &lt;-i&gt;=1 !</span>    <span class="hljs-comment">// i 为最后一个非 叶子 节点的索引，i还有子节点</span>    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items, heapSize, i</span>) </span>&#123;  <span class="hljs-comment">// 自上而下式堆化</span>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">var</span> maxIndex = i;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>          maxIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;          maxIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (maxIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[maxIndex]] = [items[maxIndex],items[i]]      i = maxIndex;   &#125;&#125;</code></pre></div><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>建立大顶堆/小顶堆</li><li>则索引1位置为当前堆的 最大值/最小值</li><li>循环将[1]与[末尾]交换位置，并且缩小堆的大小（相当于将上一次的最值移出堆）</li><li>一直堆化</li><li>大顶堆得到升序 / 小顶堆得到降序排列</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-comment">// 输入需要为[,]</span>  <span class="hljs-comment">// const heap = [,]</span>  <span class="hljs-comment">// let i = 0</span>  <span class="hljs-comment">// while(i&lt;arr.length)&#123;</span>  <span class="hljs-comment">//   heap.push(arr[i++])</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">const</span> heapSize  =  arr.length - <span class="hljs-number">1</span>  buildHeap(arr,heapSize)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = heapSize ; i&gt;<span class="hljs-number">1</span> ;i--)&#123;    [arr[i],arr[<span class="hljs-number">1</span>]]=[arr[<span class="hljs-number">1</span>],arr[i]]    heapSize --    heapify(arr,heapSize,<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h3 id="topK问题"><a href="#topK问题" class="headerlink" title="topK问题"></a>topK问题</h3><p>求出前k个最大/最小值，或者出现次数最多/最少的k个值</p><ul><li>求大值，建立最小堆</li><li>求小值，建立最大堆<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如求前k个最大值</span><span class="hljs-comment">// 先用前k个数据建立小顶堆</span><span class="hljs-comment">// 为什么求前k大建立小顶堆？？？</span><span class="hljs-comment">// 如果建立大顶堆，交换堆顶后，堆顶依然是最大的，依次比较之后的数据只会改变堆顶而已，收集不了别的值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">topK</span>(<span class="hljs-params">data,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> heap = [,...data]  <span class="hljs-keyword">const</span> heapSize = k  buildHeap(heap,heapSize)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt;data.length ;j++)&#123;    <span class="hljs-comment">// 将余下的数据依次与堆顶比较</span>    <span class="hljs-comment">// 比小顶堆的堆顶大则交换</span>    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; data[j])&#123;      heap[<span class="hljs-number">1</span>] = data[j]      heapify(heap,k,<span class="hljs-number">1</span>)    &#125;  &#125;  heap.shift()  <span class="hljs-keyword">return</span> heap&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">items ,heapSize</span>)</span>&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123;    heapify(items,heapSize,i)  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)</span>&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>        minIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;        minIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[minIndex]] = [items[minIndex],items[i]]      i = minIndex;   &#125;&#125;</code></pre></div></li></ul><h3 id="中位数问题"><a href="#中位数问题" class="headerlink" title="中位数问题"></a>中位数问题</h3><p><code>n</code>个数据中的中位数</p><div class="hljs code-wrapper"><pre><code class="hljs">  [1,2,3] =&gt; 2  [1,2,3,4] =&gt; 2,3  当 n % 2 !== 0 时，中位数为：arr[(n-1)/2]  当 n % 2 === 0 时，中位数为：arr[n/2], arr[n/2 + 1]</code></pre></div><ul><li><p>将前<code>n/2//偶数</code>||<code>（Math.floor(n/2)）+ 1//奇数</code>堆化为大顶堆，后<code>Math.floor(n/2)</code>堆化为小顶堆。</p></li><li><p>结果分别为两个堆顶<code>偶数</code>/前面的堆顶<code>奇数</code></p></li><li><p>动态数组，则把插入的数据与堆顶比较</p><ul><li>【升序】大于大顶堆的顶则加入小顶堆</li><li>【降序】小于小顶堆则加入大顶堆</li><li> 加入后再次堆化，如果堆大小不满足分割中位数要求则继续调整</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Median</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.maxHeap = <span class="hljs-keyword">new</span> MaxHeap()  <span class="hljs-built_in">this</span>.minHeap = <span class="hljs-keyword">new</span> MinHeap()&#125;Median.prototype.addNum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-built_in">this</span>.maxHeap.getTop() || !<span class="hljs-built_in">this</span>.maxHeap.getSize())&#123;    <span class="hljs-built_in">this</span>.maxHeap.insert(num)  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-built_in">this</span>.minHeap.insert(num)  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.maxHeap.getSize() - <span class="hljs-built_in">this</span>.minHeap.getSize() &gt; <span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//奇数分布</span>    <span class="hljs-comment">//大顶堆size比小顶堆大1</span>    <span class="hljs-built_in">this</span>.minHeap.insert(<span class="hljs-built_in">this</span>.maxHeap.rmTop())    <span class="hljs-comment">//不符合则大顶堆顶插入小顶堆</span>  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.minHeap.getSize() &gt; <span class="hljs-built_in">this</span>.maxHeap.getSize())&#123;    <span class="hljs-built_in">this</span>.maxHeap.insert(<span class="hljs-built_in">this</span>.minHeap.rmTop())    <span class="hljs-comment">// </span>  &#125;&#125;Median.prototype.getMedianNum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-comment">// return console.log(this.maxHeap.getSize());</span>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.maxHeap.getSize() &amp;&amp; <span class="hljs-built_in">this</span>.maxHeap.getSize() === <span class="hljs-built_in">this</span>.minHeap.getSize())&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.maxHeap.getTop() + <span class="hljs-built_in">this</span>.minHeap.getTop())/<span class="hljs-number">2</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.maxHeap.getTop()&#125;<span class="hljs-comment">// 大顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MaxHeap</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-built_in">this</span>.getSize = <span class="hljs-function">() =&gt;</span> heap.length - <span class="hljs-number">1</span>  <span class="hljs-built_in">this</span>.getTop = <span class="hljs-function">() =&gt;</span> heap.length &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    <span class="hljs-comment">//插入式建堆</span>    heap.push(num)    <span class="hljs-keyword">let</span> i = heap.length - <span class="hljs-number">1</span>    <span class="hljs-comment">// push 进去的索引</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &gt; heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 大顶堆，与父节点比较，大于则交换</span>      [heap[i],heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-built_in">this</span>.rmTop = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.length &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.length === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.pop()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.pop()<span class="hljs-comment">// 拿走了top值，并用末尾节点填充</span>    heapify(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  <span class="hljs-keyword">const</span> heapify = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-comment">// 堆化</span>    <span class="hljs-keyword">const</span> heapSize = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> maxIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &gt; heap[i]) maxIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &gt; heap[maxIndex]) maxIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> <span class="hljs-comment">// !!!!!!</span>      <span class="hljs-keyword">if</span>(maxIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[maxIndex]] = [heap[maxIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = maxIndex    &#125;  &#125;&#125;<span class="hljs-comment">// 小顶堆</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinHeap</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-built_in">this</span>.getSize = <span class="hljs-function">() =&gt;</span> heap.length - <span class="hljs-number">1</span>  <span class="hljs-built_in">this</span>.getTop = <span class="hljs-function">() =&gt;</span> heap.length &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    heap.push(num)    <span class="hljs-keyword">let</span> i = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &lt; heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 小顶堆，与父节点比较，小于则交换</span>      [heap[i],heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-built_in">Math</span>.floor(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-built_in">this</span>.rmTop = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.length&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.length === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.pop()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.pop()    heapify(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  <span class="hljs-keyword">const</span> heapify = <span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> heapSize = heap.length - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> minIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &lt; heap[i]) minIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; heap[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>      <span class="hljs-keyword">if</span>(minIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[minIndex]] = [heap[minIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = minIndex    &#125;  &#125;&#125;<span class="hljs-comment">// 二分查找法</span><span class="hljs-keyword">const</span> MedianFinder = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = []&#125;MedianFinder.prototype.addMun = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">this</span>.data  <span class="hljs-keyword">if</span>(data.length&lt;<span class="hljs-number">1</span>)&#123;    data.push(num)    <span class="hljs-keyword">return</span>   &#125;  <span class="hljs-keyword">let</span> L = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> R = data.length - <span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(L&lt;=R)&#123;    <span class="hljs-keyword">let</span> M = <span class="hljs-built_in">Math</span>.floor((L+R)/<span class="hljs-number">2</span>)    <span class="hljs-keyword">if</span>(data[M]===num)&#123;      data.splice(M,<span class="hljs-number">0</span>,num)      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(data[M]&lt;num)&#123;      L ++    &#125;<span class="hljs-keyword">else</span>&#123;      R --    &#125;  &#125;  data.splice(R+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,num)&#125;MedianFinder.prototype.findMedian = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> len = <span class="hljs-built_in">this</span>.data.length  <span class="hljs-keyword">if</span>(!len) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((len-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)  <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>===<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.data[mid]+ <span class="hljs-built_in">this</span>.data[mid+<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data[mid]  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作字符串算法题</title>
    <link href="/2022/02/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>  寻找最长公公前缀</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><span class="hljs-comment">// 输出: &quot;fl&quot;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix</span>(<span class="hljs-params">...str</span>) </span>&#123;<span class="hljs-keyword">if</span> (!str.length || str.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">let</span> ref = str[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; str.length; i++) &#123;<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (; j &lt; ref.length &amp;&amp; j &lt; str[i].length; j++) &#123;<span class="hljs-keyword">if</span> (ref.chartAt(j) !== str[i].chartAt(j)) <span class="hljs-keyword">break</span>;&#125;ref = ref.subString(<span class="hljs-number">0</span>, j);&#125;<span class="hljs-keyword">return</span> ref;&#125;</code></pre></div><ul><li>  连字符转为驼峰</li></ul><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> toCamelCase = <span class="hljs-function">(<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt;</span> str.replace(<span class="hljs-regexp">/-\w/g</span>, <span class="hljs-function">(<span class="hljs-params">$</span>) =&gt;</span> $.slice(<span class="hljs-number">1</span>).toUpperCase());</code></pre></div><ul><li>  将字符串改为首字母大写</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// -i-hate -_you_</span><span class="hljs-comment">// \b匹配单词边界</span><span class="hljs-comment">// 加上判断是否会有下划线</span><span class="hljs-comment">// \w 字母、数字、下划线</span><span class="hljs-keyword">const</span> firstUpper = <span class="hljs-function">(<span class="hljs-params">str: string</span>) =&gt;</span> str.replace(<span class="hljs-regexp">/\b_?\w/g</span>, <span class="hljs-function">(<span class="hljs-params">$</span>) =&gt;</span> $.toUpperCase());</code></pre></div><ul><li>  反转句子</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  正则</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">return</span> str.trim().replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">&quot; &quot;</span>).split(<span class="hljs-string">&quot; &quot;</span>).reverse().join(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// \s \s是指空白,包括空格、换行、tab缩进等所有的空白</span><span class="hljs-comment">// 去除单词之间多余的空白</span>&#125;<span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseWords</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-comment">// 也可以使用string+ &#x27; &#x27;</span><span class="hljs-comment">// 这里使用数组</span><span class="hljs-keyword">let</span> arr = [];str = srt.trim();<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = str.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> word = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">// 去除头尾多余空格</span><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<span class="hljs-keyword">let</span> char = str.charAt(left);<span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot; &quot;</span> &amp;&amp; word) &#123;arr.unshift(word);word = <span class="hljs-string">&quot;&quot;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char !== <span class="hljs-string">&quot; &quot;</span>) &#123;word += char;&#125;left++;&#125;arr.unshift(word);<span class="hljs-comment">// 上面单词的添加是基于该位置字符是否为空</span><span class="hljs-comment">// 则最后一个单词的末尾非空将不会被添加</span><span class="hljs-comment">// 所以最后加上arr.unshift(word)</span><span class="hljs-keyword">return</span> arr.join(<span class="hljs-string">&quot; &quot;</span>);&#125;</code></pre></div><ul><li>  检查回文</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseCheck</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">let</span> s = str.toLowerCase().replace(<span class="hljs-regexp">/[\W_]/g</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 格式掉不是字母的别的玩意</span><span class="hljs-comment">// | `\W`   | 匹配任意不是字母，数字，下划线 |</span><span class="hljs-comment">// `[]` 字符串用中括号括起来，表示匹配其中的任一字符</span><span class="hljs-keyword">return</span> s === s.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 指针</span><span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span><span class="hljs-keyword">let</span> r = str.length - <span class="hljs-number">1</span> <span class="hljs-keyword">while</span>(l&lt;r)&#123;<span class="hljs-keyword">if</span>(str[l++]===str[r--])&#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><ul><li>  最长不重复子串长度</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 滑动窗口</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longest1</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = [];<span class="hljs-comment">// 滑动窗口</span><span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<span class="hljs-keyword">const</span> index = <span class="hljs-built_in">window</span>.indexOf(str[i]);<span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) &#123;<span class="hljs-built_in">window</span>.splice(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>);<span class="hljs-comment">// 有重复值时缩小窗口</span>&#125;<span class="hljs-built_in">window</span>.push(str[i]);<span class="hljs-comment">// 无重复扩大窗口</span>maxLen = <span class="hljs-built_in">Math</span>.max(maxLen, <span class="hljs-built_in">window</span>.length);&#125;<span class="hljs-keyword">return</span> maxLen;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longest2</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">let</span> _index = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; str.length; j++) &#123;_index = str.substring(i, j).indexOf(str[j]);<span class="hljs-keyword">if</span> (_index !== -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// _index为重复项位置</span>i += _index + <span class="hljs-number">1</span>;&#125;maxLen = <span class="hljs-built_in">Math</span>.max(maxLen, j - i + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> maxLen;&#125;<span class="hljs-comment">// map双指针</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longest3</span>(<span class="hljs-params">str</span>) </span>&#123;<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">// 设 i 位置右侧字符无重复</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; str.length; j++) &#123;<span class="hljs-keyword">if</span> (map.has(str[j])) &#123;i = <span class="hljs-built_in">Math</span>.max(map.get(str[j]) + <span class="hljs-number">1</span>, i);<span class="hljs-comment">// 检测到重复，更新i的位置，注意不一定是str[j]+1，str[j]+1不一定比上一个重复元素的查重位置更靠后</span><span class="hljs-comment">// [3,2,1,1,3,2] 3查重的位置明显小于1查重</span>&#125;map.set(str[j], j);maxLen = <span class="hljs-built_in">Math</span>.max(j - i + <span class="hljs-number">1</span>, maxLen);&#125;&#125;</code></pre></div><ul><li>  计算二进制数中 1 的个数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// n 为32位二进制数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hammingWeight1</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">const</span> numStr = n.toString(<span class="hljs-number">2</span>);<span class="hljs-comment">// 转为二进制后记数</span><span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numStr.length; i++) &#123;<span class="hljs-keyword">if</span> (numStr[i] === <span class="hljs-string">&quot;1&quot;</span>) &#123;showTimes++;&#125;&#125;<span class="hljs-keyword">return</span> showTimes;&#125;<span class="hljs-comment">// 位运算</span><span class="hljs-comment">// &gt;&gt;&gt; 无符号向右移</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hammingWeight2</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;showTimes += n &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">// &amp;运算，1的二进制为1</span><span class="hljs-comment">// 则左右都为1时输出1</span>n &gt;&gt;&gt;= <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> showTimes;&#125;<span class="hljs-comment">// 整体n &amp;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hammingWeight3</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;showTimes++;n &amp;= n - <span class="hljs-number">1</span>;<span class="hljs-comment">// 二进制 - 中</span><span class="hljs-comment">// n-1 相当 于n把最右边的1变为0,其后面的0变为1</span><span class="hljs-comment">// n与n-1进行与运算,1&amp;1=1,即只改变了最右边第一个1</span><span class="hljs-comment">// n       =&gt; 0001100</span><span class="hljs-comment">// n-1     =&gt; 0001011</span><span class="hljs-comment">// n&amp;(n-1) =&gt; 0001000</span><span class="hljs-comment">// n-1     =&gt; 0000111</span><span class="hljs-comment">// n&amp;(n-1) =&gt; 0000000</span><span class="hljs-comment">// 跳出循环</span>&#125;<span class="hljs-keyword">return</span> showTimes;&#125;</code></pre></div><ul><li>  请实现一个函数用来判断字符串是否表示数值（包括整数和小数）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numberCheck</span>(<span class="hljs-params">s</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\s$/</span>.test(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(s).toString() !== <span class="hljs-string">&quot;NaN&quot;</span>;&#125;</code></pre></div><ul><li>  千分位加逗号</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numFormat</span>(<span class="hljs-params">num</span>)</span>&#123;  <span class="hljs-keyword">var</span> res=num.toString().replace(<span class="hljs-regexp">/\d+/</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>&#123; <span class="hljs-comment">// 整数部分</span>       <span class="hljs-keyword">return</span> n.replace(<span class="hljs-regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>,$<span class="hljs-number">1</span>=&gt;$<span class="hljs-number">1</span>+<span class="hljs-string">&#x27;,&#x27;</span>);  &#125;)  <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// or</span><span class="hljs-built_in">Number</span>[].toLocaleString();</code></pre></div><ul><li>  解析 URL 参数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseQueryString</span>(<span class="hljs-params">url</span>) </span>&#123;<span class="hljs-keyword">const</span> rule = <span class="hljs-regexp">/([^?=&amp;]+)=([^&amp;#]*)/g</span>;<span class="hljs-keyword">return</span> url.match.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> [key, value] = b.split(<span class="hljs-string">&quot;=&quot;</span>);k = <span class="hljs-built_in">decodeURIComponent</span>(key);v = <span class="hljs-built_in">decodeURIComponent</span>(value);a[k] = a[k] ? [...a[k], value] : value;<span class="hljs-keyword">return</span> a;&#125;, &#123;&#125;);&#125;</code></pre></div><ul><li>  字符串相加/大数相加</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringAdd</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<span class="hljs-keyword">let</span> l1 = num1.length;<span class="hljs-keyword">let</span> l2 = num2.length;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">// 进位</span><span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (l1 || l2) &#123;<span class="hljs-keyword">if</span> (l1) carry += +num1[--l1];<span class="hljs-keyword">if</span> (l2) carry += +num2[--l2];<span class="hljs-comment">// 当前位</span>res = (carry % <span class="hljs-number">10</span>) + res;<span class="hljs-comment">// 计算出超过十的进位</span>carry = carry &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (carry) res = carry + res;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>  字符串相乘/大数相乘</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringMulti</span>(<span class="hljs-params">x, y</span>) </span>&#123;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;0&quot;</span> || y === <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> y;<span class="hljs-keyword">if</span> (y === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">const</span> len1 = x.length;<span class="hljs-keyword">const</span> len2 = y.length;<span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len1 + len2).fill(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> num1, num2, multi, cur;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;num1 = x[i];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;num2 = y[j];multi = num1 * num2;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;multi&quot;</span> + multi);<span class="hljs-comment">// 参考乘法草稿</span>cur = multi + pos[i + j + <span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;cur&quot;</span> + cur);<span class="hljs-comment">// 进位</span>pos[i + j] += (cur / <span class="hljs-number">10</span>) | <span class="hljs-number">0</span>;<span class="hljs-comment">// 余数</span>pos[i + j + <span class="hljs-number">1</span>] = cur % <span class="hljs-number">10</span>;&#125;&#125;<span class="hljs-keyword">let</span> res = pos.join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">while</span> (res[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;0&quot;</span>) &#123;res = res.substring(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>  实现一个<code>trim</code>函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// trim 返回去除了首尾空白的字符串</span><span class="hljs-built_in">String</span>.prototype._trim = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//1.regexp</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-regexp">/\s+$/</span>, <span class="hljs-string">&quot;&quot;</span>);&#125;;<span class="hljs-built_in">String</span>.prototype._trim = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">const</span> str = <span class="hljs-built_in">this</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">let</span> trimFlag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">let</span> tailIndex; <span class="hljs-comment">// 找出最后一个不是空格的索引</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = str.length - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (str[j] !== <span class="hljs-string">&quot; &quot;</span>) &#123;tailIndex = j;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;<span class="hljs-comment">// 越过末位后又开始忽略空格</span><span class="hljs-keyword">if</span> (i &gt;= tailIndex) &#123;trimFlag = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&quot; &quot;</span> &amp;&amp; trimFlag) &#123;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> &#123;trimFlag = <span class="hljs-literal">false</span>;res += str[i];&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制台一直打印http://xxx/sockjs-node/info?t=xxx</title>
    <link href="/2022/02/24/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%80%E7%9B%B4%E6%8A%A5%E9%94%99sockjs-node/"/>
    <url>/2022/02/24/%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%80%E7%9B%B4%E6%8A%A5%E9%94%99sockjs-node/</url>
    
    <content type="html"><![CDATA[<h3 id="sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。"><a href="#sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。" class="headerlink" title="sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。"></a>sockjs-node是一个JavaScript库，提供跨浏览器JavaScript的API，创建了一个低延迟，全双工的浏览器和web服务器之间通信通道。</h3><h3 id="如果你的项目没有用到sockjs-vuecli3-运行npm-run-serve-之后network里面一直调用一个接口"><a href="#如果你的项目没有用到sockjs-vuecli3-运行npm-run-serve-之后network里面一直调用一个接口" class="headerlink" title="如果你的项目没有用到sockjs,vuecli3 运行npm run serve 之后network里面一直调用一个接口:"></a>如果你的项目没有用到sockjs,vuecli3 运行npm run serve 之后network里面一直调用一个接口:</h3><p><code>http://localhost:8080/sockjs-node/info?t=1556418283950</code></p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ol><li>开发环境中关闭此服务</li></ol><p>  <code>node_modules/sockjs-client/dist/sockjs.js</code>中注释<br><code>self.xhr.send(payload)</code></p><ol start="2"><li>webpack配置中</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">sockHost: <span class="hljs-string">&quot; http://192.168.1.6:8080&quot;</span>,disableHostCheck: <span class="hljs-literal">true</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2022/02/24/%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/24/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字面量</span><span class="hljs-keyword">let</span> arr = []<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-comment">// 构造函数</span><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>()<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-regexp">/传入数组代表数组长度/</span>)<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;item1&#x27;</span>,<span class="hljs-string">&#x27;item2&#x27;</span>/传入元素/)<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>)/省略<span class="hljs-keyword">new</span>操作符/<span class="hljs-comment">// Array.of</span><span class="hljs-built_in">Array</span>.of(<span class="hljs-number">7</span>) 创建一个具有单个元素 <span class="hljs-number">7</span> 的数组，而<span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>) 创建一个长度为<span class="hljs-number">7</span>的空数组<span class="hljs-comment">// Array.from</span><span class="hljs-built_in">Array</span>.from(arrayLike[, mapFn[, thisArg]]类数组对象)</code></pre></div><h2 id="变异方法（改变原数组）"><a href="#变异方法（改变原数组）" class="headerlink" title="变异方法（改变原数组）"></a>变异方法（改变原数组）</h2><ul><li>  <code>pop()</code>删除最后一个元素</li><li>  <code>shift()</code>删除第一个元素</li><li>  <code>push()</code>添加元素至末尾</li><li>  <code>unshift()</code>添加元素至首位</li><li>  <code>splice(start,delCount,new1,new2...)</code>往数组索引为 start 位置删除 delCont 个元素，并从该位置加入 new 新元素</li><li>  <code>sort()</code>排序</li><li><code>reverse()</code>倒序,返回新数组<br>  es6</li><li>  <code>copyWithin(target,start,end)</code>拷贝数组中索引从 start 到 end（end）的元素添加至 target</li><li>  <code>fill(value,start,end)</code>将数组中索引 start 到 end（不含）的位置填充为 value 元素</li></ul><h2 id="非变异方法"><a href="#非变异方法" class="headerlink" title="非变异方法"></a>非变异方法</h2><ul><li>  <code>slice(start,end)</code>潜拷贝，返回索引从 start 到 end（不含）的元素组成新数组</li><li>  <code>join()</code>指定分隔符将数字元素连成字符串</li><li>  <code>concat()</code>合并数组</li><li>  <code>indexOf()/lastIndexOf()</code>查找元素索引,可传入起始位置</li><li>  <code>includes()</code>查找是否包含元素返回 Boolean,可传入起始位置</li><li>  <code>...</code>展开运算符</li></ul><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历数组的回调<code>mapFn</code>包含自动传入的参数(currentValue,currentIndex,thisArr)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// parseInt(string, radix)   解析一个字符串并返回指定基数的十进制整数</span><span class="hljs-comment">// 解释了</span>[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-built_in">parseInt</span>)=&gt;  <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-number">0</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-number">2</span>)=&gt;  <span class="hljs-number">1</span>,<span class="hljs-literal">NaN</span>,<span class="hljs-literal">NaN</span></code></pre></div><ul><li><p>  <code>map()</code>使用指定函数映射每一个元素后的返回值组成的新数组</p></li><li><p>  <code>flatmap()</code>使用指定函数映射每一个元素后的返回值组成新数组并执行一次扁平化</p></li><li><p>  <code>some()</code>测试是否至少有一个元素可以通过提供的函数,返回布尔值，找到第一个就会停止遍历</p></li><li><p>  <code>every()</code>检测数组所有元素是否都符合判断条件,返回布尔值，遇到false就会停止遍历</p></li><li><p>  <code>forEach()</code>对数组的每个元素执行一次提供的函数,不会改变原数组</p></li><li><p>  <code>filter()</code>返回通过制定函数过滤后「返回true」的数组</p></li><li><p>  <code>find()</code>返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined</p></li><li><p>  <code>findIndex()</code>返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1</p></li><li><p>  <code>reduce()和reduceRight()</code>累加器,累加函数的 return 作为下一次累加的 pre 值，并可指定初始值</p></li><li><p>  <code>flat(depth)</code>按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回（_会移除数组中的空项_）</p></li><li><p>调用遍历器[Symbol.Iterator]</p><ul><li>  <code>of Object.keys()</code></li><li>  <code>of Object.values()</code></li><li>  <code>of Object.entries()</code></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].keys()) &#123;<span class="hljs-built_in">console</span>.log(index);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].values()) &#123;<span class="hljs-built_in">console</span>.log(elem);&#125;<span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-comment">// &#x27;b&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].entries()) &#123;<span class="hljs-built_in">console</span>.log(index, elem);&#125;<span class="hljs-comment">// 0 &quot;a&quot;</span><span class="hljs-comment">// 1 &quot;b&quot;</span></code></pre></div></li></ul><h2 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h2><ol><li><p><code>arr.constructor===Array</code></p></li><li><p><code>arr instanceof Array</code></p></li><li><p><code>Array.prototype.isPrototypeOf(arr)</code></p><blockquote><p>这三种查找原型的方法，如果手动更改对象的原型也可欺骗过检测</p></blockquote></li><li><p><code>Object.prototype.toString.call(arr)===&#39;[object Array]&#39;</code></p></li><li><p><code>Array.isArray()</code></p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> notArr = &#123;__proto__: <span class="hljs-built_in">Array</span>.prototype,&#125;;notArr.constructor = <span class="hljs-built_in">Array</span>;<span class="hljs-comment">// true</span><span class="hljs-built_in">Array</span>.prototype.isPrototypeOf(notArr);<span class="hljs-comment">// true</span>notArr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>;<span class="hljs-comment">// true</span><span class="hljs-built_in">Object</span>.prototype.toString.call(notArr);<span class="hljs-comment">// &quot;[object Object]&quot;</span><span class="hljs-built_in">Array</span>.isArray(notArr);<span class="hljs-comment">// false</span></code></pre></div><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">// 1</span><span class="hljs-keyword">let</span> uni1 = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr));<span class="hljs-comment">// 2</span><span class="hljs-keyword">let</span> uni2 = [...new <span class="hljs-built_in">Set</span>(arr)];<span class="hljs-comment">// 3</span><span class="hljs-keyword">let</span> uni3 = arr.sort().reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (pre.length === <span class="hljs-number">0</span> || pre[pre.length - <span class="hljs-number">1</span>] !== cur) pre.push(cur);<span class="hljs-keyword">return</span> pre;&#125;, []);<span class="hljs-comment">// 4</span><span class="hljs-keyword">let</span> uni4 = arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<span class="hljs-keyword">if</span>(!pre.includes(cur))&#123;pre.push(cur)&#125;<span class="hljs-keyword">return</span> pre&#125;,[])<span class="hljs-comment">// 5</span><span class="hljs-keyword">let</span> uni4 = arr.filter(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> arr.indexOf(item) === index;&#125;);</code></pre></div><h2 id="计算数组中元素出现的次数"><a href="#计算数组中元素出现的次数" class="headerlink" title="计算数组中元素出现的次数"></a>计算数组中元素出现的次数</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">//reduce</span><span class="hljs-keyword">let</span> countArr = arr.reduce(<span class="hljs-function">(<span class="hljs-params">obj, i</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;obj[i]++;&#125; <span class="hljs-keyword">else</span> &#123;obj[i] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> obj;&#125;, &#123;&#125;);<span class="hljs-comment">// &#123; &#x27;1&#x27;: 2, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2, &#x27;4&#x27;: 4 &#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;obj[i]++;&#125; <span class="hljs-keyword">else</span> &#123;obj[i] = <span class="hljs-number">1</span>;&#125;&#125;</code></pre></div><h2 id="对于-obj-按照属性分类"><a href="#对于-obj-按照属性分类" class="headerlink" title="对于 obj 按照属性分类"></a>对于 obj 按照属性分类</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 面试题教你归类json</span><span class="hljs-comment">// JSON.parse(jsonStr)</span><span class="hljs-keyword">let</span> person = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Hank&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jery&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span> &#125;,];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">groupBy</span>(<span class="hljs-params">objArr, prop</span>) </span>&#123;<span class="hljs-keyword">return</span> objArr.reduce(<span class="hljs-function">(<span class="hljs-params">acc, obj</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> key = obj[prop];<span class="hljs-keyword">if</span> (!acc[key]) acc[key] = [];acc[key].push(obj);<span class="hljs-keyword">return</span> acc;&#125;, &#123;&#125;);&#125;<span class="hljs-keyword">let</span> res = groupBy(person, <span class="hljs-string">&quot;age&quot;</span>);</code></pre></div><h2 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 reduce</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat1</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">res, item</span>) =&gt;</span>  &#123;    <span class="hljs-keyword">return</span> res.concat(<span class="hljs-built_in">Array</span>.isArray(item) ? flat1(item) : item);  &#125;, []);&#125;<span class="hljs-comment">//2 递归</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat2</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> res = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;    res.push(<span class="hljs-built_in">Array</span>.isArray(item) ? (...flat2(item)) : item)  &#125;  <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 3 展开运算符</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat3</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">while</span> (arr.some(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span>  <span class="hljs-built_in">Array</span>.isArray(item))) &#123;    arr = [].concat(...arr);  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 4 toString</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat4</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr    .toString()    .split(<span class="hljs-string">&quot;,&quot;</span>)    .map(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span>  <span class="hljs-built_in">Number</span>(item));&#125;<span class="hljs-comment">// 5 join</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat5</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">return</span> arr    .join(<span class="hljs-string">&quot;,&quot;</span>)    .split(<span class="hljs-string">&quot;,&quot;</span>)    .map((item) =  <span class="hljs-built_in">Number</span>(item));&#125;<span class="hljs-comment">// 6 flat()</span>flat(<span class="hljs-literal">Infinity</span>);</code></pre></div><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="V8-中的-sort"><a href="#V8-中的-sort" class="headerlink" title="V8 中的 sort()"></a>V8 中的 sort()</h3><ul><li>  7.0 之前 arr.length =10【插入排序】， 10【快速排序】</li><li>  7.0 之后 【timesort】</li></ul><h3 id="常见排序方法"><a href="#常见排序方法" class="headerlink" title="常见排序方法"></a>常见排序方法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote><p>O(n^2) 第一个循环设定冒泡范围，第二个循环冒泡元素</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bubbleSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">const</span> len = arr.length;<span class="hljs-comment">// 外层循环是冒泡范围</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 提前退出flag</span><span class="hljs-comment">// 内层循环是冒泡比较</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; len - i; j++) &#123;<span class="hljs-keyword">if</span> (arr[j - <span class="hljs-number">1</span>] &gt; arr[j]) &#123;[arr[j - <span class="hljs-number">1</span>], arr[j]] = [arr[j], arr[j - <span class="hljs-number">1</span>]];flag = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote><p>O(n^2)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(arr) || arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">const</span> len = arr.length;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">const</span> pivot = arr[i]; <span class="hljs-comment">// 从index开始选出基准值</span><span class="hljs-keyword">let</span> j = i;<span class="hljs-keyword">while</span> (arr[j - <span class="hljs-number">1</span>] &gt; pivot &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 与基准值比较,将基准值插入正确位置</span>arr[j] = arr[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 把比基准大的元素向右边搬移</span>j--;&#125;arr[j] = pivot;&#125;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 也可以使用交换,性能低</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSort2</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">const</span> len = arr.length;<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j - <span class="hljs-number">1</span>]; j--) &#123;[arr[j], arr[j - <span class="hljs-number">1</span>]] = [arr[j - <span class="hljs-number">1</span>], arr[j]];&#125;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote><p>O(n^2) 不稳定</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">selectSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arr) !== <span class="hljs-literal">true</span> || arr.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">const</span> len = arr.length;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">let</span> minIndex = i;<span class="hljs-comment">// 假设i为从i到len的最小值</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<span class="hljs-comment">// 从i+1开始寻找最小值</span><span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;minIndex = j;&#125;&#125;<span class="hljs-comment">// 替换i位置的值得</span>[arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><blockquote><p>对于大量数据,上述三种 O(n^2)的时间复杂度难以接受</p></blockquote><h4 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h4><blockquote><p>O(n log n)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-comment">// once function &#x27;mergeSort&#x27; run ,split arr to two group length equally</span><span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> left = arr.slice(<span class="hljs-number">0</span>, mid);<span class="hljs-keyword">const</span> right = arr.slice(mid);<span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">l, r</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (l.length &gt; <span class="hljs-number">0</span> &amp;&amp; r.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//notice: ‘&amp;&amp;’ not ‘||‘</span><span class="hljs-keyword">if</span> (l[<span class="hljs-number">0</span>] &gt; r[<span class="hljs-number">0</span>]) &#123;res.push(r.shift());&#125; <span class="hljs-keyword">else</span> &#123;res.push(l.shift());&#125;&#125;<span class="hljs-comment">// one of l and r is empty,concat it to Array &#x27;res&#x27;</span><span class="hljs-keyword">return</span> res.concat(l).concat(r);&#125;</code></pre></div><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote><p>平均 O(n log n)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>)</span>&#123;  <span class="hljs-keyword">if</span> (arr.length &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr; <span class="hljs-comment">//一直排序到区间内只有一个数</span>  <span class="hljs-keyword">var</span> pivotIndex = <span class="hljs-built_in">Math</span>.floor(arr.length / <span class="hljs-number">2</span>); <span class="hljs-comment">//基准位置（可任意选取）</span>  <span class="hljs-keyword">var</span> pivot = arr.splice(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">//找出基准数并把它从原数组删除</span>  <span class="hljs-keyword">var</span> left = [];  <span class="hljs-comment">// 空间复杂度O(n)</span>  <span class="hljs-keyword">var</span> right = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;    <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<span class="hljs-comment">// 小于在左边大于在右</span>      left.push(arr[i]);    &#125; <span class="hljs-keyword">else</span> &#123;      right.push(arr[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> [...quickSort(left), pivot, ...quickSort(right)];<span class="hljs-comment">// 不使用额外空间,在原数组交换元素位置</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quick</span>(<span class="hljs-params">arr,l,r</span>)</span>&#123;    <span class="hljs-keyword">const</span> index = partition(arr,l,r)    <span class="hljs-comment">// partition函数取出一个基准索引，并会依据基准分为大于小于基准的两部分</span>    <span class="hljs-keyword">if</span>(l&lt;index)&#123;      quick(arr,l,index-<span class="hljs-number">1</span>)    &#125;    <span class="hljs-keyword">if</span>(r&gt;index)&#123;      quick(arr,index+<span class="hljs-number">1</span>,r)    &#125;  &#125;  quick(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> arr&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partition</span>(<span class="hljs-params">arr,l,r</span>)</span>&#123;  <span class="hljs-comment">// 这里直接使用r作为基准，不用随机值</span>  <span class="hljs-comment">// i 是pivot的正确位置，初始在最坐标</span>  <span class="hljs-keyword">let</span> i = l  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = l;j&lt;r;j++)&#123;    <span class="hljs-comment">// 判断相对于基准的大小并更新i的位置</span>    <span class="hljs-comment">// i左边是已经比较完的区间,都比arr[r]小</span>    <span class="hljs-keyword">if</span>(arr[j]&lt;arr[r])&#123;      [arr[j],arr[i]] = [arr[i],arr[j]]<span class="hljs-comment">// j向又扫的过程中遇到比基准小的值时,i停留在上一个比基准大的位置,则对他两进行交换</span>      i++    &#125;  &#125;  <span class="hljs-comment">// pivot归位,最后以i位置完成分界</span>  [arr[i],arr[r]] = [arr[r],arr[i]]  <span class="hljs-keyword">return</span> i&#125;</code></pre></div><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote><p>平均 O(n log 2n) 最坏 O(n^2)<br>相当于设置动态间隔的插入排序</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 移动</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shellSort1</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">const</span> len = arr.length;<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">let</span> gap = <span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>);<span class="hljs-comment">// 这里初始设为长度一半</span><span class="hljs-keyword">for</span> (; gap &gt; <span class="hljs-number">0</span>; gap = <span class="hljs-built_in">Math</span>.floor(gap / <span class="hljs-number">2</span>)) &#123;<span class="hljs-comment">// 不断缩小间隔的长度</span><span class="hljs-comment">// 最终会为1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = gap; i &lt; len; i++) &#123;<span class="hljs-keyword">const</span> pivot = arr[i];<span class="hljs-keyword">let</span> j = i;<span class="hljs-keyword">while</span> (arr[j - gap] &gt; temp &amp;&amp; j - gap &gt;= <span class="hljs-number">0</span>) &#123;arr[j] = arr[j - gap];j -= gap;&#125;arr[j] = pivot;&#125;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 建立大顶堆</span><span class="hljs-comment">// 依次将末尾元素与heap[1]交换位置并调整堆，同时缩小堆的大小（排除最后的大数）</span><span class="hljs-comment">// heap[2]和heap[1]交换完成后就是升序排序</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">const</span> heap = [, ...arr];<span class="hljs-keyword">let</span> heapSize = arr.length;buildHeap(heap, heapSize);<span class="hljs-comment">// 开始交换头尾</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = heapSize; k &gt; <span class="hljs-number">1</span>; k--) &#123;[heap[k], heap[<span class="hljs-number">1</span>]] = [heap[<span class="hljs-number">1</span>], heap[k]];heapify(heap, --heapSize, <span class="hljs-number">1</span>);&#125;heap.shift();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildHeap</span>(<span class="hljs-params">heap, size</span>) </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-built_in">Math</span>.floor(size / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">1</span>; i--) &#123;heapify(heap, size, i);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">heapify</span>(<span class="hljs-params">heap, heapSize, i</span>) </span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">let</span> maxIndex = i;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span> * i] &gt; heap[i]) maxIndex = <span class="hljs-number">2</span> * i;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] &gt; heap[maxIndex]) maxIndex = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (maxIndex === i) <span class="hljs-keyword">break</span>;[heap[maxIndex], heap[i]] = [heap[i], heap[maxIndex]];i = maxIndex;&#125;&#125;&#125;</code></pre></div><h4 id="记数排序"><a href="#记数排序" class="headerlink" title="记数排序"></a>记数排序</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countSort</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">let</span> maxValue = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> arr) &#123;<span class="hljs-keyword">if</span> (n &gt; maxValue) maxValue = n;&#125;<span class="hljs-comment">// 找出数据中的最大值</span><span class="hljs-keyword">const</span> countArr = <span class="hljs-built_in">Array</span>(maxValue + <span class="hljs-number">1</span>).fill(<span class="hljs-number">0</span>);<span class="hljs-comment">// 建立计数数组，下标为数据值，元素为相同元素个数</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> arr) &#123;countArr[n]++;&#125;<span class="hljs-comment">// 统计数据出现次数加入计数数组</span><span class="hljs-comment">// 对计数数组执行累加操作</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; countArr.length; i++) &#123;countArr[i] += countArr[i - <span class="hljs-number">1</span>];&#125;<span class="hljs-comment">// countArr中元素即代表arr中元素小于等于该下标的数量</span><span class="hljs-keyword">const</span> temp = <span class="hljs-built_in">Array</span>(arr.length);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.length - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">let</span> num = arr[j];<span class="hljs-keyword">let</span> pos = countArr[num] - <span class="hljs-number">1</span>;<span class="hljs-comment">// 得出顺序正确的索引</span>temp[pos] = num;<span class="hljs-comment">// arr指针向左扫，归位元素后将累加计数数组中计数-1</span>countArr[num]--;&#125;<span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// or copy temp to origin arr</span>&#125;</code></pre></div><h4 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">return</span> arr.sort(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>);<span class="hljs-comment">//由于js中sort方法的特殊性，对于数据量小于10和大于10的排序方法不一样</span><span class="hljs-comment">// Math.random()-0.5不能做到真正意义上的完全随机</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shuffle</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">let</span> len = arr.length;<span class="hljs-keyword">while</span> (len) &#123;<span class="hljs-keyword">const</span> i = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * len--);[arr[i], arr[len]] = [arr[len], arr[i]];&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈算法题</title>
    <link href="/2022/02/24/%E6%A0%88%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/24/%E6%A0%88%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="栈结构，先进后出"><a href="#栈结构，先进后出" class="headerlink" title="栈结构，先进后出"></a>栈结构，先进后出</h2><ul><li><p>最小栈</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MinStack</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.stack = []  <span class="hljs-built_in">this</span>.min = [<span class="hljs-literal">Infinity</span>]&#125;MinStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;  <span class="hljs-built_in">this</span>.stack.push(item)  <span class="hljs-built_in">this</span>.min.push(<span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">this</span>.min[<span class="hljs-built_in">this</span>.min.length-<span class="hljs-number">1</span>],item))&#125;MinStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&#123;  <span class="hljs-built_in">this</span>.stack.pop()  <span class="hljs-built_in">this</span>.min.pop()&#125;MinStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stack[<span class="hljs-built_in">this</span>.stack.length-<span class="hljs-number">1</span>]&#125;MinStack.prototype.min = <span class="hljs-function"><span class="hljs-keyword">function</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.min[<span class="hljs-built_in">this</span>.min.length-<span class="hljs-number">1</span>]&#125;</code></pre></div></li><li><p>判断括号是否合法</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ()</span><span class="hljs-comment">// []</span><span class="hljs-comment">// &#123;&#125;</span><span class="hljs-comment">// (&#123;[)]&#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bracketCheck</span>(<span class="hljs-params">str</span>)</span>&#123;  <span class="hljs-keyword">const</span> brackets = &#123;    <span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-string">&#x27;)&#x27;</span>,    <span class="hljs-string">&#x27;&#123;&#x27;</span>:<span class="hljs-string">&#x27;&#125;&#x27;</span>,    <span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-string">&#x27;]&#x27;</span>  &#125;  <span class="hljs-keyword">let</span> stack = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i&lt;str.length;i++)&#123;    <span class="hljs-keyword">if</span>(brackets[str[i]])&#123;      stack.push([str[i]])    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str[i] !== brackets[stack.pop()])&#123;      <span class="hljs-comment">// 这个写法6⃣️啊</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> stack.length === <span class="hljs-number">0</span>&#125;</code></pre></div><ul><li>生成n对括号<br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</li></ul><p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateParenthesis</span>(<span class="hljs-params">n</span>)</span>&#123;  <span class="hljs-comment">//n对括号</span>  <span class="hljs-comment">//可用的左括号数量l=n</span>  <span class="hljs-comment">//可用的右括号数量r=n</span>  <span class="hljs-keyword">const</span> res = []  DFS(n,n,<span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-keyword">return</span> res  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DFS</span>(<span class="hljs-params">l,r,str</span>)</span>&#123;    <span class="hljs-comment">// 考虑合理闭合的括号组合</span>    <span class="hljs-comment">// 生成过程中左右括号可使用的数量</span>    <span class="hljs-keyword">if</span>(str.length===<span class="hljs-number">2</span>*n)&#123;      <span class="hljs-comment">// 2n个字符说明凑够一种</span>      <span class="hljs-keyword">return</span> res.push(str)    &#125;    <span class="hljs-keyword">if</span>(l&gt;<span class="hljs-number">0</span>)&#123;      <span class="hljs-comment">// 左括号有就能用</span>      DFS(l-<span class="hljs-number">1</span>,r,str+<span class="hljs-string">&#x27;(&#x27;</span>)    &#125;    <span class="hljs-keyword">if</span>(l&lt;r)&#123;      DFS(l,r-<span class="hljs-number">1</span>,str+<span class="hljs-string">&#x27;)&#x27;</span>)    &#125;  &#125;&#125;</code></pre></div><ul><li>删除字符串内相邻重复项<br>给出由小写字母组成的字符串 S ，删除所有相邻重复项<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// &#x27;ababccca&#x27;</span><span class="hljs-comment">// pre = &#x27;&#x27;</span><span class="hljs-comment">// c = a</span><span class="hljs-comment">// stack = [&#x27;&#x27;,a]</span><span class="hljs-comment">// pre = a</span><span class="hljs-comment">// c = c</span><span class="hljs-comment">// stack = [&#x27;&#x27;,a,c]</span><span class="hljs-comment">// pre = c</span><span class="hljs-comment">// c = c</span><span class="hljs-comment">// stack = [&#x27;&#x27;,a]</span><span class="hljs-comment">// pre = a</span><span class="hljs-comment">// c = c</span><span class="hljs-comment">// stack = [&#x27;&#x27;,a,c]</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delDup</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-keyword">const</span> stack = [s[<span class="hljs-number">0</span>]]  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ;i &lt; s.length ;i++)&#123;    <span class="hljs-keyword">const</span> pre = stack.pop()    <span class="hljs-comment">// 每次取出上一个末尾字符</span>    <span class="hljs-keyword">const</span> cur = s[i]    <span class="hljs-keyword">if</span>(cur !== pre)&#123;      <span class="hljs-comment">// 不是相同字符则存储起来</span>      <span class="hljs-comment">// 是相同字符则由于pop方法已经从结果中删除</span>      stack.push(pre,cur)    &#125;  &#125;  <span class="hljs-keyword">return</span> stack.join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;</code></pre></div></li></ul><ul><li>滑动窗口最大值<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// k 为窗口大小</span><span class="hljs-comment">// window存储数组索引</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxInSlideWin</span>(<span class="hljs-params">arr,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> res = []  <span class="hljs-keyword">let</span> <span class="hljs-built_in">window</span> = []  <span class="hljs-comment">// window存储索引</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; arr.length ; i++)&#123;    <span class="hljs-keyword">if</span>(i-<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>]&gt;=k)&#123;      <span class="hljs-comment">// 窗口大小超过限制</span>      <span class="hljs-built_in">window</span>.shift()      <span class="hljs-comment">// 抛弃前面的值</span>    &#125;    <span class="hljs-keyword">while</span>(arr[<span class="hljs-built_in">window</span>[<span class="hljs-built_in">window</span>.length-<span class="hljs-number">1</span>]]&lt;=arr[i])&#123;      <span class="hljs-comment">// 用指针位置的值与窗口尾部索引值比较</span>      <span class="hljs-comment">// 循环删除比指针小的值索引</span>      <span class="hljs-built_in">window</span>.pop()    &#125;    <span class="hljs-built_in">window</span>.push(i)    <span class="hljs-comment">// i之前都比i大</span>    <span class="hljs-keyword">if</span>(i&gt;=k-<span class="hljs-number">1</span>)&#123;      <span class="hljs-comment">// 索引k-1开始收集窗口最大值，</span>      <span class="hljs-comment">// k-1之前窗口都还没到尺寸</span>      res.push(arr[<span class="hljs-built_in">window</span>[<span class="hljs-number">0</span>]])      <span class="hljs-comment">// 保证窗口内最左值=边索引为最大值</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存策略</title>
    <link href="/2022/02/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2022/02/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p>浏览器在本地验证资源是否过期，如果没过期直接使用本地缓存，并返回<code>200</code>和显示(<code>from memory cache / from disk cache)</code>(根据内存空闲情况和资源类型，并且memory cache页面关闭后会清理，下次加载是从disk cache)</p><h2 id="强缓存字段"><a href="#强缓存字段" class="headerlink" title="强缓存字段"></a>强缓存字段</h2><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><code>Expires</code></h3><ul><li> http 1.0</li><li> 时间戳格式<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code></li><li> ⚠️使用本地时间验证，与服务器时间之间的误差或者本地时间的修改都后会造成缓存失效</li></ul><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a><code>Cache-control</code></h3><ul><li> http 1.1</li><li>可选参数：<ul><li><code>public</code>,<code>private</code><ul><li><code>public</code> 表示该资源可以被所有客户端和代理服务器缓存</li><li><code>private</code> 表示该资源仅能客户端缓存[<em>默认值</em>]</li></ul></li><li><code>max-age</code><em>相对资源首次被请求的时间</em><ul><li>单位为毫秒，表示多长时间后过期</li><li>可设置为 <strong>0</strong> 立即请求新资源</li></ul></li><li><code>s-maxage</code> 会在<code>public</code>字段生效时覆盖<code>Expires</code>和<code>max-age</code> </li><li><code>no-cache</code>,<code>no-store</code><ul><li><code>no-cache</code> 会缓存资源，但要协商缓存验证</li><li><code>no-store</code> 不缓存</li></ul></li><li><code>max-age=0 || no-cache</code>会进入协商缓存</li></ul></li></ul><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><code>Pragma</code></h3><ul><li> 只为了兼容http1.0</li><li> <code>Pragma = no-cache</code>与<code>Cache-Control: no-cache</code>效果一致</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>Cache-Control -&gt; Expires</code></p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>浏览器携带缓存标识向服务器发起请求，询问服务器缓存有效性，协商缓存生效，返回<code>304</code>和<code>Not Modified</code>，协商缓存失效，返回<code>200</code>和请求结果</p><h2 id="协商缓存字段"><a href="#协商缓存字段" class="headerlink" title="协商缓存字段"></a>协商缓存字段</h2><h3 id="Last-modified-If-Modified-Since"><a href="#Last-modified-If-Modified-Since" class="headerlink" title="Last-modified + If-Modified-Since"></a><code>Last-modified + If-Modified-Since</code></h3><ul><li><p>服务器返回资源的同时在<code>response header</code>中添加 <code>Last-Modified</code>字段，值是该资源在服务器上的最后修改时间<br>  <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code></p></li><li><p> 再次请求该资源时，浏览器检测到资源中存在 <code>Last-Modified</code>字段，则会将这个时间戳作为<code>If-Modified-Since</code>的值加入请求头中发送给服务器</p></li><li><p> 服务器根据自身资源的修改时间和来自请求的时间戳判断资源是否更新，返回相对应的结果</p></li></ul><blockquote><p>缺点</p></blockquote><ul><li>本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改</li><li><code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，则不能体现被修改过</li></ul><h3 id="ETag-If-Not-Match"><a href="#ETag-If-Not-Match" class="headerlink" title="ETag + If-Not-Match"></a><code>ETag + If-Not-Match</code></h3><ul><li><p> 服务器为资源进行hash计算生成唯一的标识符<code>Etag</code>加入返回头，资源的修改会导致标识改变</p></li><li><p> 浏览器请求时将资源自带的标识作为<code>If-None-Match</code>的值加入请求头中发送给服务器</p></li><li><p> 服务器根据同一资源标识是否一致返回相应结果</p></li><li><p><code>ETag:\W 弱验证</code>: 新旧资源不需要逐字节一一对应新旧资源的比较会使用较为宽松的算法</p></li><li><p><code>If-Match条件请求</code>: 在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源匹配该ETag值时才会返回资源。而对于 PUT 或其他非安全方法来说，只有在满足条件的情况下才可以将数据上传。例如:Range请求 or 避免更新丢失（用户上传覆盖其他用户提交的更新）</p><h1 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h1></li></ul><ol><li><p>先判断<code>Cache-Control</code>，在<code>Cache-Control</code>的<code>max-age</code>之内，直接返回<code>200 from cache</code>；</p></li><li><p>没有<code>Cache-Control</code>再判断<code>Expires</code>，在<code>Expires</code>之内，直接返回<code>200 from cache</code></p></li><li><p><code>Cache-Control=no-cache/no-store</code>或者不符合<code>Expires</code>，浏览器向服务器发送请求</p></li><li><p> 服务器判断<code>If-Modified-Since</code>和<code>If-None-Match</code>，两者同时出现时会忽略<code>If-Modified-Since</code>，有效则返回<code>304</code>，失效则返回新资源。</p></li></ol><h2 id="用户行为的影响"><a href="#用户行为的影响" class="headerlink" title="用户行为的影响"></a>用户行为的影响</h2><ol><li><em>地址栏</em>访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；</li><li><em>F5</em>刷新，进行协商缓存判断；</li><li><em>ctrl+F5</em>刷新，指定强缓存和协商缓存都失效。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法题</title>
    <link href="/2022/02/24/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/24/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li><p>两数之合</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">arr, target</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<span class="hljs-comment">// 使用数值-&gt;索引建立map</span><span class="hljs-comment">// 每次循环计算得出当前差值</span><span class="hljs-comment">// 在map中查找这个差值既能得出索引</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-keyword">let</span> k = target - arr[i];<span class="hljs-keyword">if</span> (map.has(k)) &#123;res.push([map.get(k), i]);&#125;map.set(arr[i], i);&#125;<span class="hljs-keyword">return</span> res.length === <span class="hljs-number">1</span> ? res[<span class="hljs-number">0</span>] : res;&#125;</code></pre></div></li><li><p>排序数组的两数之和</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt; r) &#123;<span class="hljs-keyword">const</span> curSum = nums[l] + nums[r];<span class="hljs-keyword">if</span> (curNum === target) <span class="hljs-keyword">return</span> [nums[l], nums[r]];<span class="hljs-keyword">if</span> (curNum &gt; target) &#123;r--;&#125; <span class="hljs-keyword">else</span> &#123;l++;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div></li><li><p>三数之合</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">threeSum</span>(<span class="hljs-params">arr, target</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> len = arr.length;<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res;arr = arr.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-comment">// 按大小排序</span><span class="hljs-comment">// 开始循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">if</span> (arr[i] &gt;= target) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 第一个值就大于target后面不用想了</span><span class="hljs-keyword">if</span> (arr[i] === arr[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 跳过重复的值</span><span class="hljs-keyword">let</span> first = i,second = i + <span class="hljs-number">1</span>,third = len - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (second &lt; third) &#123;<span class="hljs-keyword">const</span> sum = arr[first] + arr[second] + arr[third];<span class="hljs-keyword">if</span> (sum === target) &#123;res.push([arr[first], arr[second], arr[third]]);second++;third--;<span class="hljs-comment">// 移动一次指针再跳过重复项</span><span class="hljs-keyword">while</span> (arr[second] === arr[second - <span class="hljs-number">1</span>]) &#123;second++;&#125;<span class="hljs-keyword">while</span> (arr[third] === arr[third + <span class="hljs-number">1</span>]) &#123;third--;&#125;&#125;<span class="hljs-comment">//移动指针</span><span class="hljs-keyword">if</span> (sum &gt; target) third--;<span class="hljs-keyword">if</span> (sum &lt; target) second++;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></li><li><p>最大面积</p><p>  给定数组，按数组 index 为 x 轴坐标,value 为 y 轴坐标在二纬坐标系画线，连接哪两条线时得到最大面积</p><blockquote><p>面积 = 两直线中较短的高度 * 两线间距离</p></blockquote>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxArea</span>(<span class="hljs-params">height</span>) </span>&#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = height.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (l &lt; r) &#123;res = <span class="hljs-built_in">Math</span>.max(res, (r - l) * <span class="hljs-built_in">Math</span>.min(height[l], height[r]));<span class="hljs-keyword">if</span> (height[l] &lt; height[r]) &#123;l++;&#125; <span class="hljs-keyword">else</span> &#123;r--;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></li><li><p>删除排序数组中的重复项，不能使用额外空间，返回不重复的长度</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeDuplicates</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> len = arr.length;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<span class="hljs-keyword">if</span> (arr[j] !== arr[j - <span class="hljs-number">1</span>]) &#123;arr[++i] = arr[j];&#125;&#125;<span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;&#125;</code></pre></div></li><li><p>设计一个支持在平均时间复杂度 O(1) 下，执行以下操作的数据结构。</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">insert(val) ：当元素 val 不存在时，向集合中插入该项。remove(val) ：元素 val 存在时，从集合中移除该项。getRandom ：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。示例 :<span class="hljs-comment">// 初始化一个空的集合。</span>RandomizedSet randomSet = <span class="hljs-keyword">new</span> RandomizedSet();<span class="hljs-comment">// 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span>randomSet.insert(<span class="hljs-number">1</span>);<span class="hljs-comment">// 返回 false ，表示集合中不存在 2 。</span>randomSet.remove(<span class="hljs-number">2</span>);<span class="hljs-comment">// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span>randomSet.insert(<span class="hljs-number">2</span>);<span class="hljs-comment">// getRandom 应随机返回 1 或 2 。</span>randomSet.getRandom();<span class="hljs-comment">// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span>randomSet.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">// 2 已在集合中，所以返回 false 。</span>randomSet.insert(<span class="hljs-number">2</span>);<span class="hljs-comment">// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span>randomSet.getRandom();<span class="hljs-comment">// map方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RandomSet</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-built_in">this</span>.values = []&#125;RandomSet.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.map.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.map.set(val,values.length)  <span class="hljs-comment">// 插入后的索引（插入前的数组长度）</span>  <span class="hljs-built_in">this</span>.values.push(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;RandomSet.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.map.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">this</span>.map.get(val)  <span class="hljs-comment">// 判断在尾部</span>  <span class="hljs-comment">// 似乎也可以用头部</span>  <span class="hljs-keyword">if</span>(index === <span class="hljs-built_in">this</span>.values.length - <span class="hljs-number">1</span>)&#123;    <span class="hljs-built_in">this</span>.map.delete(value)    <span class="hljs-built_in">this</span>.values.pop()  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">// 不在尾部</span>    <span class="hljs-comment">// values用尾部元素填充该位置</span>    <span class="hljs-comment">// map中修改索引</span>    <span class="hljs-keyword">let</span> last = <span class="hljs-built_in">this</span>.values.pop()    <span class="hljs-comment">// 赋值</span>    <span class="hljs-built_in">this</span>.values[index] = last    <span class="hljs-built_in">this</span>.map.set(last,index)    <span class="hljs-built_in">this</span>.map.delete(val)  &#125;  <span class="hljs-keyword">return</span> val&#125;RandomSet.prototype.getRandom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-built_in">this</span>.values.length  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*len)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.values[index]&#125;<span class="hljs-comment">// set方法</span><span class="hljs-comment">// set是不重复的值的集合</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RandomSet</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-built_in">this</span>.data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()&#125;RandomizedSet.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.data.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.set.add(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;RandomizedSet.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.data.has(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-built_in">this</span>.set.delete(val)  <span class="hljs-keyword">return</span> val&#125;RandomizedSet.prototype.getRandom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-built_in">this</span>.values.length  <span class="hljs-keyword">let</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*len)  <span class="hljs-keyword">return</span> [...this.data][index]&#125;</code></pre></div></li><li><p>合并两个有序数组</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// arr1 = [1,2,5]  m=3</span><span class="hljs-comment">// arr2 = [2,3,4]  n=3</span><span class="hljs-comment">// 假设arr1能装下arr2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeArr</span>(<span class="hljs-params">arr1, m, arr2, n</span>) </span>&#123;<span class="hljs-keyword">let</span> index1 = m - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> index2 = n - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> index = m + n - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (index2 &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// arr2耗尽</span><span class="hljs-comment">// 剩下保持arr1的值</span>arr1[index--] = arr2[index2--];<span class="hljs-keyword">continue</span>;&#125;arr1[index--] = arr1[index1] &gt;= arr2[index2] ? arr1[index1--] : arr2[index2--];&#125;&#125;</code></pre></div></li><li><p>计算两个数组的交集</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">arr1, arr2</span>) </span>&#123;<span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arr1.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> arr2.includes(item)))];&#125;</code></pre></div></li><li><p>计算多个数组的交集</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">intersection</span>(<span class="hljs-params">...arrs</span>) </span>&#123;<span class="hljs-keyword">if</span> (arrs.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">if</span> (arrs.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arrs[<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Set</span>(arrs.reduce(<span class="hljs-function">(<span class="hljs-params">pre, next</span>) =&gt;</span> &#123;<span class="hljs-comment">// reduce累加器，每一次的return作为下一次累加的pre，你咋这也能忘</span><span class="hljs-comment">// 后还能添加参数手动制定第一次累加的pre值</span><span class="hljs-keyword">return</span> pre.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> next.includes(item));&#125;)),];&#125;</code></pre></div></li><li><p>实现一个 fill 函数</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// fill(3,4) =&gt; [4,4,4]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFill</span>(<span class="hljs-params">num, size</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">acc, size</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (--size &gt; <span class="hljs-number">0</span>) &#123;acc = acc.concat(num);&#125;<span class="hljs-keyword">return</span> acc, [];&#125;;&#125;</code></pre></div></li><li><p>大数相乘(可以输出字符串)</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bigMulti</span>(<span class="hljs-params">x, y</span>) </span>&#123;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;0&quot;</span> || y === <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> y;<span class="hljs-keyword">if</span> (y === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">const</span> len1 = x.length;<span class="hljs-keyword">const</span> len2 = y.length;<span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len1 + len2).fill(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> num1, num2, mulit, cur;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;num1 = x[i];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;num2 = y[j];mulit = num1 * num2;cur = mulit + pos[i + j + <span class="hljs-number">1</span>];pos[i + j + <span class="hljs-number">1</span>] = cur % <span class="hljs-number">10</span>;pos[i + j] += (cur / <span class="hljs-number">10</span>) | <span class="hljs-number">0</span>; <span class="hljs-comment">// 取10位以上部分</span>&#125;&#125;<span class="hljs-keyword">let</span> res = pos.join(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-built_in">console</span>.log(res);<span class="hljs-keyword">while</span> (res[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;0&quot;</span>) &#123;res = res.substring(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></li><li><p>保留精度加法</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fixAdd = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> len1 = x.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].length;<span class="hljs-keyword">const</span> len2 = y.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].length;<span class="hljs-keyword">const</span> maxLen = len1 &gt;= len2 ? len1 : len2;<span class="hljs-keyword">const</span> times = maxLen * <span class="hljs-number">10</span>;<span class="hljs-keyword">return</span> (x * times + y * times) / times;&#125;;</code></pre></div></li><li><p>满 9 加 1</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add1</span>(<span class="hljs-params">num</span>) </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dig = num.length - <span class="hljs-number">1</span>; dig &gt;= <span class="hljs-number">0</span>; dig--) &#123;<span class="hljs-keyword">if</span> (num[dig] === <span class="hljs-number">9</span>) &#123;num[dig] = <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;num[dig]++;<span class="hljs-keyword">return</span> num;&#125;&#125;num.unshift(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> num;&#125;</code></pre></div></li><li><p>将数组中的 0 全部移动到最后且非 0 部分保持原顺序</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">move0</span>(<span class="hljs-params">num</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (i &lt; num.length) &#123;<span class="hljs-keyword">if</span> (num[i] !== <span class="hljs-number">0</span>) &#123;[mim[i], num[j]] = [num[j], num[i]];i++;j++;&#125; <span class="hljs-keyword">else</span> &#123;i++;&#125;&#125;&#125;</code></pre></div></li><li><p>  数的次方（不使用内置库 pow</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果指数n是偶数，x^n = x^(n/2) * x^(n/2)</span><span class="hljs-comment">// 如果指数n是奇数，x^n = x * x^(n/2) * x^(n/2)</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myPow</span>(<span class="hljs-params">x, n</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_pow</span>(<span class="hljs-params">base, ex</span>) </span>&#123;<span class="hljs-keyword">if</span> (ex === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (ex === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base;<span class="hljs-keyword">const</span> splitPow = _pow(base, <span class="hljs-built_in">Math</span>.floor(ex / <span class="hljs-number">2</span>));<span class="hljs-keyword">return</span> ex % <span class="hljs-number">2</span> ? base * splitPow * splitPow : splitPow * splitPow;&#125;<span class="hljs-keyword">const</span> res = _pow(x, <span class="hljs-built_in">Math</span>.abs(n));<span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> / res : res;&#125;</code></pre></div><ul><li>  数字的开方 （不使用内置库 pow 和 X ** X</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  返回值只保留整数部分 ，8 =&gt; 2</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mySqrt</span>(<span class="hljs-params">num</span>) </span>&#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = num;<span class="hljs-comment">// 左右指针重合后跳出</span><span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-comment">// 计算一次当前的中间值</span><span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">Math</span>.floor((r - l) / <span class="hljs-number">2</span>) + l;<span class="hljs-comment">// const mid = (r-l) &gt;&gt; 1 + l</span><span class="hljs-keyword">const</span> curPow = mid * mid;<span class="hljs-keyword">if</span> (mid &lt;= num) &#123;l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> r;&#125;</code></pre></div><ul><li>  输出 1 到最大的 n 位数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment">  / <span class="hljs-doctag">@params </span>n=1 一位数，最大9，输出123456789</span><span class="hljs-comment">  / <span class="hljs-doctag">@params </span>n=2 两位数呀 最大99</span><span class="hljs-comment">  */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNumbers1</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-comment">//组合字符串</span><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;str += <span class="hljs-string">&quot;9&quot;</span>;n--;&#125;str = <span class="hljs-built_in">Number</span>(str);<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= str; i++) &#123;res.push(i);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printNumbers1</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-comment">//最大值就是 10^n-1......</span><span class="hljs-keyword">const</span> max = <span class="hljs-number">10</span> ** n - <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(max).fill(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res.map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> v + i);&#125;</code></pre></div><ul><li>  和为 s 的所有正数序列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  15</span><span class="hljs-comment"> * [1,2,3,4,5] [4,5,6] [7,8]</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-comment">// 直接用滑动窗口套</span><span class="hljs-keyword">let</span> l = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> r = <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> sum = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (l &lt; r) &#123;<span class="hljs-keyword">if</span> (sum === target) &#123;<span class="hljs-keyword">const</span> ret = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = j; i &lt;= r; i++) &#123;ret.push(i);&#125;sum -= l;l++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;sum -= l;l++;&#125; <span class="hljs-keyword">else</span> &#123;r++;sum += r;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 滑动窗口的另外一种实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">target</span>) </span>&#123;<span class="hljs-keyword">const</span> max = target % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? target / <span class="hljs-number">2</span> : <span class="hljs-built_in">Math</span>.round(target / <span class="hljs-number">2</span>);<span class="hljs-comment">// max右边都不可能满足</span><span class="hljs-comment">// t = 9</span><span class="hljs-comment">// max = 1，2，3，4，5，6[x]，7[x]，8[x]</span><span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) &#123;<span class="hljs-built_in">window</span>.push(i);sum += i;<span class="hljs-keyword">while</span> (sum &gt; target) &#123;sum -= <span class="hljs-built_in">window</span>.shift();&#125;<span class="hljs-keyword">if</span> (sum === target) &#123;<span class="hljs-built_in">window</span>.length &gt; <span class="hljs-number">1</span> &amp;&amp; res.push([...window]);<span class="hljs-comment">//<span class="hljs-doctag">FIXME:</span></span><span class="hljs-comment">// 注意！！</span><span class="hljs-comment">// push window的浅拷贝</span>&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>  数组中出现次数超过数组长度一半的元素</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 一定会是排序后的数组中点</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">majorityElement</span>(<span class="hljs-params">nums</span>) </span>&#123;nums = nums.sort();<span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">Math</span>.floor(nums.length / <span class="hljs-number">2</span>)];&#125;<span class="hljs-comment">// 投票记数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">majorityElement</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> vote = <span class="hljs-number">1</span>;<span class="hljs-comment">// 前后元素相同投票加1，不同减1，票数抵消则计算后面的元素</span><span class="hljs-keyword">let</span> mid = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<span class="hljs-keyword">if</span> (vote === <span class="hljs-number">1</span>) &#123;mid = num;&#125;vote += num === mid ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> mid;&#125;</code></pre></div><ul><li>  圆圈中最后剩下的数字</li></ul><p>0,1,···,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 朴朴素素超时方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n, m</span>) </span>&#123;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> (v += i));<span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (arr &gt; <span class="hljs-number">1</span>) &#123;pos = (pos + m - <span class="hljs-number">1</span>) % arr.length;arr.splice(pos, <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 找规律</span><span class="hljs-comment">// 约瑟夫环</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n, m</span>) </span>&#123;<span class="hljs-comment">// 0，1，2，3，4，5...n-1,n</span><span class="hljs-comment">// n = 1 时输出 0</span><span class="hljs-comment">// 反推得到公式</span><span class="hljs-comment">// n个数字,由于从0开始排列，则索引===数值</span><span class="hljs-comment">// 当前状态用f(n,m)表示，则上一轮为f(n-1,m)</span><span class="hljs-comment">// f(n,m) = (f(n-1,m)+m)%n</span><span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> (lastRemaining(n - <span class="hljs-number">1</span>, m) + m) % n;&#125;<span class="hljs-comment">// 也可以使用迭代实现</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n, m</span>) </span>&#123;<span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>; <span class="hljs-comment">// n为1时的 剩下0</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">// 每一轮都根据规律修改</span>pos = (pos + m) % i;&#125;<span class="hljs-keyword">return</span> pos;&#125;</code></pre></div><ul><li>  将数组中的奇数移动到前，偶数移动到后</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 对撞指针</span><span class="hljs-comment">// 分别寻找符合条件的数</span><span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,r = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt; r) &#123;<span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) l++;<span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) r--;[nums[l], nums[r]] = [nums[r], nums[l]];&#125;<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">exchange</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 快慢指针</span><span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>,fast = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<span class="hljs-keyword">if</span> (nums[fast] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123;[nums[slow], nums[fast]] = [num[fast], nums[slow]];slow++;&#125;fast++;&#125;<span class="hljs-keyword">return</span> nums;&#125;</code></pre></div><ul><li>  实现前缀树 prefixTree</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PrefixTree</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">this</span>.tree = &#123;&#125;;&#125;PrefixTree.prototype.insert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) </span>&#123;<span class="hljs-comment">// 依次将单词的每个字母向tree对象中递归添加属性</span><span class="hljs-comment">// msy= &gt;</span><span class="hljs-comment">// &#123;m:&#123;s:&#123;y:&#123;isEnd:true&#125;&#125;&#125;&#125;</span><span class="hljs-keyword">let</span> node = <span class="hljs-built_in">this</span>.tree;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> word) &#123;<span class="hljs-keyword">if</span> (!node[n]) node[n] = &#123;&#125;;node = node[n];&#125;node.isEnd = <span class="hljs-literal">true</span>;&#125;;PrefixTree.prototype.loop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) </span>&#123;<span class="hljs-keyword">let</span> node = <span class="hljs-built_in">this</span>.tree;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> word) &#123;<span class="hljs-keyword">if</span> (!node[n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;node = node[n];&#125;<span class="hljs-keyword">return</span> node;&#125;;PrefixTree.prototype.search = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) </span>&#123;<span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">this</span>.loop(word);<span class="hljs-keyword">return</span> ret !== <span class="hljs-literal">undefined</span> &amp;&amp; ret.isEnd === <span class="hljs-literal">true</span>;&#125;;PrefixTree.prototype.startWith = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.loop(prefix);&#125;;</code></pre></div><ul><li>青蛙跳台阶/斐波那契数列<blockquote><p>注意别搞混了，fibonacci 数列排列是固定的<br>fib 数列 [0,1,1,2,3]<br>青蛙跳法 [1,1,2,3,5]</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numWays</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> cur = <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> pre = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (i++ &lt; n) &#123;<span class="hljs-comment">// 从n=3时迭代推导</span>res = cur + pre;pre = cur;cur = res;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numWays</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-comment">// 斐波那契数列</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;arr[i] = arr[i - <span class="hljs-number">1</span>] + arr[i - <span class="hljs-number">2</span>];&#125;<span class="hljs-keyword">return</span> arr[i];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fibonacci</span>(<span class="hljs-params">n</span>) </span>&#123;<span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> Fibonacci(n - <span class="hljs-number">1</span>) + Fibonacci(n - <span class="hljs-number">2</span>);&#125;<span class="hljs-comment">// 尾递归版本</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fibonacci</span>(<span class="hljs-params">n, b1 = <span class="hljs-number">1</span>, b2 = <span class="hljs-number">1</span>, c = <span class="hljs-number">3</span></span>) </span>&#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (n === <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> c;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> Fibonacci(n, b2, b1 + b2, c + <span class="hljs-number">1</span>);&#125;&#125;&#125;</code></pre></div><ul><li>  连续子数组的和的最大值</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-comment">// 用dp记录该位置作为子数组末尾的累加值</span><span class="hljs-comment">// [nums[0],nums[1]],dp[1] = num[0] + num[1]</span><span class="hljs-comment">// dp[2] = dp[1] + nums[2]</span><span class="hljs-comment">// 同时判断前一dp的值正负</span><span class="hljs-comment">// 前一个dp为正则 当前dp = 前dp + 当前nums</span><span class="hljs-comment">// 如果为负直接丢弃</span><span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> dpi = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;dpi = dpi &gt; <span class="hljs-number">0</span> ? dpi + nums[i] : nums[i];max = <span class="hljs-built_in">Math</span>.max(max, dpi);&#125;<span class="hljs-keyword">return</span> max;&#125;</code></pre></div><ul><li>  反转嵌套数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 已知数组 a=[1,[2,[3,[4,null]]]], 实现数组 b=[4,[3,[2,[1,null]]]] ，考虑n级嵌套的情况</span><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-literal">null</span>]]]];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseArray</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverse</span>(<span class="hljs-params">arr, temp</span>) </span>&#123;<span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]]</span><span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1] = [2,[3,[4,null]]]</span><span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1][1] = [3,[4,null]]</span><span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1][1][1] = [4,null]</span><span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> [arr[<span class="hljs-number">0</span>], temp];<span class="hljs-comment">// return</span>&#125;temp = temp ? [arr[<span class="hljs-number">0</span>], temp] : [arr[<span class="hljs-number">0</span>], <span class="hljs-literal">null</span>];<span class="hljs-comment">// temp = [1,null]</span><span class="hljs-comment">// temp = [2,[1,null]]</span><span class="hljs-comment">// temp = [3,[2,[1,null]]]</span><span class="hljs-keyword">return</span> reverse(arr[<span class="hljs-number">1</span>], temp); <span class="hljs-comment">// 递归进嵌套</span>&#125;<span class="hljs-keyword">return</span> reverse(arr, <span class="hljs-literal">null</span>);&#125;<span class="hljs-built_in">console</span>.log(reverseArray(a));</code></pre></div><ul><li><p>约瑟夫环</p><p>  0,1,···,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。<br>  例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归公式</span><span class="hljs-comment">// f(n,m) = (f(n-1,m)+m)%n 本轮索引=上轮索引+m%n</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n, m</span>) </span>&#123;<span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> (lastRemaining(n - <span class="hljs-number">1</span>, m) + m) % n;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastRemaining</span>(<span class="hljs-params">n, m</span>) </span>&#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= m; j++) &#123;i = (i + m) % j;&#125;<span class="hljs-keyword">return</span> i;&#125;</code></pre></div><ul><li><p>连续子数组的最大和</p><p>  输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。<br>  要求时间复杂度为 O(n)。</p><div class="hljs code-wrapper"><pre><code class="hljs">  示例1:  输入: nums = [-2,1,-3,4,-1,2,1,-5,4]  输出: 6  解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre></div></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 状态转移</span><span class="hljs-comment">// 由连续元素来求和</span><span class="hljs-comment">// dp[i] 位置的累加值由dp[i-1]决定，dp[i-1]不为负则加上dp[i-1]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">const</span> dp = [nums[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;dp[i] = dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? nums[i] + dp[i - <span class="hljs-number">1</span>] : nums[i];<span class="hljs-keyword">if</span> (dp[i] &gt; max) max = dp[i];&#125;<span class="hljs-keyword">return</span> max;&#125;<span class="hljs-comment">// 使用变量记忆dp[i-1]的值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxSubArray</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> preDp = <span class="hljs-number">0</span>; <span class="hljs-comment">// init 0</span><span class="hljs-keyword">let</span> curDp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> nums) &#123;curDp = n;curDp += preDp &gt; <span class="hljs-number">0</span> ? preDp : <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (curDp &gt; max) max = curDp;preDp = curDp;&#125;<span class="hljs-keyword">return</span> max;&#125;</code></pre></div><ul><li>  [0 ~ n-1]中缺省的值</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 正确的数组应该value===index</span><span class="hljs-comment">// [0,1,3] =&gt; 2</span><span class="hljs-comment">// [1,2] =&gt; 0</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">missingNumber</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<span class="hljs-keyword">if</span> (i !== nums[i]) <span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">missingNumber</span>(<span class="hljs-params">nums</span>) </span>&#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = nums.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &gt;= r) &#123;<span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">Math</span>.floor((r - l) / <span class="hljs-number">2</span>) + l;<span class="hljs-keyword">if</span> (mid === nums[mid]) &#123;<span class="hljs-comment">// 中间位置数值正确，说明缺省数值在右边</span>l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 中间数值已经不正确，说明缺省数值在左边</span>r = mid - <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-comment">// 跳出while后r在l的左边</span><span class="hljs-keyword">return</span> l;&#125;</code></pre></div><ul><li>  输入一个矩形，顺时针打印矩形其中元素</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> matrix = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">spiralOrder</span>(<span class="hljs-params">matrix</span>) </span>&#123;<span class="hljs-keyword">const</span> rowLen = matrix.length;<span class="hljs-keyword">const</span> columnLen = matrix[<span class="hljs-number">0</span>].length;<span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> bottom = rowLen - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = columnLen - <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = left; a &lt;= right; a++) &#123;res.push(matrix[top][a]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b = top + <span class="hljs-number">1</span>; b &lt;= bottom; b++) &#123;res.push(matrix[b][right]);&#125;<span class="hljs-keyword">if</span> (top &gt;= bottom || left &gt;= right) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = right - <span class="hljs-number">1</span>; c &gt;= left; c--) &#123;res.push(matrix[bottom][c]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> d = bottom; d &gt;= top; d--) &#123;res.push(matrix[left][d]);&#125;left++;right--;top++;bottom--;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li><p>电商 SKU 全排列/笛卡尔积</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> attrs = &#123;names: [<span class="hljs-string">&quot;iPhone X&quot;</span>, <span class="hljs-string">&quot;iPhone XS&quot;</span>, <span class="hljs-string">&quot;iPhone 11&quot;</span>],colors: [<span class="hljs-string">&quot;黑色&quot;</span>, <span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-string">&quot;红色&quot;</span>],storage: [<span class="hljs-string">&quot;64g&quot;</span>, <span class="hljs-string">&quot;128G&quot;</span>, <span class="hljs-string">&quot;256g&quot;</span>],&#125;;<span class="hljs-keyword">const</span> descartes = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunks</span>) </span>&#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">const</span> keysName = <span class="hljs-built_in">Object</span>.keys(chunks);<span class="hljs-comment">// 由于是操作对象,多增加一个keys数组</span><span class="hljs-keyword">const</span> helper = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunkIndex, prev</span>) </span>&#123;<span class="hljs-keyword">let</span> curKey = keysName[chunkIndex];<span class="hljs-keyword">let</span> curChunk = chunks[curKey];<span class="hljs-keyword">let</span> isLast = chunkIndex === keysName.length - <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> curChunk) &#123;<span class="hljs-keyword">const</span> cur = prev.concat(<span class="hljs-string">`<span class="hljs-subst">$&#123;curKey&#125;</span>:<span class="hljs-subst">$&#123;val&#125;</span>`</span>);<span class="hljs-keyword">if</span> (isLast) &#123;<span class="hljs-comment">// 如果已经处理到数组的最后一项了 则把拼接的结果放入返回值中</span>res.push(cur);&#125; <span class="hljs-keyword">else</span> &#123;helper(chunkIndex + <span class="hljs-number">1</span>, cur);&#125;&#125;&#125;;<span class="hljs-comment">// 从属性数组下标为 0 开始处理</span><span class="hljs-comment">// 并且此时的 prev 是个空数组</span>helper(<span class="hljs-number">0</span>, []);<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div></li><li><p>1 到 n 的数字组成 k 长度的数组的所有组合</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入: n = 4, k = 2;</span><span class="hljs-comment">// 输出: [[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span>(<span class="hljs-params">n, k</span>) </span>&#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">helper</span>(<span class="hljs-params">start, prev</span>) </span>&#123;<span class="hljs-keyword">const</span> len = prev.length;<span class="hljs-keyword">if</span> (len === k) &#123;res.push(prev);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 剪枝,还能剩下几个空位</span><span class="hljs-keyword">const</span> rest = k - len;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (n - i + <span class="hljs-number">1</span> &lt; rest) &#123;<span class="hljs-comment">// 递增关系+1</span><span class="hljs-comment">// n是最大数字,减去当前数字+1</span><span class="hljs-keyword">return</span>; <span class="hljs-comment">// 往后的i都不会符合,直接return</span>&#125;helper(i + <span class="hljs-number">1</span>, prev.concat(i));&#125;&#125;helper(<span class="hljs-number">1</span>, []);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></li><li><p>请你判断一个  9 x 9 的数独是否有效。根据以下规则 ，验证已经填入的数字是否有效</p><ol><li>数字  1-9  在每一行只能出现一次。</li><li>数字  1-9  在每一列只能出现一次。</li><li>数字  1-9  在每一个以粗实线分隔的  3x3  宫内只能出现一次。（请参考示例图）</li><li>空白为’.’</li></ol>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">board = [[<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>],];<span class="hljs-comment">//输出：true</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidSudoku</span>(<span class="hljs-params">arr</span>) </span>&#123;<span class="hljs-comment">// 用最直白的哈希表，由于要处理顺序递增数组，可以默认全部是0</span><span class="hljs-comment">// 记录index+1位置的数有没有出现过</span><span class="hljs-keyword">const</span> rows = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">9</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">9</span>).fill(<span class="hljs-number">0</span>));<span class="hljs-keyword">const</span> columns = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">9</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">9</span>).fill(<span class="hljs-number">0</span>));<span class="hljs-comment">// 9*9的小方块</span><span class="hljs-keyword">const</span> blocks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>).fill(<span class="hljs-number">0</span>).map(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">9</span>).fill(<span class="hljs-number">0</span>)));<span class="hljs-comment">// 开始循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<span class="hljs-keyword">const</span> cur = board[i][j];<span class="hljs-keyword">if</span> (cur === <span class="hljs-string">&quot;.&quot;</span>) countine; <span class="hljs-comment">//跳过</span><span class="hljs-keyword">const</span> index = +cur - <span class="hljs-number">1</span>;rows[i][index]++;columns[j][index]++;blocks[~~(i / <span class="hljs-number">3</span>)][~~[j / <span class="hljs-number">3</span>]][index]++;<span class="hljs-keyword">if</span> (rows[i][index] &gt; <span class="hljs-number">1</span> || columns[j][index] &gt; <span class="hljs-number">1</span> || blocks[~~(i / <span class="hljs-number">3</span>)][~~[j / <span class="hljs-number">3</span>]][index] &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div></li><li><p>实现 LRU 缓存结构 （最近最少访问</p>  <div class="hljs code-wrapper"><pre><code class="hljs `javascript">function LRUCache(capacity)&#123;this.capacity &#x3D; capacitythis.cache &#x3D; new Map()&#125;LRUCache.prototype.get &#x3D; function(key)&#123;if(this.cache.has(key))&#123;const val &#x3D; this.cache.get(key)this.cache.delete(key)this.cache.set(key,val)return val&#125;else&#123;return -1&#125;&#125;LRUCache.prototype.put &#x3D; function(key,value)&#123;if(this.cache.has(key))&#123;this.cache.delete(key)&#125;this.cache.set(key,value)&#x2F;&#x2F; 如果容量超标if(this.cache.size &gt; this.capacity)&#123;&#x2F;&#x2F; 删除map中的第一个const latestKey &#x3D; this.cache.keys().next().valuethis.cache.delete(latestKey)&#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络分层模型</title>
    <link href="/2022/02/24/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/02/24/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p><code>OSI参考模型（OSI/RM）</code>的全称是开放系统互连参考模型<code>（Open System Interconnection Reference Model，OSI/RM）</code>，它是由国际标准化组织（International Standard Organization，ISO）提出的一个网络系统互连模型。</p><ul><li><p>在这个 OSI 七层模型中，每一层都为其上一层提供服务和访问接口</p></li><li><p>不同主机之间的相同层称为<strong>对等层</strong></p></li><li></li><li><p>对等层之间互相通信需要遵守一定的规则，如通信的内容、通信的方式，我们将其称为<strong>协议</strong>（Protocol）。</p></li><li><p>我们将某个主机上运行的某种协议的集合称为<strong>协议栈</strong>。主机正是利用这个协议栈来接收和发送数据的。</p></li><li><p>OSI 参考模型通过将协议栈划分为不同的层次，可以简化问题的分析、处理过程以及网络系统设计的复杂性。</p></li></ul><h2 id="OSI-参考模型中各层的作用"><a href="#OSI-参考模型中各层的作用" class="headerlink" title="OSI 参考模型中各层的作用"></a>OSI 参考模型中各层的作用</h2><h3 id="物理层Physical-Layer"><a href="#物理层Physical-Layer" class="headerlink" title="物理层Physical Layer"></a>物理层<code>Physical Layer</code></h3><ul><li>利用传输介质为数据链路层提供物理信道，传输二进制数据</li><li>数据的单位称为比特<code>bit</code></li></ul><h3 id="数据链路层Data-Link-Layer"><a href="#数据链路层Data-Link-Layer" class="headerlink" title="数据链路层Data Link Layer"></a>数据链路层<code>Data Link Layer</code></h3><blockquote><p>相邻节点</p></blockquote><ul><li>物理地址寻址、数据的成帧、流量控制、检错重发等。控制帧在物理信道的传输</li><li>数据的单位称为帧<code>frame</code></li><li>协议<ul><li><code>ARP</code>（Address Resolution Protocol，地址解析协议）IP地址映射到MAC地址</li><li><code>RARP</code>（Reverse Address Resolution Protocol，逆地址解析协议）</li></ul></li></ul><h3 id="网络层Network-Layer"><a href="#网络层Network-Layer" class="headerlink" title="网络层Network Layer"></a>网络层<code>Network Layer</code></h3><blockquote><p>不相邻节点</p></blockquote><ul><li>将传输层数据封装成包，并根据IP地址选择路由路径并在网络中传输</li><li>数据的单位称为包<code>packet</code></li><li>协议<ul><li><code>IP</code> 协议（Internet Protocol，网际协议）<ol><li><code>IP协议</code>是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则</li><li><code>IP协议</code>屏蔽了下层各种物理子网的差异，向上层提供给统一格式的<code>IP数据报</code></li><li><code>IP数据报</code>传送使用<code>非连接式</code>的传送方式。非连接式的传送方式是指IP传送时，源设备与目的设备双方不必事先连接，即可将IP数据报送达。即源设备完全不用理会目的设备，而只是单纯地将IP数据报逐一送出。至于目的设备是否收到每个信息包、是否收到正确的信息包等，则由上层的协议(例如<code>TCP</code>)来负责检查</li></ol></li><li><code>ICMP</code> 协议（Internet Control Message Protocol，网际控制报文协议）</li><li><code>IGMP</code> 协议（Internet Group Management Protocol，网际组管理协议）</li></ul></li></ul><h3 id="传输层Transport-Layer"><a href="#传输层Transport-Layer" class="headerlink" title="传输层Transport Layer"></a>传输层<code>Transport Layer</code></h3><ul><li><p>提供端对端的接口，向两个主机中进程之间的通信提供服务，根据协议可向会话层交付可靠的网络连接，同时对于高层屏蔽了低层的技术细节</p></li><li><p>数据的单位称为数据段<code>Segment</code>或报文</p></li><li><p>协议</p><ul><li><p><code>TCP</code>（Transmission Control Protocol）传输控制协议</p><ol><li>面向连接（握手繁琐）</li><li>可靠交付，保证数据的完整和顺序无差错</li><li>单播点对点</li><li>头部较大——20字节</li><li>队头阻塞</li></ol></li><li><p><code>UDP</code>（User Datagram Protocol）用户数据协议</p><ol><li>面向报文（无需握手，对应用层交下来的报文，添加首部后直接乡下交付为IP层）</li><li>不可靠交付，数据发送不受丢包和网络波动影响</li><li>单播和广播，</li><li>头部较小——8字节</li><li>直播，在线会议，语音，即时通信</li><li>没有拥塞机制</li></ol></li></ul></li></ul><h3 id="会话层Session-Layer"><a href="#会话层Session-Layer" class="headerlink" title="会话层Session Layer"></a>会话层<code>Session Layer</code></h3><ul><li>管理表示层之间的连接（会话）</li><li>组织和协调两个会话进程之间的通信,并对数据交换进行管理</li></ul><h3 id="表示层Presentation-Layer"><a href="#表示层Presentation-Layer" class="headerlink" title="表示层Presentation Layer"></a>表示层<code>Presentation Layer</code></h3><ul><li>处理数据编码、数据格式转换和加密解密</li></ul><h3 id="应用层Application-Layer"><a href="#应用层Application-Layer" class="headerlink" title="应用层Application Layer"></a>应用层<code>Application Layer</code></h3><ul><li>应用程序访问网络服务的接口</li><li>协议<ul><li><code>HTTP</code>（Hyper Text Transfer Protocol，超文本传输协议）</li><li><code>FTP</code>（File Transfer Protocol，文件传输协议）</li><li>邮件相关的<code>POP3</code>（Post Office Protocol - V3）和<code>SMTP</code>（Simple Mail Transfer Protocol，简单邮件传输协议）</li></ul></li></ul><hr><h1 id="TCP-IP-分层模型"><a href="#TCP-IP-分层模型" class="headerlink" title="TCP/IP 分层模型"></a>TCP/IP 分层模型</h1><ul><li>TCP/IP 分层模型（TCP/IP Layering Model）被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model)</li></ul><h2 id="TCP-IP-中各层的作用"><a href="#TCP-IP-中各层的作用" class="headerlink" title="TCP/IP 中各层的作用"></a>TCP/IP 中各层的作用</h2><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><blockquote><p>对应着 OSI/RM 的数据链路层+物理层</p></blockquote><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><blockquote><p>对应OSI/RM 的表示层+会话层+应用层</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟列表的简单实现</title>
    <link href="/2022/02/24/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/24/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ref:[<a href="https://mp.weixin.qq.com/s/8uttkBw-dwYXsybKePQ3nA]">https://mp.weixin.qq.com/s/8uttkBw-dwYXsybKePQ3nA]</a></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>虚拟列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">      <span class="hljs-selector-tag">html</span> &#123;</span><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span>      &#125;<span class="css">      <span class="hljs-selector-tag">body</span> &#123;</span><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span>      &#125;      #app &#123;<span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span>      &#125;      .visible-area&#123;<span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span>      &#125;      .infinite-list-container &#123;<span class="css">        <span class="hljs-attribute">overflow</span>: auto;</span><span class="css">        <span class="hljs-attribute">position</span>: relative;</span><span class="css">        -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch;</span><span class="css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;</span>      &#125;      .infinite-list-phantom &#123;<span class="css">        <span class="hljs-attribute">position</span>: absolute;</span><span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;</span>      &#125;      .infinite-list &#123;<span class="css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="css">        <span class="hljs-attribute">position</span>: absolute;</span>      &#125;      .infinite-list-item &#123;<span class="css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;</span><span class="css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#555</span>;</span><span class="css">        <span class="hljs-comment">/* box-sizing: border-box; */</span></span><span class="css">        <span class="hljs-attribute">border</span>:<span class="hljs-number">6px</span> solid gray;</span><span class="css">        <span class="hljs-comment">/* height:200px; */</span></span>      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;visible-area&quot;</span>&gt;</span>        我是可视区域              <span class="hljs-tag">&lt;<span class="hljs-name">virtual-list</span> <span class="hljs-attr">:list-data</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">:estimated-item-size</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">:buffer-scale</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">virtual-list</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">virtual-list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/Faker/3.1.0/faker.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript">      <span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&quot;</span>;</span><span class="javascript">      Vue.component(<span class="hljs-string">&quot;virtual-list&quot;</span>, &#123;</span>        template: `<span class="javascript">        &lt;div ref=<span class="hljs-string">&quot;list&quot;</span> :style=<span class="hljs-string">&quot;&#123;height&#125;&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;infinite-list-container&quot;</span> @scroll=<span class="hljs-string">&quot;scrollEvent($event)&quot;</span>&gt;</span><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;phantom&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;infinite-list-phantom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><span class="javascript">          &lt;div ref=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;infinite-list&quot;</span>&gt;</span><span class="javascript">            &lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;infinite-list-item&quot;</span> ref=<span class="hljs-string">&quot;items&quot;</span> :id=<span class="hljs-string">&quot;item.id&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in visibleData&quot;</span>&gt;</span><span class="handlebars"><span class="xml">              <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.id</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.value</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="handlebars"><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><span class="handlebars"><span class="xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><span class="handlebars"><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span>        `,        props: &#123;<span class="javascript">          <span class="hljs-comment">//列表数据</span></span>          listData: &#123;<span class="javascript">            type: <span class="hljs-built_in">Array</span>,</span><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-function">() =&gt;</span> [],</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//预估高度</span></span>          estimatedItemSize: &#123;<span class="javascript">            type: <span class="hljs-built_in">Number</span>,</span><span class="javascript">            required: <span class="hljs-literal">true</span>,</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//缓冲区比例</span></span>          bufferScale: &#123;<span class="javascript">            type: <span class="hljs-built_in">Number</span>,</span><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-number">1</span>,</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//容器高度 100px or 50vh</span></span>          height: &#123;<span class="javascript">            type: <span class="hljs-built_in">String</span>,</span><span class="javascript">            <span class="hljs-keyword">default</span>: <span class="hljs-string">&quot;100%&quot;</span>,</span>          &#125;,        &#125;,        computed: &#123;<span class="javascript">          <span class="hljs-comment">// 可视区域内能显示几条数据</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">visibleCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">this</span>.screenHeight / <span class="hljs-built_in">this</span>.estimatedItemSize);</span>          &#125;,<span class="javascript">          <span class="hljs-comment">// 可视区域上方数据条数</span></span><span class="javascript">          <span class="hljs-comment">// Math.min取缓冲区值</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">aboveCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">this</span>.start, <span class="hljs-built_in">this</span>.bufferScale * <span class="hljs-built_in">this</span>.visibleCount);</span>          &#125;,<span class="javascript">          <span class="hljs-comment">// 可视区域下方数据条数</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">belowCount</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(</span><span class="javascript">              <span class="hljs-built_in">this</span>.listData.length - <span class="hljs-built_in">this</span>.end,</span><span class="javascript">              <span class="hljs-built_in">this</span>.bufferScale * <span class="hljs-built_in">this</span>.visibleCount</span>            );          &#125;,<span class="javascript">          <span class="hljs-function"><span class="hljs-title">visibleData</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-comment">// 需要渲染的数据 = 显示的数据加上上下缓冲区</span></span><span class="javascript">            <span class="hljs-keyword">let</span> start = <span class="hljs-built_in">this</span>.start - <span class="hljs-built_in">this</span>.aboveCount;</span><span class="javascript">            <span class="hljs-keyword">let</span> end = <span class="hljs-built_in">this</span>.end + <span class="hljs-built_in">this</span>.belowCount;</span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.listData.slice(start, end);</span>          &#125;,        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-built_in">this</span>.initPositions();</span>        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-built_in">this</span>.screenHeight = <span class="hljs-built_in">this</span>.$el.clientHeight;</span><span class="javascript">          <span class="hljs-built_in">this</span>.start = <span class="hljs-number">0</span>;</span><span class="javascript">          <span class="hljs-built_in">this</span>.end = <span class="hljs-built_in">this</span>.start + <span class="hljs-built_in">this</span>.visibleCount;</span>        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">updated</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.$refs.items || !<span class="hljs-built_in">this</span>.$refs.items.length) &#123;</span><span class="javascript">              <span class="hljs-keyword">return</span>;</span>            &#125;<span class="javascript">            <span class="hljs-comment">//获取真实元素大小，修改对应的尺寸缓存</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.updateItemsSize();</span><span class="javascript">            <span class="hljs-comment">//更新列表总高度</span></span><span class="javascript">            <span class="hljs-keyword">let</span> height = <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.positions.length - <span class="hljs-number">1</span>].bottom;</span><span class="javascript">            <span class="hljs-built_in">this</span>.$refs.phantom.style.height = height + <span class="hljs-string">&quot;px&quot;</span>;</span><span class="javascript">            <span class="hljs-comment">//更新真实偏移量</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.setStartOffset();</span>          &#125;);        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            <span class="hljs-comment">//可视区域高度</span></span>            screenHeight: 0,<span class="javascript">            <span class="hljs-comment">//起始索引</span></span>            start: 0,<span class="javascript">            <span class="hljs-comment">//结束索引</span></span>            end: 0,          &#125;;        &#125;,        methods: &#123;<span class="javascript">          <span class="hljs-function"><span class="hljs-title">initPositions</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.positions = <span class="hljs-built_in">this</span>.listData.map(<span class="hljs-function">(<span class="hljs-params">d, index</span>) =&gt;</span> (&#123;</span>              index,<span class="javascript">              height: <span class="hljs-built_in">this</span>.estimatedItemSize,</span><span class="javascript">              top: index * <span class="hljs-built_in">this</span>.estimatedItemSize,</span><span class="javascript">              bottom: (index + <span class="hljs-number">1</span>) * <span class="hljs-built_in">this</span>.estimatedItemSize,</span>            &#125;));          &#125;,<span class="javascript">          <span class="hljs-comment">//获取列表起始索引</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">getStartIndex</span>(<span class="hljs-params">scrollTop = <span class="hljs-number">0</span></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-comment">//二分法查找</span></span><span class="javascript">            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.binarySearch(<span class="hljs-built_in">this</span>.positions, scrollTop);</span>          &#125;,<span class="javascript">          <span class="hljs-function"><span class="hljs-title">binarySearch</span>(<span class="hljs-params">list, value</span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;</span><span class="javascript">            <span class="hljs-keyword">let</span> end = list.length - <span class="hljs-number">1</span>;</span><span class="javascript">            <span class="hljs-keyword">let</span> tempIndex = <span class="hljs-literal">null</span>;</span><span class="javascript">            <span class="hljs-keyword">while</span> (start &lt;= end) &#123;</span><span class="javascript">              <span class="hljs-keyword">let</span> midIndex = <span class="hljs-built_in">parseInt</span>((start + end) / <span class="hljs-number">2</span>);</span><span class="javascript">              <span class="hljs-keyword">let</span> midValue = list[midIndex].bottom;</span>              if (midValue === value) &#123;<span class="javascript">                <span class="hljs-keyword">return</span> midIndex + <span class="hljs-number">1</span>;</span><span class="javascript">              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &lt; value) &#123;</span>                start = midIndex + 1;<span class="javascript">              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &gt; value) &#123;</span><span class="javascript">                <span class="hljs-keyword">if</span> (tempIndex === <span class="hljs-literal">null</span> || tempIndex &gt; midIndex) &#123;</span>                  tempIndex = midIndex;                &#125;                end = end - 1;              &#125;            &#125;<span class="javascript">            <span class="hljs-keyword">return</span> tempIndex;</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//更新列表项的当前尺寸</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">updateItemsSize</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> nodes = <span class="hljs-built_in">this</span>.$refs.items;</span><span class="javascript">            nodes.forEach(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;</span><span class="javascript">              <span class="hljs-keyword">let</span> rect = node.getBoundingClientRect();</span><span class="javascript">              <span class="hljs-keyword">let</span> height = rect.height;</span><span class="javascript">              <span class="hljs-keyword">let</span> index = +node.id.slice(<span class="hljs-number">1</span>);</span><span class="javascript">              <span class="hljs-keyword">let</span> oldHeight = <span class="hljs-built_in">this</span>.positions[index].height;</span><span class="javascript">              <span class="hljs-keyword">let</span> dValue = oldHeight - height;</span><span class="javascript">              <span class="hljs-comment">//存在差值</span></span>              if (dValue) &#123;<span class="javascript">                <span class="hljs-built_in">this</span>.positions[index].bottom =</span><span class="javascript">                  <span class="hljs-built_in">this</span>.positions[index].bottom - dValue;</span><span class="javascript">                <span class="hljs-built_in">this</span>.positions[index].height = height;</span><span class="javascript">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = index + <span class="hljs-number">1</span>; k &lt; <span class="hljs-built_in">this</span>.positions.length; k++) &#123;</span><span class="javascript">                  <span class="hljs-built_in">this</span>.positions[k].top = <span class="hljs-built_in">this</span>.positions[k - <span class="hljs-number">1</span>].bottom;</span><span class="javascript">                  <span class="hljs-built_in">this</span>.positions[k].bottom = <span class="hljs-built_in">this</span>.positions[k].bottom - dValue;</span>                &#125;              &#125;            &#125;);          &#125;,<span class="javascript">          <span class="hljs-comment">//计算偏移量并translate</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">setStartOffset</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> startOffset;</span><span class="javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.start &gt;= <span class="hljs-number">1</span>) &#123;</span><span class="javascript">              <span class="hljs-keyword">let</span> size =</span><span class="javascript">                <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start].top -</span><span class="javascript">                (<span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start - <span class="hljs-built_in">this</span>.aboveCount]</span><span class="javascript">                  ? <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start - <span class="hljs-built_in">this</span>.aboveCount].top</span>                  : 0);<span class="javascript">              startOffset = <span class="hljs-built_in">this</span>.positions[<span class="hljs-built_in">this</span>.start - <span class="hljs-number">1</span>].bottom - size;</span><span class="javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span>              startOffset = 0;            &#125;<span class="javascript">            <span class="hljs-built_in">this</span>.$refs.content.style.transform = <span class="hljs-string">`translate3d(0,<span class="hljs-subst">$&#123;startOffset&#125;</span>px,0)`</span>;</span>          &#125;,<span class="javascript">          <span class="hljs-comment">//滚动事件</span></span><span class="javascript">          <span class="hljs-function"><span class="hljs-title">scrollEvent</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-comment">//当前滚动位置</span></span><span class="javascript">            <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-built_in">this</span>.$refs.list.scrollTop;</span><span class="javascript">            <span class="hljs-comment">// let startBottom = this.positions[this.start - ]</span></span><span class="javascript">            <span class="hljs-comment">//此时的开始索引</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.start = <span class="hljs-built_in">this</span>.getStartIndex(scrollTop);</span><span class="javascript">            <span class="hljs-comment">//此时的结束索引</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.end = <span class="hljs-built_in">this</span>.start + <span class="hljs-built_in">this</span>.visibleCount;</span><span class="javascript">            <span class="hljs-comment">//此时的偏移量</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.setStartOffset();</span>          &#125;,        &#125;,      &#125;);<span class="javascript">      <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&quot;#app&quot;</span>,</span>        data: &#123;          dataLength: 100000,          list: [],        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; id &lt; <span class="hljs-built_in">this</span>.dataLength; ++id) &#123;</span><span class="javascript">            <span class="hljs-built_in">this</span>.list.push(&#123;</span>              id,              value: faker.lorem.sentences(),            &#125;);          &#125;        &#125;,      &#125;);    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/02/24/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/02/24/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>数组需要申请连续的内存空间，链表可以使用“零散的”内存空间</li><li>插入/删除时间复杂度<code>O(1)</code></li><li>随机访问时间复杂度<code>O(n)</code></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>零散的内存块称为<code>结点</code></li><li>记录下一个结点地址的指针叫做<code>后继指针next</code></li><li><code>headNode</code></li><li><code>tailNode.next = null</code></li></ul><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul><li>单链表</li><li>循环链表</li></ul><p>  <code>tailNode.next = headNode</code></p><p>  适合处理环状结构的数据</p><ul><li><p>双向链表</p><p>结点拥有两个指针<br><code>curNode.prev</code><br><code>curNode.next</code></p><p><code>O(1)</code>时间复杂度即可访问前序结点</p></li><li><p>双向循环链表</p><p><code>headNode.prev = tailNode</code><br><code>tailNode.next = headNode</code></p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单向链表</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">linkedList</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 追加</span>  <span class="hljs-function"><span class="hljs-title">append</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> Node(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) &#123;      <span class="hljs-built_in">this</span>.head = n;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.next) &#123;        cur = cur.next;      &#125;      cur.next = n;      <span class="hljs-built_in">this</span>.length++;    &#125;  &#125;  <span class="hljs-comment">// 查找</span>  <span class="hljs-function"><span class="hljs-title">search</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.element === element) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;      cur = cur.next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 插入</span>  <span class="hljs-comment">// position之前插入新node</span>  <span class="hljs-function"><span class="hljs-title">insert</span>(<span class="hljs-params">position, element</span>)</span> &#123;    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-built_in">this</span>.length) &#123;      <span class="hljs-keyword">let</span> n = <span class="hljs-keyword">new</span> Node(element);      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;        n.next = <span class="hljs-built_in">this</span>.head;        <span class="hljs-built_in">this</span>.head = n;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (index &lt; position) &#123;          pre = cur;          cur = cur.next;          index++;        &#125;        pre.next = n;        n.next = cur;      &#125;      <span class="hljs-built_in">this</span>.length++;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-comment">// 删除</span>  <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,      pre = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.element === element) &#123;        cur = cur.next;        pre.next = cur;        <span class="hljs-built_in">this</span>.length --       &#125;      pre = cur      cur = cur.next;    &#125;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element</span>)</span> &#123;    <span class="hljs-built_in">this</span>.element = element;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;  &#125;&#125;<span class="hljs-comment">// 双向链表</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DubLinkedList</span>(<span class="hljs-params">params</span>) </span>&#123;  <span class="hljs-keyword">const</span> Node = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) </span>&#123;    <span class="hljs-built_in">this</span>.prev = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;    <span class="hljs-built_in">this</span>.element = element;  &#125;;  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>;  <span class="hljs-built_in">this</span>.length = <span class="hljs-number">0</span>;  <span class="hljs-built_in">this</span>.append = <span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head;    <span class="hljs-keyword">if</span> (!cur) &#123;      <span class="hljs-built_in">this</span>.head = newNode;      <span class="hljs-built_in">this</span>.tail = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.next) &#123;        cur = cur.next;      &#125;      cur.next = newNode      newNode.prev = cur      <span class="hljs-built_in">this</span>.tail = newNode    &#125;    <span class="hljs-built_in">this</span>.length++;  &#125;  <span class="hljs-built_in">this</span>.insert = <span class="hljs-function">(<span class="hljs-params">position,element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position &lt;=<span class="hljs-built_in">this</span>.length)&#123;      <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> Node(element)      <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//头</span>        <span class="hljs-keyword">if</span>(!cur)&#123;          <span class="hljs-built_in">this</span>.head = newNode;          <span class="hljs-built_in">this</span>.tail = newNode;        &#125;<span class="hljs-keyword">else</span>&#123;          newNode.next = <span class="hljs-built_in">this</span>.head          cur.prev = newNode          <span class="hljs-built_in">this</span>.head = newNode        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-built_in">this</span>.length)&#123;        <span class="hljs-comment">//尾巴</span>        cur = <span class="hljs-built_in">this</span>.tail        cur.prev = newNode        newNode.next = cur        <span class="hljs-built_in">this</span>.tail = newNode      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.next          index++        &#125;        cur.prev = newNode        pre.next = newNode        newNode.next = cur        newNode.prev = pre      &#125;      <span class="hljs-built_in">this</span>.length ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  <span class="hljs-built_in">this</span>.remove = <span class="hljs-function"><span class="hljs-params">position</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position&lt;<span class="hljs-built_in">this</span>.length &amp;&amp; <span class="hljs-built_in">this</span>.length&gt;<span class="hljs-number">0</span>)&#123;      <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre,index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.length === <span class="hljs-number">1</span>)&#123;          <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>          <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>        &#125;<span class="hljs-keyword">else</span>&#123;          cur = cur.next          cur.prev = <span class="hljs-literal">null</span>          <span class="hljs-built_in">this</span>.head = cur        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-built_in">this</span>.length-<span class="hljs-number">1</span>)&#123;        cur = <span class="hljs-built_in">this</span>.tail        pre = cur.prev        pre.next = <span class="hljs-literal">null</span>        <span class="hljs-built_in">this</span>.tail = pre      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.next          index ++        &#125;        cur = cur.next        pre.next = cur        cur.prev = pre      &#125;      <span class="hljs-built_in">this</span>.length --      <span class="hljs-keyword">return</span> cur.element    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    &#125;  &#125;  <span class="hljs-built_in">this</span>.search = <span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.element === element)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>      &#125;      cur = cur.next    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  &#125;&#125;</code></pre></div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="注意边界情况"><a href="#注意边界情况" class="headerlink" title="注意边界情况"></a>注意边界情况</h3><ul><li>链表为空</li><li>链表只有一个结点</li><li>链表只有两个结点</li><li>处理头部结点和尾部结点</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>单链表反转<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListNode</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-built_in">this</span>.val = val  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseLinkedList</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-comment">// 长度为1</span>  <span class="hljs-keyword">if</span>(!head.next) <span class="hljs-keyword">return</span> head  <span class="hljs-comment">// 链表反过来，则head的值为null</span>  <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-comment">// 链表正向走完后.next = null</span>  <span class="hljs-keyword">while</span>(cur)&#123;    <span class="hljs-keyword">const</span> n = cur.next    cur.next = pre    pre = cur    cur = n  &#125;  <span class="hljs-keyword">return</span> pre&#125;<span class="hljs-comment">// es6</span><span class="hljs-keyword">let</span> [pre,cur] = [<span class="hljs-literal">null</span>,head]<span class="hljs-keyword">while</span>(cur)&#123;  [cur.next,pre,cur] = [pre,cur,cur.next]&#125;<span class="hljs-keyword">return</span> pre</code></pre></div></li><li>检测链表是否循环<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//</span><span class="hljs-built_in">JSON</span>.stringify() <span class="hljs-comment">//不能序列化循环链表</span><span class="hljs-comment">//标记</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLoop</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-keyword">while</span>(cur)&#123;    <span class="hljs-keyword">if</span>(cur.flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    cur.flag = <span class="hljs-literal">true</span>    cur = cur.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// 快慢指针</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLoop2</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> fast = head.next.next  <span class="hljs-keyword">let</span> slow = head.next  <span class="hljs-keyword">while</span>(slow!==fast)&#123;    <span class="hljs-keyword">if</span>(!fast || !fast.next)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    fast = fast.next.next    slow = slow.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div></li></ul><ul><li><p>实现LRU缓存淘汰策略</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">value</span>)</span>&#123;  <span class="hljs-built_in">this</span>.value = value  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LRULinkedList</span>(<span class="hljs-params">maxSize</span>)</span>&#123;  <span class="hljs-built_in">this</span>.maxSize = maxSize  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.curSize = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.visit = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> Node(value)    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head,pre = <span class="hljs-built_in">this</span>.head    <span class="hljs-keyword">let</span> preCatch,curCatch    <span class="hljs-keyword">if</span>(!cur)&#123;      <span class="hljs-built_in">this</span>.head = n      <span class="hljs-built_in">this</span>.curSize = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(cur.value===value) <span class="hljs-keyword">return</span>     <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.value === value)&#123;          <span class="hljs-comment">// 找到了</span>          <span class="hljs-comment">// 从原来位置删除并作为头</span>          pre.next = cur.next          cur.next = <span class="hljs-built_in">this</span>.head          <span class="hljs-keyword">return</span>      &#125;      preCatch = pre      curCatch = cur      pre = cur      cur = cur.next    &#125;    <span class="hljs-comment">// 没找到</span>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.curSize&lt;maxSize)&#123;      <span class="hljs-comment">// 插入头部</span>      n.next = <span class="hljs-built_in">this</span>.head      <span class="hljs-built_in">this</span>.head = n      <span class="hljs-built_in">this</span>.curSize ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 删除尾部结点</span>      <span class="hljs-comment">// 插入头部</span>      preCatch.next = <span class="hljs-literal">null</span>      curCatch.next = <span class="hljs-built_in">this</span>.head      <span class="hljs-built_in">this</span>.head = curCatch    &#125;  &#125;&#125;</code></pre></div></li><li><p>回文链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 快慢指针找出中点</span><span class="hljs-comment">// 一半的链表与另一半链表组成的栈对比</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isPalindrome</span>(<span class="hljs-params">head</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  <span class="hljs-keyword">const</span> stack = []  <span class="hljs-keyword">let</span> slow = head  <span class="hljs-keyword">let</span> fast = head  <span class="hljs-keyword">while</span>(fast &amp;&amp; fast.next &amp;&amp; fast.next.next)&#123;    slow = slow.next    fast = fast.next.next  &#125;  <span class="hljs-keyword">let</span> mid  = slow  <span class="hljs-keyword">while</span> (mid.next) &#123;    stack.push(mid.next)    mid = mid.next  &#125;  <span class="hljs-keyword">while</span>(stack.length&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">if</span>(head.val !== stack.pop().val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    head = head.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// 或者将链表转数组，对撞指针</span><span class="hljs-comment">// 另一种是到到中点后反转链表，不使用辅助栈</span></code></pre></div></li><li><p>合并两个有序链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-built_in">this</span>.val = val  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-comment">// 1-&gt;2-&gt;4,1-&gt;3-&gt;4</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeLinkedList</span>(<span class="hljs-params">l1,l2</span>)</span>&#123;  <span class="hljs-keyword">if</span>(l1===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l2  &#125;  <span class="hljs-keyword">if</span>(l2===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l1  &#125;  <span class="hljs-keyword">if</span>(l1.val&lt;=l2.val)&#123;    l1.next = mergeLinkedList(l1.next,l2)    <span class="hljs-keyword">return</span> l1  &#125;<span class="hljs-keyword">else</span>&#123;    l2.next = mergeLinkedList(l2.next,l1)    <span class="hljs-keyword">return</span> l2  &#125;&#125;<span class="hljs-comment">// 或者蠢办法</span><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) </span>&#123;   <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>)   <span class="hljs-keyword">let</span> cur = n   <span class="hljs-keyword">while</span>(l1&amp;&amp;l2)&#123;       <span class="hljs-keyword">if</span>(l1.val&lt;=l2.val)&#123;           cur.next = l1           l1 = l1.next       &#125;<span class="hljs-keyword">else</span>&#123;           cur.next = l2           l2 = l2.next       &#125;       cur = cur.next   &#125;   <span class="hljs-comment">// 有一条到头咯</span>   <span class="hljs-keyword">if</span>(l1)&#123;       cur.next = l1   &#125;<span class="hljs-keyword">else</span>&#123;       cur.next = l2   &#125;   <span class="hljs-keyword">return</span> n.next&#125;;</code></pre></div></li><li><p>查找两个链表的公共起始点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix</span>(<span class="hljs-params">headA,headB</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">while</span>(headA)&#123;    headA.flag = <span class="hljs-literal">true</span>    headA = headA.next  &#125;  <span class="hljs-keyword">while</span>(headB)&#123;    <span class="hljs-keyword">if</span>(headB.flag) <span class="hljs-keyword">return</span> headB    headB.flag =<span class="hljs-literal">true</span>    headB = headB.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commonPrefix2</span>(<span class="hljs-params">headA,headB</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-comment">// 连个链表同时移动指针</span>  <span class="hljs-keyword">let</span> n1 = headA  <span class="hljs-keyword">let</span> n2 = headB  <span class="hljs-keyword">while</span>(n1 || n2)&#123;    <span class="hljs-keyword">if</span>(n1===n2) <span class="hljs-keyword">return</span> n1    <span class="hljs-comment">//指针到头后跳到对面的开头</span>    n1 = n1 === <span class="hljs-literal">null</span> ? headB : n1.next    n2 = n2 === <span class="hljs-literal">null</span> ? headA : n2.next  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre></div></li><li><p>删除特定值链表节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteNode</span>(<span class="hljs-params">head,val</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>   <span class="hljs-keyword">if</span>(head.val === val)&#123;    <span class="hljs-keyword">return</span> head.next  &#125;  head.next = deleteNode(head.next,val)  <span class="hljs-keyword">return</span> head&#125;</code></pre></div></li><li><p>返回链表中特定位置节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 计数法</span><span class="hljs-comment">// 一遍算链表长度</span><span class="hljs-comment">// 一遍根据位置.next</span><span class="hljs-comment">// 计数法配合map</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">head,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-keyword">while</span>(head)&#123;    map.set(pos++,head)    head = head.next  &#125;  <span class="hljs-keyword">return</span> map.get(pos-k)&#125;<span class="hljs-comment">// 双指针</span><span class="hljs-comment">// 返回倒数k位置</span><span class="hljs-comment">//  * Definition for singly-linked list.</span><span class="hljs-comment">//  * function ListNode(val) &#123;</span><span class="hljs-comment">//  *     this.val = val;</span><span class="hljs-comment">//  *     this.next = null;</span><span class="hljs-comment">//  * &#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getKthFromEnd</span>(<span class="hljs-params">head,k</span>)</span>&#123;  <span class="hljs-keyword">let</span> fast = head  <span class="hljs-keyword">let</span> slow = head  <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(fast.next)&#123;    fast = fast.next    t ++    <span class="hljs-keyword">if</span>(t&gt;=k) slow = slow.next  &#125;  <span class="hljs-keyword">return</span> slow&#125;</code></pre></div></li><li><p>字符串中第一个不重复字符</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//map</span><span class="hljs-comment">//循环两次</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstUniqChar</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [i,v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Array</span>.from(s).entries())&#123;    <span class="hljs-keyword">if</span>(map.has(v))&#123;      map.set(v,-<span class="hljs-number">1</span>)    &#125;<span class="hljs-keyword">else</span>&#123;      map.set(v,i)    &#125;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.keys())&#123;    <span class="hljs-keyword">if</span>(map.get(key)!==-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> key    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>&#125;<span class="hljs-comment">//</span>...indexOf===lastIndexOf...</code></pre></div></li><li><p>字符串能否构成回文</p></li></ul><p>字符顺序修改后能否回文<br>相当于非回文字符最多只有一个</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">canPermutePalindrome</span>(<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-comment">// map // object都行</span>&#125;<span class="hljs-keyword">var</span> canPermutePalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;  <span class="hljs-keyword">const</span> obj = &#123;&#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt;s.length ;i++)&#123;    <span class="hljs-keyword">const</span> str = s[i]    <span class="hljs-built_in">console</span>.log(str);    <span class="hljs-keyword">if</span>(obj[str])&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);      <span class="hljs-keyword">delete</span> obj[str]    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 使用object时，上面的if(obj[str])会和这里冲突</span>      <span class="hljs-comment">// 刚好设置obj[str] = 0</span>      <span class="hljs-comment">// if判断不成立</span>      obj[str] = <span class="hljs-number">1</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.keys(obj).length &lt;= <span class="hljs-number">1</span>&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列及算法题</title>
    <link href="/2022/02/24/%E9%98%9F%E5%88%97/"/>
    <url>/2022/02/24/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列结构，先进先出"><a href="#队列结构，先进先出" class="headerlink" title="队列结构，先进先出"></a>队列结构，先进先出</h2><ul><li><p>用数组实现-顺序队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ArrayQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len)  <span class="hljs-built_in">this</span>.n = len  <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-number">0</span>&#125;ArrayQueue.prototype.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.tail === <span class="hljs-built_in">this</span>.n)&#123;<span class="hljs-comment">// tail后没有空余空间</span>    <span class="hljs-keyword">if</span>(head === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">// 判断是否队列前方有已经出队的位置</span>    <span class="hljs-comment">// 有则将整个队列向前移动</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = head;i&lt;<span class="hljs-built_in">this</span>.tail;i++)&#123;      <span class="hljs-built_in">this</span>.items[i-head] = <span class="hljs-built_in">this</span>.items[i]    &#125;    <span class="hljs-built_in">this</span>.tail = <span class="hljs-built_in">this</span>.tail-<span class="hljs-built_in">this</span>.head    <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>  &#125;  <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.tail] = item  <span class="hljs-built_in">this</span>.tail ++  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;ArrayQueue.prototype.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.head === <span class="hljs-built_in">this</span>.tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.head ++   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.items.shift()&#125;</code></pre></div></li><li><p>!循环队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 避免了顺序队列中的数据搬移操作</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CircularQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len)  <span class="hljs-built_in">this</span>.n = len  <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-number">0</span>&#125;CircularQueue.prototype = &#123;  enqueue:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;    <span class="hljs-keyword">if</span>((<span class="hljs-built_in">this</span>.tail+<span class="hljs-number">1</span>)%n===<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-built_in">this</span>.items[<span class="hljs-built_in">this</span>.tail] = item    <span class="hljs-built_in">this</span>.tail = (<span class="hljs-built_in">this</span>.tail+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  dequeue:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.head===<span class="hljs-built_in">this</span>.tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">const</span> ret = <span class="hljs-built_in">this</span>.items[head]    <span class="hljs-built_in">this</span>.head = (<span class="hljs-built_in">this</span>.head+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> ret  &#125;&#125;</code></pre></div></li><li><p>用链表实现-链式队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">val</span>)</span>&#123;  <span class="hljs-built_in">this</span>.val = val  <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LinkedListQueue</span>(<span class="hljs-params">len</span>)</span>&#123;  <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.tail = <span class="hljs-literal">null</span>  <span class="hljs-built_in">this</span>.curLen = <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>.maxLen = len&#125;LinkedListQueue.prototype = &#123;  enqueue: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.head===<span class="hljs-literal">null</span>)&#123;      <span class="hljs-built_in">this</span>.head = node      <span class="hljs-built_in">this</span>.tail = node      <span class="hljs-built_in">this</span>.curLen = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.curLen &gt;= <span class="hljs-built_in">this</span>.len) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-comment">// 循环到链表末尾</span>    <span class="hljs-keyword">while</span>(cur.next)&#123;      cur = cur.next    &#125;    cur.next = node    <span class="hljs-built_in">this</span>.tail = node    <span class="hljs-built_in">this</span>.curLen ++    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  dequeue : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-built_in">this</span>.head    <span class="hljs-comment">// 删除表头</span>    <span class="hljs-built_in">this</span>.head = cur.next    <span class="hljs-built_in">this</span>.curLen --    <span class="hljs-keyword">return</span> cur  &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象题</title>
    <link href="/2022/02/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/"/>
    <url>/2022/02/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>打车时可以打专车或快车。任何车都有车牌号和名称。快车每公里1元，专车每公里2元。行程开始时，显示车辆信息。行程结束时，显示打车金额。行程距离为5公里。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.licence = licence    <span class="hljs-built_in">this</span>.name = name  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">super</span>(licence,name)    <span class="hljs-built_in">this</span>.price =<span class="hljs-number">1</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrivateCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence,name</span>)</span>&#123;    <span class="hljs-built_in">super</span>(licence,name)    <span class="hljs-built_in">this</span>.price = <span class="hljs-number">2</span>  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">car,distance</span>)</span>&#123;    <span class="hljs-built_in">this</span>.car = car    <span class="hljs-built_in">this</span>.distance = distance  &#125;  <span class="hljs-function"><span class="hljs-title">getIn</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.name);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.licence);  &#125;  <span class="hljs-function"><span class="hljs-title">getOff</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.car.price*<span class="hljs-built_in">this</span>.distance);  &#125;&#125;<span class="hljs-keyword">let</span> car1 = <span class="hljs-keyword">new</span> PrivateCar(<span class="hljs-string">&#x27;粤A8888888&#x27;</span>,<span class="hljs-string">&#x27;特斯拉&#x27;</span>)<span class="hljs-keyword">let</span> cost1 = <span class="hljs-keyword">new</span> Order(car1,<span class="hljs-number">5</span>).getOff()</code></pre></div><ul><li>某停车场, 分三层, 每层100 车位,每个车位都能监控到车辆的进入和离开,车辆进入前,显示每层的空余车位数量,车辆进入时,摄像头可识别车牌号和进入时间,车辆出来时,出口显示屏显示车牌号和停车时长</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">licence</span>)</span>&#123;    <span class="hljs-built_in">this</span>.licence = licence  &#125;&#125;<span class="hljs-comment">// 整个停车场</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingLot</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">floors</span>)</span>&#123;    <span class="hljs-comment">// floors:[[300],[300],[300]]</span>    <span class="hljs-built_in">this</span>.floors = floors    <span class="hljs-built_in">this</span>.dataBase = []  &#125;  <span class="hljs-function"><span class="hljs-title">showSpace</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.floors.length;i++)&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`第<span class="hljs-subst">$&#123;i+<span class="hljs-number">1</span>&#125;</span>层空闲车位(<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.floors[i].emptySpace()&#125;</span>)`</span>)    &#125;  &#125;  <span class="hljs-function"><span class="hljs-title">intoLot</span>(<span class="hljs-params">car,floorIndex,lotIndex</span>)</span>&#123;    <span class="hljs-comment">//车牌，时间</span>    <span class="hljs-keyword">let</span> licence = car.licence    <span class="hljs-keyword">let</span> intoTime = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> space = <span class="hljs-built_in">this</span>.floors[floorIndex].lot[lotIndex]    <span class="hljs-built_in">this</span>.dataBase[licence] = &#123;intoTime,floorIndex,lotIndex&#125;    space.checkIn()  &#125;  <span class="hljs-function"><span class="hljs-title">outLot</span>(<span class="hljs-params">car</span>)</span>&#123;    <span class="hljs-keyword">let</span> outTime = <span class="hljs-built_in">Date</span>.now()    <span class="hljs-keyword">let</span> licence = car.licence    <span class="hljs-keyword">let</span> info = <span class="hljs-built_in">this</span>.dataBase[licence]    <span class="hljs-keyword">let</span> space = <span class="hljs-built_in">this</span>.floors[info.floorIndex].lot[info.lotIndex]    <span class="hljs-keyword">let</span> timeCount = <span class="hljs-built_in">parseInt</span>((outTime-info.intoTime)/<span class="hljs-number">36000000</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`停车时长<span class="hljs-subst">$&#123;timeCount&#125;</span>小时`</span>)    space.checkOut()  &#125;&#125;<span class="hljs-comment">// 车位,监视驶入离开</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingSpace</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">true</span>  &#125;  <span class="hljs-function"><span class="hljs-title">checkIn</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">false</span>  &#125;  <span class="hljs-function"><span class="hljs-title">checkOut</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">this</span>.free = <span class="hljs-literal">true</span>  &#125;&#125;<span class="hljs-comment">// 层</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingFloor</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">floor,lot</span>)</span>&#123;    <span class="hljs-built_in">this</span>.floor = floor    <span class="hljs-built_in">this</span>.lot = lot  &#125;  <span class="hljs-function"><span class="hljs-title">emptySpace</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//返回空闲车位</span>    <span class="hljs-keyword">let</span> freeLot = <span class="hljs-number">0</span>    <span class="hljs-built_in">this</span>.lot.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span>(item.free)&#123;        freeLot++      &#125;    &#125;);    <span class="hljs-keyword">return</span> freeLot  &#125;&#125;</code></pre></div><ul><li>一副扑克牌有54张牌，其中52张是正牌，另2张是副牌（大王和小王）。<br>52张正牌又均分为13张一组，并以黑桃、红桃、草花、方块四种花色表示各组，每组花色的牌包括从1-10（1通常表示为A）以及J、Q、K标示的13张牌。<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;Q&#x27;</span>,<span class="hljs-string">&#x27;K&#x27;</span>]<span class="hljs-keyword">const</span> signs = [<span class="hljs-string">&#x27;♥️&#x27;</span>, <span class="hljs-string">&#x27;♦️&#x27;</span>, <span class="hljs-string">&#x27;♣️&#x27;</span>, <span class="hljs-string">&#x27;♠️&#x27;</span>]<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">signs,numbers</span>)</span> &#123;<span class="hljs-built_in">this</span>.signs = signs<span class="hljs-built_in">this</span>.numbers = numbers<span class="hljs-built_in">this</span>.mounts = <span class="hljs-number">52</span><span class="hljs-built_in">this</span>.pokers = []&#125;<span class="hljs-function"><span class="hljs-title">initPokers</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">this</span>.signs.length;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-built_in">this</span>.numbers.length;j++)&#123;<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-built_in">this</span>.signs[i],<span class="hljs-built_in">this</span>.numbers[j]))&#125;&#125;<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-string">&#x27;BLACK&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))<span class="hljs-built_in">this</span>.pokers.push(<span class="hljs-keyword">new</span> Card(<span class="hljs-string">&#x27;RED&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))&#125;  <span class="hljs-function"><span class="hljs-title">shuffleCard</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// let arr = this.pokers</span><span class="hljs-comment">// let len = arr.length</span>    <span class="hljs-comment">// let temp,i</span>    <span class="hljs-comment">// while(len)&#123;</span>    <span class="hljs-comment">//   i = Math.floor(Math.random()*len--)</span>    <span class="hljs-comment">//   temp = arr[i]</span>    <span class="hljs-comment">//   arr[i] = arr[len]</span>    <span class="hljs-comment">//   arr[len] = temp</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// this.pokers = arr</span>    <span class="hljs-built_in">this</span>.pokers = <span class="hljs-built_in">this</span>.pokers.sort(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">Math</span>.random()-<span class="hljs-number">0.5</span>)    <span class="hljs-comment">// Math.random() - 0.5 不完全随机</span>    <span class="hljs-keyword">const</span> temp = [...this.pokers]    <span class="hljs-keyword">let</span> len = temp.length    <span class="hljs-keyword">while</span>(len)&#123;      <span class="hljs-keyword">const</span> i = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * len--)      [temp[i],temp[len]] = [temp[len],temp[i]]      &#125;    <span class="hljs-built_in">this</span>.pokers = [...temp]  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Card</span> </span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">sign, number</span>)</span> &#123;    <span class="hljs-built_in">this</span>.sign = sign;    <span class="hljs-built_in">this</span>.number = number;  &#125;&#125;<span class="hljs-keyword">let</span> game1 = <span class="hljs-keyword">new</span> Poker(signs,numbers)game1.initPokers()game1.shuffleCard()<span class="hljs-built_in">console</span>.log(game1.pokers);game1.shuffleCard()<span class="hljs-built_in">console</span>.log(game1.pokers);</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地址中输入URL回车后发生了什么</title>
    <link href="/2022/02/24/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/02/24/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="【DNS解析】"><a href="#【DNS解析】" class="headerlink" title="【DNS解析】"></a>【DNS解析】</h2><ol><li>查找浏览器DNS缓存</li><li>查找系统HOST文件</li><li>DNS查询<blockquote><p>主机和本地域名服务器之间使用递归查询，本地域名服务器要负责一直到查询得出结果</p><p>本地域名服务器和其他服务器之间的使用迭代查询，域名服务器会告诉本地服务器下一次去询问谁，防止单台域名服务器压力过大</p></blockquote></li></ol><blockquote><p>DNS请求使用<code>UDP</code>协议，如果请求失败则使用<code>TCP</code>重试</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs">1. 本地DNS服务器查找自己缓存2. 本地DNS服务器向【根域名服务器】发送请求，根域名服务器返回顶级域名服务器的地址`com`3. 本地DNS服务器向顶级域名服务器发送请求，顶级域名返回二级域名的服务器地址`baidu.com`4. 本地DNS服务器向二级域名服务器发送请求，得到目标主机IP地址，存入本地DNS服务器缓存并返回给用户主机5. 用户主机和浏览器都将缓存这个IP地址的映射</code></pre></div><h2 id="【TCP握手】"><a href="#【TCP握手】" class="headerlink" title="【TCP握手】"></a>【TCP握手】</h2><p>对应IP地址，端口建立TCP连接，构造HTTP请求并与服务器握手后发送tcp数据包</p><p>  TCP三次握手</p><blockquote><p>客户端与服务端互相确认收发能力</p></blockquote><ol><li>【CLIENT】 发送<code>SYN</code>报文，指明自己的初始化序列号<code>ISN(c)</code></li><li>【SERVER】 收到后，将client发送的<code>ISN(c)</code>+1作为<code>ACK</code>字符，并且也生成自己的<code>ISN(s)</code>发送给【CLIENT】</li><li>【CLIENT】 收到后，同样将<code>ISN(s)</code>+1作为<code>ACK</code>字符发送给【SERVER】</li></ol><h2 id="【分析请求资源】"><a href="#【分析请求资源】" class="headerlink" title="【分析请求资源】"></a>【分析请求资源】</h2><ul><li><p>不同浏览器对资源优先级分类</p></li><li><p>安全策略检查 </p><p>内容安全策略(Content Security Policy，缩写 CSP)是由浏览器提供的一种白名单制度。发者通过配置，来告诉浏览器各类外部资源的加载和执行限制，来提高网页的安全性。一种最常用应用就是通过限制非信任域名脚本的加载来预防XSS攻击。</p><p>可以通过两种方式来配置CSP：</p><ol><li>HTTP请求头的<code>Content-Security-Policy</code></li><li><code>meta</code>标签 <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> content=<span class="hljs-string">&quot;script-src &#x27;self&#x27;;style-src nos.netease.com kaola.com;&quot;</span>&gt;</code></pre></div></li></ol></li><li><p>资源优先级计算</p><ol><li><code>html,font,css</code></li><li><code>preload,script,xhr</code></li><li><code>img,audio,video</code></li><li><code>prefetch</code></li></ol></li><li><p>顺序调整</p><ol><li>同步XHR请求优先级调整到最高</li><li>图片根据是否出现在可视区域</li><li><code>async/defer</code>的<code>script</code>标签请求优先级降低</li></ol></li></ul><h2 id="【应用缓存策略】"><a href="#【应用缓存策略】" class="headerlink" title="【应用缓存策略】"></a>【应用缓存策略】</h2><ul><li>强缓存</li><li>协商缓存</li></ul><h2 id="【渲染页面】"><a href="#【渲染页面】" class="headerlink" title="【渲染页面】"></a>【渲染页面】</h2><h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><ul><li>处理html标记，生成DOM树，所有标签都会包含在内</li><li>DOM的构建是增量的</li><li>解析完一个节点的所有子元素才会解析他的兄弟元素</li></ul><h3 id="CSSOM-Tree"><a href="#CSSOM-Tree" class="headerlink" title="CSSOM Tree"></a>CSSOM Tree</h3><ul><li>加载所有样式，生成CSSOM树</li><li>CSSOM的构建会阻塞渲染<blockquote><p>不同来源的样式（内联、内部style标签和外部引用）可能会发送覆盖，所以要等他们全加载完才能继续渲染</p></blockquote></li></ul><h3 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h3><ul><li>对DOM节点找到与其匹配的CSSOM规则并应用</li><li>只包含DOM树中的可见元素(忽略像<code>display：none/&lt;head&gt;标签</code>)</li></ul><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>浏览器依据Render树和设备屏幕信息<strong>重排</strong>一次，从 <code>&lt;html&gt;标签</code> 开始往下依次计算所有的节点几何尺寸和位置</p><h3 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h3><p>根据上一步得到的像素信息<strong>重绘</strong>页面</p><h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p>GPU合成各图层，显示在屏幕上</p><h1 id="重点概念"><a href="#重点概念" class="headerlink" title="重点概念"></a>重点概念</h1><h3 id="重排reflow"><a href="#重排reflow" class="headerlink" title="重排reflow"></a>重排<code>reflow</code></h3><ul><li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow，而是会把这样的操作积攒一批，然后做一次处理，这又叫异步 reflow 或增量异步 reflow。</li><li>在有些情况下，比如窗口<code>resize</code>，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li><li>除了渲染树的直接变化，当获取一些需要计算的属性时，浏览器为取得正确的值也会触发重排,这些属性包括：<code>offsetXXX、scrollXXX、clientXXX、getComputedStyle()</code></li><li>重排必定触发重绘</li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重绘，但是元素的几何尺寸没有变。</p><h3 id="合成层"><a href="#合成层" class="headerlink" title="合成层"></a>合成层</h3><p>区别于一般的图层，合成层【composite】使用GPU线程进行计算</p><h3 id="提升到合成层的条件"><a href="#提升到合成层的条件" class="headerlink" title="提升到合成层的条件"></a>提升到合成层的条件</h3><ul><li>3D<code>transform</code></li><li><code>opacity</code></li><li><code>filter</code></li><li><code>will-change</code></li><li><code>&lt;video&gt;,&lt;audio&gt;,&lt;canvas&gt;</code></li><li><code>position:fixed</code></li></ul><h3 id="解析URL参数"><a href="#解析URL参数" class="headerlink" title="解析URL参数"></a>解析URL参数</h3><ol><li><p>正则解析</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseQueryString</span>(<span class="hljs-params">url</span>)</span>&#123;  <span class="hljs-keyword">const</span> rule = <span class="hljs-regexp">/([^?=&amp;]+)=([^&amp;#]*)/g</span>    <span class="hljs-keyword">return</span> url.match(rule).reduce(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> [k,v] = b.split(<span class="hljs-string">&#x27;=&#x27;</span>)    k = <span class="hljs-built_in">decodeURIComponent</span>(k)    v = decodeIRIComponent(v)    a[k] = a[k] ? [...a[k],v] : v    <span class="hljs-keyword">return</span> a  &#125;,&#123;&#125;)  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>API解析</p><p> URLSearchParams<br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseURL</span>(<span class="hljs-params">url</span>)</span>&#123;  <span class="hljs-keyword">const</span> urlObj = <span class="hljs-keyword">new</span> URLSearchParams(url.slice(url.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>)))  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> urlObj.keys())&#123;    res[key] = urlObj.getAll(key)  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码提交规范新手包</title>
    <link href="/2022/01/17/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E6%96%B0%E6%89%8B%E5%8C%85/"/>
    <url>/2022/01/17/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E6%96%B0%E6%89%8B%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="commit-提交工具"><a href="#commit-提交工具" class="headerlink" title="commit 提交工具"></a>commit 提交工具</h2><ul><li><p>安装</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">npm i -d commitizen</code></pre></div></li><li><p>预设配置</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 预设</span>npm i -d cz-conventional-changelog</code></pre></div></li><li><p>修改<code>package.json</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加config</span><span class="hljs-string">&quot;config&quot;</span>: &#123;  <span class="hljs-string">&quot;commitizen&quot;</span>: &#123;    <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;cz-conventional-changelog&quot;</span>  &#125;&#125;</code></pre></div></li><li><p>交互式提交</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加到script</span><span class="hljs-string">&quot;commit&quot;</span>:<span class="hljs-string">&quot;cz&quot;</span><span class="hljs-comment">//或者直接</span>cz</code></pre></div></li></ul><h2 id="commit-校验工具"><a href="#commit-校验工具" class="headerlink" title="commit 校验工具"></a>commit 校验工具</h2><ul><li><p>安装</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// husky - git的钩子工具</span><span class="hljs-comment">// commitlint - 校验工具</span>npm i -d husky commitlint</code></pre></div></li><li><p>配置</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">npm i -d @commitlint/config-conventional<span class="hljs-comment">//  .commitlintrc.js</span><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-keyword">extends</span>:   <span class="hljs-comment">// angluar 规范校验</span>  [<span class="hljs-string">&#x27;@commitlint/config-conventional&#x27;</span>]&#125;;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化husky</span>npx husky install<span class="hljs-comment">// 新建文件 .husky/commit-msg</span>#!/bin/shnpx --no-install commitlint --edit <span class="hljs-string">&quot;$1&quot;</span></code></pre></div></li><li><p>之后的所有commit信息都将校验并抛出校验错误结果</p></li></ul><h2 id="生成CHANGELOG"><a href="#生成CHANGELOG" class="headerlink" title="生成CHANGELOG"></a>生成CHANGELOG</h2><ul><li><p>安装</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">npm i -D standard-version</code></pre></div></li><li><p>添加script</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <span class="hljs-string">&quot;release&quot;</span>: <span class="hljs-string">&quot;standard-version&quot;</span>  &#125;&#125;</code></pre></div></li><li><p>运行后会自动生成<code>CHANGELOG.md</code>，当提交类型是feat和fix的时候版本号会累加</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mapbox-gl动态style表达式</title>
    <link href="/2022/01/17/Mapbox-gl%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/01/17/Mapbox-gl%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/">https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/</a></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><ul><li>适用于<code>Style</code>中的<code>layout</code>,<code>paint</code>,<code>filter</code>属性，均可添加表达式。</li><li>表达式定义了如何使用逻辑、数学、字符串或颜色操作组合<code>feature</code>中的一个或多个<code>properties</code>或<code>zoom</code>，以生成适当的样式属性值或过滤器决策。</li></ul><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>[expression_name, argument_0, argument_1, ...]</code></p><ol><li>常用操作符<code>expression_name</code></li></ol><ul><li><code>*</code></li><li><code>case</code></li><li><code>==,&gt;=,&lt;</code>(比较的两边类型需要相同，都是数字或都是字符串)</li><li><code>match</code></li><li><code>all</code></li><li><code>contact</code><br>…  </li></ul><ol><li><p>大部分操作符可以多级嵌套</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&quot;line-dasharray&quot;</span>: [<span class="hljs-string">&quot;case&quot;</span>,[<span class="hljs-string">&quot;==&quot;</span>, [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;customStatus&quot;</span>], <span class="hljs-string">&quot;PLANING&quot;</span>], <span class="hljs-comment">// 规划</span>[<span class="hljs-string">&quot;literal&quot;</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>]],[<span class="hljs-string">&quot;==&quot;</span>, [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;customStatus&quot;</span>], <span class="hljs-string">&quot;TEST&quot;</span>], <span class="hljs-comment">// 测试</span>[<span class="hljs-string">&quot;literal&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]],<span class="hljs-comment">// 回退选项</span>[<span class="hljs-string">&quot;literal&quot;</span>, [<span class="hljs-number">1</span>]],],</code></pre></div></li><li><p>定义变量的表达式<br>变量需要设定在使用变量的外层表达式</p></li><li><p>获取feature属性</p></li></ol><ul><li><code>[&#39;get&#39;,&#39;propName&#39;]</code>获取properties对象中的属性</li><li><code>$propName</code>获取定义在feature对象顶层的属性，例如<code>$type</code>,<code>$geometry</code><br>``</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>data表达式<div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;    <span class="hljs-string">&quot;circle-color&quot;</span>: [        <span class="hljs-string">&quot;rgb&quot;</span>,        <span class="hljs-comment">// red is higher when feature.properties.temperature is higher</span>        [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;temperature&quot;</span>],<span class="hljs-comment">// r数值取temperature数值</span>        <span class="hljs-comment">// green is always zero</span>        <span class="hljs-number">0</span>,        <span class="hljs-comment">// blue is higher when feature.properties.temperature is lower</span>        [<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">100</span>, [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;temperature&quot;</span>]]<span class="hljs-comment">// b数值=100-temp</span>    ]&#125;</code></pre></div></li><li>camera表达式<div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;    <span class="hljs-string">&quot;circle-radius&quot;</span>: [        <span class="hljs-string">&quot;interpolate&quot;</span>, [<span class="hljs-string">&quot;linear&quot;</span>], [<span class="hljs-string">&quot;zoom&quot;</span>],        <span class="hljs-comment">// zoom is 5 (or less) -&gt; circle radius will be 1px</span>        <span class="hljs-number">5</span>, <span class="hljs-number">1</span>,        <span class="hljs-comment">// zoom 5到10两个定义档位之间，interpolate运算符讲线性计算数值</span>        <span class="hljs-comment">// zoom is 10 (or greater) -&gt; circle radius will be 5px</span>        <span class="hljs-number">10</span>, <span class="hljs-number">5</span>    ]&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>mapbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚手架搭建&amp;Lerna新手包</title>
    <link href="/2022/01/10/cli%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2022/01/10/cli%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="脚手架工具"><a href="#脚手架工具" class="headerlink" title="脚手架工具"></a>脚手架工具</h1><h2 id="脚手架结构"><a href="#脚手架结构" class="headerlink" title="脚手架结构"></a>脚手架结构</h2><ul><li><p>文件头部</p><p>  <code>#!/usr/bin/env node</code></p></li><li><p>命令结构</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">vue &lt;command&gt;  [options]  --options params&lt;!-- <span class="hljs-comment">// eg: --&gt;</span>vue create my_app -p env=...</code></pre></div></li></ul><h2 id="本地开发"><a href="#本地开发" class="headerlink" title="本地开发"></a>本地开发</h2><ul><li><p>链接本地脚手架</p><div class="hljs code-wrapper"><pre><code class="hljs">  `npm link`全局node_modules中添加目前库</code></pre></div></li><li><p>链接本地脚手架的依赖库</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// lib dir </span>npm link<span class="hljs-comment">// 同时注意在脚手架的package.json中手动 </span>dependencies:&#123;    <span class="hljs-string">&quot;xxx-lib&quot;</span>:<span class="hljs-string">&quot;^1.0.0&quot;</span>&#125;<span class="hljs-comment">// cli dir</span>npm link xx-lib</code></pre></div></li><li><p>解开本地lib和本地包的链接</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// lib dir</span>npm unlink<span class="hljs-comment">// cli dir</span>rm -rf node_modulesnpm unlink xxx-lib</code></pre></div></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><code>npm link/unlink</code>链接当前项目到全局</li><li><code>npm link/unlink xxx-lib</code>将xxx-li添加/从当前node_modules中移除</li></ul><h1 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h1><h2 id="基于Git-Npm的多package项目管理工具"><a href="#基于Git-Npm的多package项目管理工具" class="headerlink" title="基于Git+Npm的多package项目管理工具"></a>基于Git+Npm的多package项目管理工具</h2><ol><li><p>解决原生脚手架开发中的重复操作</p><ul><li>多package本地link</li><li>多package依赖安装</li><li>多package单元测试</li><li>多package代码提交</li><li>多package代码发布</li></ul></li><li><p>解决版本一致性</p><ul><li>package版本一致</li><li>相互依赖版本升级</li></ul></li></ol><h2 id="lerna开发脚手架流程"><a href="#lerna开发脚手架流程" class="headerlink" title="lerna开发脚手架流程"></a>lerna开发脚手架流程</h2><ol><li><p>项目创建</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">npm init npm i lernalerna init</code></pre></div></li><li><p>创建package</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">lerna create <span class="hljs-comment">// 创建package</span>lerna add <span class="hljs-comment">//安装依赖</span>lerna <span class="hljs-comment">//链接依赖</span></code></pre></div></li><li><p>开发测试</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">lerna exec <span class="hljs-comment">// 执行shell脚本</span>lerna runlerna clean <span class="hljs-comment">// 清空依赖</span>lerna bootstrap <span class="hljs-comment">// 重装依赖</span></code></pre></div></li><li><p>发布上线</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">lerna version <span class="hljs-comment">// 提升版本号</span>lerna change <span class="hljs-comment">//  查看变更</span>lerna diff <span class="hljs-comment">// 查看diff</span>lerna public <span class="hljs-comment">// 发布</span></code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>工程化</tag>
      
      <tag>cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>graphql新手包</title>
    <link href="/2022/01/04/graphql%E6%96%B0%E6%89%8B%E5%8C%85/"/>
    <url>/2022/01/04/graphql%E6%96%B0%E6%89%8B%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="GraphQl"><a href="#GraphQl" class="headerlink" title="GraphQl"></a>GraphQl</h2><p><code>GraphQL</code>是一个旨在简化前端和后端之间通信的规范。它主要由服务端的 schema 语言和客户端的查询语言组成。<br>【_查询语法和 schema 语法几乎是相等的_】。</p><p><code>gql</code>的 api 需要完整描述期望返回的数据，相对于<code>RestFul API</code>减少了数据的冗余。修改一下官网的示例：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 描述你的数据</span><span class="hljs-comment">// 定义了一个名为Project的对象类型，该类型上有三个字段，并且字段拥有不同的数据类型</span>type Project &#123;  name: <span class="hljs-built_in">String</span>  tagline: <span class="hljs-built_in">String</span>  contributors: [User]&#125;<span class="hljs-comment">// 请求你所要的数据</span><span class="hljs-comment">// 请求project中，name值为字符串‘GraphQl’的数据，并返回他的tagline字段</span>&#123;  <span class="hljs-function"><span class="hljs-title">project</span>(<span class="hljs-params">name: <span class="hljs-string">&quot;GraphQL&quot;</span></span>)</span> &#123;    tagline  &#125;&#125;<span class="hljs-comment">// 得到可预测的结果</span>&#123;  <span class="hljs-string">&quot;project&quot;</span>: &#123;    <span class="hljs-string">&quot;tagline&quot;</span>: <span class="hljs-string">&quot;A query language for APIs&quot;</span>  &#125;&#125;</code></pre></div><ul><li><p>  gql 实体资源不能通过 URL 识别</p></li><li><p>与 gql 服务器的<strong>全部</strong>数据交互基于一个指定的<code>URL</code>通<br>  道</p></li><li><p>标准的 gql GET 请求</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">http:<span class="hljs-comment">//myapi/graphql?query=&#123;me&#123;name&#125;&#125;</span>&#123;  me&#123;    name  &#125;&#125;</code></pre></div></li><li><p>标准的 gql POST 请求</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">content-type:application/json&#123;  <span class="hljs-string">&quot;query&quot;</span>: 查询的对象及参数,  <span class="hljs-string">&quot;operationName&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,  <span class="hljs-string">&quot;variables&quot;</span>: 变量形式的参数传参&#125;<span class="hljs-comment">// 并且一般会发起两次请求，先发一次OPTION，</span></code></pre></div></li></ul><h3 id="gql-文件"><a href="#gql-文件" class="headerlink" title="gql 文件"></a>gql 文件</h3><ul><li>  比较方便的管理 gql 接口的方式就是预先编写<code>.graphql</code>文件，方便复用和拓展。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 在一个gql文件内声明多个query，需要命名query，并支持es6结构引用。单个query请求文件则可不命名。</span>query queryxxx(  $variable1: <span class="hljs-built_in">String</span>  $variable2: [<span class="hljs-built_in">String</span>])&#123;  myCoWorkers(    name:$variable1    gender:$variable2  )&#123;    name    age    gender    nation  &#125;&#125;</code></pre></div><ul><li>  也可以在请求时手动编写（需安装’graphql-tag’）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">$apollo.query(  query:gql<span class="hljs-string">`query tagList &#123;</span><span class="hljs-string">      tags &#123;</span><span class="hljs-string">        id,</span><span class="hljs-string">        label</span><span class="hljs-string">      &#125;</span><span class="hljs-string">    &#125;`</span>)</code></pre></div><h2 id="ApolloClient"><a href="#ApolloClient" class="headerlink" title="ApolloClient"></a>ApolloClient</h2><p><code>Apollo</code>是实现 gql 标准的客户端，(可以理解成使用 gql 的<code>axios</code>)。各大框架和开发场景都有对应的整合库，如<code>VueApollo</code>。</p><h3 id="常用-api-选项"><a href="#常用-api-选项" class="headerlink" title="常用 api/选项"></a>常用 api/选项</h3><p><a href="https://vue-apollo.netlify.app/zh-cn/api/smart-query.html#%E9%80%89%E9%A1%B9">https://vue-apollo.netlify.app/zh-cn/api/smart-query.html#%E9%80%89%E9%A1%B9</a></p><ul><li><p>  query 查询表（可以是 query，mutation）</p></li><li><p>  variables 变量</p></li><li><p>fetchPolicy 缓存选项</p>  <div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># cache-first[default]</span>Apollo Client 首先对缓存执行查询。如果缓存中存在所有请求的数据，则返回该数据。否则，Apollo Client 会针对您的 GraphQL 服务器执行查询，并在缓存数据后返回该数据。<span class="hljs-section"># cache-only</span>Apollo Client 仅针对缓存执行查询。在这种情况下，它永远不会查询您的服务器。如果缓存不包含所有请求字段的数据，则会引发错误。<span class="hljs-section"># cache-and-network</span>Apollo Client 对缓存和 GraphQL 服务器执行完整查询。如果服务器端查询的结果修改了缓存字段，则查询会自动更新。<span class="hljs-section"># network-only</span>Apollo Client 会针对您的 GraphQL 服务器执行完整查询，而无需先检查缓存。查询的结果存储在缓存中。<span class="hljs-section"># no-cache</span>与 network-only 类似, 但不缓存结果。<span class="hljs-section"># standby</span>使用与 cache-first 相同的逻辑，除了当基础字段值更改时此查询不会自动更新。您仍然可以使用 refetch 和 updateQueries 手动更新此查询。</code></pre></div></li><li><p>  pollInterval 轮询（间隔 x 毫秒）</p></li><li><p>  fetchMore 加载更多（可以改变个别或全部参数发送同一个请求，需手动处理请求结果）</p></li></ul><h3 id="使用-Apollo（vue-v2）"><a href="#使用-Apollo（vue-v2）" class="headerlink" title="使用 Apollo（vue v2）"></a>使用 Apollo（vue v2）</h3><ul><li><p>安装<code>Apollo</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">yarn add vue-apollo graphql apollo-boost#  apollo-boost 是创建apollo client的懒人包，包含常用的默认值，无需繁琐的手动配置ornpm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag</code></pre></div></li><li><p>封装<code>ApolloClient</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> ApolloClient <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;apollo-boost&quot;</span>;<span class="hljs-keyword">const</span> $apollo = <span class="hljs-keyword">new</span> ApolloClient(&#123;<span class="hljs-attr">uri</span>:<span class="hljs-string">&#x27;xxx&#x27;</span>&#125;)<span class="hljs-comment">// or</span><span class="hljs-comment">// 封装举例</span><span class="hljs-comment">// 超时</span><span class="hljs-keyword">import</span> ApolloLinkTimeout <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;apollo-link-timeout&quot;</span>;<span class="hljs-keyword">const</span> timeoutLink = <span class="hljs-keyword">new</span> ApolloLinkTimeout(<span class="hljs-number">30000</span>);<span class="hljs-comment">// 缓存</span><span class="hljs-keyword">import</span> &#123; InMemoryCache &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;apollo-cache-inmemory&#x27;</span><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> InMemoryCache()<span class="hljs-comment">// link</span><span class="hljs-keyword">const</span> httpLink = createHttpLink(&#123; <span class="hljs-attr">uri</span>: <span class="hljs-string">&#x27;xxx&#x27;</span> &#125;);<span class="hljs-keyword">const</span> timeoutHttpLink = timeoutLink.concat(httpLink);<span class="hljs-keyword">const</span> apolloClient = <span class="hljs-keyword">new</span> ApolloClient(&#123;  version:<span class="hljs-string">&#x27;&#x27;</span>,  name:<span class="hljs-string">&#x27;&#x27;</span>,  link: timeoutHttpLink,<span class="hljs-comment">//同时提供时优先级高于uri，提供更精细化的配置</span>  cache: <span class="hljs-comment">// InMemoryCache (&#123;......&#125;) 缓存控制 www.apollographql.com/docs/react/caching/cache-configuration/`</span>  defaultOptions:&#123;      watchQuery: &#123;        fetchPolicy: <span class="hljs-string">&#x27;cache-and-network&#x27;</span>,        errorPolicy: <span class="hljs-string">&#x27;ignore&#x27;</span>,      &#125;,      query: &#123;        fetchPolicy: <span class="hljs-string">&#x27;network-only&#x27;</span>,        errorPolicy: <span class="hljs-string">&#x27;all&#x27;</span>,      &#125;,      mutate: &#123;        errorPolicy: <span class="hljs-string">&#x27;all&#x27;</span>,      &#125;    &#125;<span class="hljs-comment">//&#x27;各种查询的默认策略&#x27;</span>  &#125;);</code></pre></div></li><li><p>使用方法</p><ul><li><h4 id="apollo-provider"><a href="#apollo-provider" class="headerlink" title="apollo provider"></a>apollo provider</h4><p>  使用 apollo 组件，需先生成<code>apollo provider</code>，为 vue 实例提供 apollo 能力</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">Vue.use(VueApollo);<span class="hljs-keyword">const</span> apolloProvider = <span class="hljs-keyword">new</span> VueApollo(&#123;defaultClient: apolloClient,&#125;);<span class="hljs-keyword">new</span> Vue(&#123;el: <span class="hljs-string">&quot;#app&quot;</span>,<span class="hljs-comment">// 像 vue-router 或 vuex 一样注入 apolloProvider</span>apolloProvider,render: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> h(App),&#125;);</code></pre></div><p>  引入后之后，在你的每个 vue 组件实例上将多出$apollo 对象指向 apollo 客户端。</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.$apollo ===&gt;&#123;<span class="hljs-attr">query</span>:[....],&#125;</code></pre></div><p>  并且与 data 选项平行的 apollo 选择中可以自定义各种 gql 查询，并且他们的结果将作为 vue 变量来使用</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> &#123;    a:<span class="hljs-number">1</span>  &#125;&#125;,apollo:&#123;  fetchB:&#123;    query:...,    variables:...,    fetchPolicy:...,    ...各种apollo的api选项  &#125;&#125;</code></pre></div></li><li><h4 id="apollo-组件"><a href="#apollo-组件" class="headerlink" title="apollo 组件"></a>apollo 组件</h4><p>  在组件模版中编写 gql 查询，同时通过插槽<code>slot</code>分发请求结果,分别有<code>ApolloQuery</code>,<code>ApolloMutation</code>,<code>ApolloSubscribeToMore</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;  &lt;!-- Apollo 查询 --&gt;  &lt;ApolloQuery :query=<span class="hljs-string">&quot;/* 一些查询 */&quot;</span>&gt;    &lt;!-- 结果将自动更新 --&gt;    &lt;template slot-scope=<span class="hljs-string">&quot;&#123; result: &#123; data, loading &#125; &#125;&quot;</span>&gt;      &lt;!-- 一些内容 --&gt;      &lt;div v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;loading&quot;</span>&gt;Loading...&lt;/div&gt;      &lt;ul v-<span class="hljs-keyword">else</span>&gt;        &lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;user of data.users&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;user&quot;</span>&gt;          &#123;&#123; user.name &#125;&#125;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/template&gt;  &lt;/ApolloQuery&gt;&lt;/template&gt;</code></pre></div></li><li><h4 id="纯-api-封装"><a href="#纯-api-封装" class="headerlink" title="纯 api 封装"></a>纯 api 封装</h4><p>  基本上没有侵入性的使用方法，封装成函数式的 api，不需要在实例中插入<code>Apollo Provider</code>和<code>vue.use(vueApollo)</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 伪代码</span><span class="hljs-keyword">import</span> apolloclient<span class="hljs-keyword">import</span> gql图表文件<span class="hljs-comment">// apollo请求基于promise</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> xxxapi = <span class="hljs-keyword">async</span> (params) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> $apollo.query(&#123;    query:，    variables:&#123;&#125;,    fetchPolicy,    ...    ...各种参数  &#125;)&#125;</code></pre></div><p>  然后在你的 js 代码中引入,熟悉的味道熟悉的配方</p></li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>相较于<code>restful</code>少了大量处理数据的步骤，接口天然更加安全(参数类型参数数量对不上都会请求失败)，apollo 功能也是十分强大（轮询，分页，缓存），再回去用 restful 会有一种略难受的感觉。并且后端的同学也表示舒服。</p><p>之后打算在别的项目里陆续试一试智能查询和 apollo 组件，看看有没有耦合度低的接入方式或者复用的 apollo 组件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>graphql</tag>
      
      <tag>apollo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js设计模式</title>
    <link href="/2021/09/09/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/09/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://item.jd.com/11747684.html">javascript设计模式 张容铭</a></p><h2 id="创建性设计模式"><a href="#创建性设计模式" class="headerlink" title="创建性设计模式"></a>创建性设计模式</h2><ul><li><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><p>创建实例时，为了保证被new关键字正确调用，可在构造函数中加入对this指向的判断。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Factory = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Factory)&#123;    ...    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>(args)  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Factory(...args)  &#125;&#125;</code></pre></div></li><li><h3 id="简单工厂模式（静态工厂）"><a href="#简单工厂模式（静态工厂）" class="headerlink" title="简单工厂模式（静态工厂）"></a>简单工厂模式（静态工厂）</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建单独一类对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Factory</span>(<span class="hljs-params">name,age,gender</span>)</span>&#123;  <span class="hljs-keyword">const</span> o = &#123;&#125;  o.name = name  o.age = age  o.gender = gender  o.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;my name is&quot;</span>+  <span class="hljs-built_in">this</span>.name)  &#125;  <span class="hljs-keyword">return</span> o&#125;</code></pre></div></li><li><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建多类对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Factory</span>(<span class="hljs-params">...args</span>)</span>&#123;    ...&#125;Factory.prototype = &#123;  Product1:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">// 简单工厂</span>  &#125;,  Product2:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//简单工厂</span>  &#125;&#125;</code></pre></div></li><li><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul><li><code>抽象类</code>：没有任何属性，并且原形上的方法都被限制不能使用。</li><li>作用：假设子代都可能调用一些该类的必要方法，如果只是调用而不重写该方法，则会调用类上的被限制的版本而得到错误提示。<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Car = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;Car.prototype = &#123;  getPrice:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;抽象方法不能调用&quot;</span>)  &#125;,  getSpeed:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;抽象方法不能调用&quot;</span>)  &#125;&#125;</code></pre></div></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
