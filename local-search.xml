<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自动化测试</title>
    <link href="/2022/05/05/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/05/05/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><p>电脑代替你做回归测试</p><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>在编写代码逻辑阶段时进行报错提示</p><ul><li><code>typescript</code></li><li><code>eslint</code><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3>对应用程序中最小的单元（函数，组件）进行测试</li><li>有利于模块化设计，</li><li>代码覆盖率高</li><li>👎难以保证多个单元一起运行时的正确率</li></ul><p><a href="https://jestjs.io/"><code>Jest</code></a></p><p><code>Jest = Mocha + Chai + Sinon + mockserver + istanbul</code></p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>在浏览器环境或者想互相依赖的模块集成到一起进行测试</p><ul><li>从用户角度出发，就像写产品说明书</li><li>不关注代码逻辑细节，只关注行为</li><li>快速重构</li><li>👎代码覆盖率低</li><li>👎难以定位问题</li></ul><h3 id="端到端测试-E2E"><a href="#端到端测试-E2E" class="headerlink" title="端到端测试(E2E)"></a>端到端测试(E2E)</h3><p>通过操作浏览器的行为进行测试</p><ul><li>真实的运行环境</li><li>👎速度很慢</li><li>👎调试定位问题困难</li></ul><p><a href="https://www.cypress.io/"><code>Cyress</code></a></p><h3 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h3><p>通过对浏览器中的运行中的应用程序打快照进行对比(DOM结构)</p><ul><li>主要用于UI测试</li></ul><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><h3 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h3><p>代码被执行的比例</p><ul><li>行覆盖率（line coverage）：是否每一行都执行了？</li><li>函数覆盖率（function coverage）：是否每个函数都调用了？</li><li>分支覆盖率（branch coverage）：是否每个if代码块都执行了？</li><li>语句覆盖率（statement coverage）：是否每个语句都执行了？</li></ul><h3 id="需求覆盖率"><a href="#需求覆盖率" class="headerlink" title="需求覆盖率"></a>需求覆盖率</h3><p>由软件需求出发的测试(快照测试，端到端测试)，逻辑代码本身是个黑盒，只能人为标记需求覆盖率。</p><h2 id="测试开发"><a href="#测试开发" class="headerlink" title="测试开发"></a>测试开发</h2><h3 id="TDD-测试驱动开发"><a href="#TDD-测试驱动开发" class="headerlink" title="TDD 测试驱动开发"></a>TDD 测试驱动开发</h3><p>先写测试再写功能</p><ol><li>编写测试用例</li><li>运行测试</li><li>测试通过</li><li>重构代码</li><li>编写测试用例</li><li>…</li></ol><h4 id="TDD的原则"><a href="#TDD的原则" class="headerlink" title="TDD的原则"></a>TDD的原则</h4><ul><li>独立测试</li><li></li></ul><h3 id="BDD-行为驱动开发"><a href="#BDD-行为驱动开发" class="headerlink" title="BDD 行为驱动开发"></a>BDD 行为驱动开发</h3><p>实现功能后添加测试</p>]]></content>
    
    
    
    <tags>
      
      <tag>自动化测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Css In Js</title>
    <link href="/2022/04/22/css_in_js/"/>
    <url>/2022/04/22/css_in_js/</url>
    
    <content type="html"><![CDATA[<h1 id="Css-In-Js"><a href="#Css-In-Js" class="headerlink" title="Css In Js"></a>Css In Js</h1><blockquote><p>优点</p></blockquote><ul><li>css有自己的作用域</li><li>让组件更具可移植性，开箱即用</li><li>让样式具有动态功能(参数)</li><li>一个地方修改标签类型和标签参数</li><li>相比style能写更多（伪类，级联）</li></ul><blockquote><p>缺点</p></blockquote><ul><li>复杂度⬆️</li><li>class名混乱不语意<h2 id="Emotion"><a href="#Emotion" class="headerlink" title="Emotion"></a>Emotion</h2></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>css</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Immutable</title>
    <link href="/2022/04/20/Immutable/"/>
    <url>/2022/04/20/Immutable/</url>
    
    <content type="html"><![CDATA[<h1 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h1><ul><li><p>不可变数据</p></li><li><p>js不具备完整的数据不可变性，对于嵌套了引用数据类型依然是只拷贝地址</p></li><li><p>使用深拷贝，浪费性能且内存中会出现重复数据</p></li></ul><h2 id="Immutable-js"><a href="#Immutable-js" class="headerlink" title="Immutable.js"></a><code>Immutable.js</code></h2><p><a href="https://immutable-js.com/">https://immutable-js.com</a></p><ul><li>防止数据突变</li><li>提高性能</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx</title>
    <link href="/2022/04/19/react_mobx/"/>
    <url>/2022/04/19/react_mobx/</url>
    
    <content type="html"><![CDATA[<h1 id="MobX"><a href="#MobX" class="headerlink" title="MobX"></a>MobX</h1><h2 id="数据检测"><a href="#数据检测" class="headerlink" title="数据检测"></a>数据检测</h2><h3 id="autorun"><a href="#autorun" class="headerlink" title="autorun"></a><code>autorun</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">autorun</span>(<span class="hljs-attr">effect</span>: <span class="hljs-function">(<span class="hljs-params">reaction</span>) =&gt;</span> <span class="hljs-keyword">void</span>)</code></pre></div><ul><li>初始化执行一次</li><li>只能访问当前状态 <h3 id="reaction"><a href="#reaction" class="headerlink" title="reaction"></a><code>reaction</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">reaction</span>(<span class="hljs-function">() =&gt;</span> value, <span class="hljs-function">(<span class="hljs-params">value, previousValue, reaction</span>) =&gt;</span> &#123; sideEffect &#125;, options?)</code></pre></div></li><li>初始化不执行</li><li>能访问之前状态</li></ul><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><h4 id="强制绑定action的this指向"><a href="#强制绑定action的this指向" class="headerlink" title="强制绑定action的this指向"></a>强制绑定action的this指向</h4><ul><li>class中<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterStore</span>&#123;  count  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">count</span>)&#123;    <span class="hljs-title function_">makeObservable</span>(<span class="hljs-variable language_">this</span>,&#123;      <span class="hljs-attr">count</span>:observable,      <span class="hljs-attr">increase</span>:action.<span class="hljs-property">bound</span>    &#125;)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = count  &#125;  <span class="hljs-title function_">increase</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++  &#125;&#125;<span class="hljs-comment">// or 箭头函数</span>increase = <span class="hljs-function">()=&gt;</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;&#125;</code></pre></div></li><li>function中 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounterStore</span>(<span class="hljs-params">count</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">makeAutoObservable</span>(&#123;count,<span class="hljs-title function_">increase</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;&#125;,&#125;,&#123;&#125;, &#123; <span class="hljs-attr">autoBind</span>: <span class="hljs-literal">true</span> &#125;);&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>react</tag>
      
      <tag>mobx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redux</title>
    <link href="/2022/04/13/react_redux/"/>
    <url>/2022/04/13/react_redux/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li><p><code>Store</code> 状态容器</p><ul><li>  <code>store.dispatch(&#123;type:&#39;xxx&#39;&#125;)</code>触发 action</li><li>  <code>store.subscribe(()=&gt;&#123;...&#125;)</code>订阅状态</li><li>  <code>store.getState()</code>获取状态</li></ul></li><li><p>  <code>Reducer</code> 操作状态并返回新状态</p></li><li><p>  <code>Action</code> 描述对状态进行何种操作</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Actions</span> --&gt; <span class="hljs-title class_">Reducer</span> --&gt; <span class="hljs-title class_">Store</span><span class="hljs-title class_">Store</span> -[subscribe]-&gt; <span class="hljs-title class_">View</span><span class="hljs-title class_">View</span> -[dispatch]-&gt; <span class="hljs-title class_">Actions</span></code></pre></div><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><blockquote><p><code>Action</code>优先被<code>middleware</code>处理</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 模版格式</span>middleware = <span class="hljs-function">(<span class="hljs-params">store</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> &#123;<span class="hljs-comment">//...</span><span class="hljs-title function_">next</span>(action);&#125;;</code></pre></div><ul><li>  logger 中间件</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> logger = <span class="hljs-function">(<span class="hljs-params">store</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(store, action);<span class="hljs-title function_">next</span>(action);&#125;;</code></pre></div><h3 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a><code>redux-thunk</code></h3><p>将<code>action</code>改造为一个接收<code>dispatch</code>参数的函数</p><ul><li>  simple_thunk</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">thunk</span> = (<span class="hljs-params">store</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">next</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-comment">// 处理异步操作，action为一个函数</span><span class="hljs-keyword">const</span> &#123; dispatch &#125; = store;<span class="hljs-keyword">return</span> <span class="hljs-title function_">action</span>(dispatch);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-title function_">next</span>(action);&#125;&#125;;</code></pre></div><ul><li>  action</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// async action</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">increase</span> = (<span class="hljs-params">n = <span class="hljs-number">1</span></span>) =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">INCREASE</span>, <span class="hljs-attr">payload</span>: n &#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">increase_async</span> =(<span class="hljs-params">n = <span class="hljs-number">1</span></span>) =&gt;<span class="hljs-comment">// 接收dispatch</span><span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async&quot;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">increase</span>(n));&#125;, <span class="hljs-number">2000</span>);&#125;;</code></pre></div><ul><li>  挂载</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducers, <span class="hljs-title function_">applyMiddleware</span>(thunk));</code></pre></div><h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a><code>redux-saga</code></h3><p>可以将异步操作从<code>action creater</code>中抽离出来</p><ul><li>  action</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 和同步的action保持了一样的写法</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle_async</span> = (<span class="hljs-params">payload</span>) =&gt; (&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;toggle_async&quot;</span>, payload &#125;);</code></pre></div><ul><li>  saga 文件</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; takeEvery, put &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-saga/effects&quot;</span>;<span class="hljs-keyword">function</span>* <span class="hljs-title function_">toggle_async_fn</span>(<span class="hljs-params">action</span>) &#123;<span class="hljs-keyword">yield</span> <span class="hljs-title function_">put</span>(<span class="hljs-title function_">toggle</span>(action.<span class="hljs-property">payload</span>)); <span class="hljs-comment">//执行action</span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">modalSaga</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 接收actions</span><span class="hljs-keyword">yield</span> <span class="hljs-title function_">takeEvery</span>(<span class="hljs-string">&quot;toggle_async&quot;</span>, toggle_async_fn);&#125;</code></pre></div><ul><li>  挂载</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> createSagaMiddleware <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux-saga&quot;</span>;<span class="hljs-keyword">const</span> sagaMiddleware = <span class="hljs-title function_">createSagaMiddleware</span>();<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducers, <span class="hljs-title function_">applyMiddleware</span>(sagaMiddleware));sagaMiddleware.<span class="hljs-title function_">run</span>(modalSaga);</code></pre></div><h3 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a><code>redux-actions</code></h3><p>使用模版方法创建 action</p><ul><li>  action</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> increase = <span class="hljs-title function_">createAction</span>(<span class="hljs-string">&quot;INCREASE&quot;</span>);</code></pre></div><ul><li>  reducer</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> countReducer = <span class="hljs-title function_">handleActions</span>(&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([    [      increase,      <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> (&#123;        <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + action.<span class="hljs-property">payload</span>      &#125;)    ]])&#125;)</code></pre></div><h2 id="toolkit"><a href="#toolkit" class="headerlink" title="toolkit"></a>toolkit</h2><blockquote><p>简化 redux 流程的工具集</p></blockquote><h3 id="createSlice-configureStore"><a href="#createSlice-configureStore" class="headerlink" title="createSlice + configureStore"></a><code>createSlice</code> + <code>configureStore</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createSlice, configureStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@reduxjs/toolkit&quot;</span>;<span class="hljs-comment">// reducer 的key</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">TODO_FEATURE_KEY</span> = <span class="hljs-string">&quot;TODOS&quot;</span>;<span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">reducer</span>: <span class="hljs-title class_">TodoReducer</span>, actions &#125; = <span class="hljs-title function_">createSlice</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-variable constant_">TODO_FEATURE_KEY</span>,<span class="hljs-attr">initialState</span>: [],<span class="hljs-attr">reducers</span>: &#123;<span class="hljs-attr">addTodo</span>: &#123;<span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;state.<span class="hljs-title function_">push</span>(action.<span class="hljs-property">payload</span>);&#125;,<span class="hljs-attr">prepare</span>: <span class="hljs-function">(<span class="hljs-params">todoItem</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">payload</span>: &#123; <span class="hljs-attr">date</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), <span class="hljs-attr">title</span>: item &#125; &#125;;&#125;,&#125;,&#125;,&#125;);<span class="hljs-comment">// 配置store</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">TodoStore</span> = <span class="hljs-title function_">configureStore</span>(&#123;<span class="hljs-attr">reducer</span>: &#123; [<span class="hljs-variable constant_">TODO_FEATURE_KEY</span>]: <span class="hljs-title class_">TodoReducer</span> &#125;,<span class="hljs-attr">devTools</span>: process.<span class="hljs-property">env</span> !== <span class="hljs-string">&quot;production&quot;</span>,&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> &#123; addTodo &#125; = actions;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TodoStore</span>;</code></pre></div><h3 id="useSelect-useDispatch"><a href="#useSelect-useDispatch" class="headerlink" title="useSelect + useDispatch"></a><code>useSelect</code> + <code>useDispatch</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<span class="hljs-keyword">import</span> &#123; addTodo, <span class="hljs-variable constant_">TODO_FEATURE_KEY</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../store/slices&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-title function_">Todo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<span class="hljs-comment">// dispatch</span><span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();<span class="hljs-comment">// state</span><span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> state[<span class="hljs-variable constant_">TODO_FEATURE_KEY</span>]);<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleAddTodo</span> = (<span class="hljs-params"></span>) =&gt; &#123;<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>));inputRef.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;&quot;</span>;&#125;;&#125;;</code></pre></div><h3 id="createAsyncThunk"><a href="#createAsyncThunk" class="headerlink" title="createAsyncThunk"></a><code>createAsyncThunk</code></h3><ul><li>  dispatch 别的 action</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addTodo_async = <span class="hljs-title function_">createAsyncThunk</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;TODO_FEATURE_KEY&#125;</span>/addTodo_async`</span>, <span class="hljs-keyword">async</span> (payload, thunkApi) =&gt; &#123;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">resolve</span>(payload);&#125;, <span class="hljs-number">2000</span>);&#125;);thunkApi.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">addTodo</span>(p));&#125;);</code></pre></div><ul><li>  按照普通方式声明,在<code>extraReducer</code>中处理</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> addTodo_async2 = <span class="hljs-title function_">createAsyncThunk</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;TODO_FEATURE_KEY&#125;</span>/addTodo_async2`</span>, <span class="hljs-keyword">async</span> (payload) =&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">resolve</span>(payload);&#125;, <span class="hljs-number">2000</span>);&#125;);&#125;);<span class="hljs-comment">// reducerCreater</span><span class="hljs-attr">reducers</span>:&#123;<span class="hljs-comment">// build callback风格</span><span class="hljs-attr">extraReducers</span>: <span class="hljs-function">(<span class="hljs-params">builder</span>) =&gt;</span> &#123;builder.<span class="hljs-title function_">addCase</span>(addTodo_async2.<span class="hljs-property">fulfilled</span>, <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;action.<span class="hljs-property">payload</span> = &#123;<span class="hljs-attr">date</span>:(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">toString</span>(),<span class="hljs-attr">title</span>:action.<span class="hljs-property">payload</span>&#125;state.<span class="hljs-title function_">push</span>(action.<span class="hljs-property">payload</span>);&#125;)&#125;<span class="hljs-comment">// Map Object 风格</span><span class="hljs-attr">extraReducers</span>:&#123;[addTodo_async2.<span class="hljs-property">fulfilled</span>]: <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> &#123;state.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">date</span>:(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()).<span class="hljs-title function_">toString</span>(),<span class="hljs-attr">title</span>:action.<span class="hljs-property">payload</span>&#125;);&#125;&#125;&#125;</code></pre></div><ul><li>  <code>createEntityAdapter </code> + <code>createSelector</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// &#123;</span><span class="hljs-comment">// ids:[],</span><span class="hljs-comment">// entities:[]</span><span class="hljs-comment">// &#125;</span><span class="hljs-keyword">const</span> todoAdapter = <span class="hljs-title function_">createEntityAdapter</span>(<span class="hljs-comment">// &#123;</span><span class="hljs-comment">// selectId:x=&gt;x.xxId// 手动指定id</span><span class="hljs-comment">// 必须有ID，默认就是entity =&gt; entity.id</span><span class="hljs-comment">// sortComparer: (a, b) =&gt; a.title.localeCompare(b.title),// 排序方法</span><span class="hljs-comment">// &#125;</span>);<span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">reducer</span>: <span class="hljs-title class_">TodoReducer</span>, actions &#125; = <span class="hljs-title function_">createSlice</span>(&#123;<span class="hljs-attr">name</span>: <span class="hljs-variable constant_">TODO_FEATURE_KEY</span>,<span class="hljs-attr">initialState</span>: todoAdapter.<span class="hljs-title function_">getInitialState</span>(),<span class="hljs-attr">reducers</span>: &#123;<span class="hljs-attr">addTodo</span>: &#123;<span class="hljs-comment">// reducer: (state, action) =&gt; &#123;</span><span class="hljs-comment">// todoAdapter.addOne(state,action.payload)</span><span class="hljs-comment">// &#125;,</span><span class="hljs-comment">// 简化为</span><span class="hljs-attr">reducer</span>: todoAdapter.<span class="hljs-property">addOne</span>&#125;,&#125;,&#125;);<span class="hljs-keyword">const</span> &#123;selectAll&#125; = todoAdapter.<span class="hljs-title function_">getSelector</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> todoSelector = <span class="hljs-title function_">createSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span>=&gt;</span>state[<span class="hljs-variable constant_">TODO_FEATURE_KEY</span>],selectAll)<span class="hljs-comment">// 组件中</span><span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useSelector</span>(todoSelector)<span class="hljs-comment">// 优化前</span><span class="hljs-keyword">const</span> todos = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span>=&gt;</span>state[<span class="hljs-variable constant_">TODO_FEATURE_KEY</span>].<span class="hljs-property">entities</span>)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>react</tag>
      
      <tag>redux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端渲染</title>
    <link href="/2022/04/12/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/04/12/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="同构渲染"><a href="#同构渲染" class="headerlink" title="同构渲染"></a>同构渲染</h1><p>服务端负责输出首屏，余下部分传输给客户端渲染</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>ssr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化</title>
    <link href="/2022/04/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <url>/2022/04/06/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="工程化流程"><a href="#工程化流程" class="headerlink" title="工程化流程"></a>工程化流程</h1><pre><code class=" mermaid">graph LRA(创建项目)  --&gt; B(编码) --&gt; C(开发/预览) --&gt; D(提交) --&gt; F(部署)脚手架生成  --&gt; 代码格式化/风格校验 --&gt; 热更新/Mock数据 --&gt; GitHooks --&gt; CI/CD</code></pre><h1 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h1><h2 id="脚手架结构"><a href="#脚手架结构" class="headerlink" title="脚手架结构"></a>脚手架结构</h2><ul><li>制定 cli 入口文件  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// package.json</span>&#123;  <span class="hljs-string">&#x27;bin&#x27;</span>:<span class="hljs-string">&#x27;cli.js&#x27;</span>&#125;</code></pre></div></li><li>cli 入口文件头部  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ./cli.js</span>#!<span class="hljs-regexp">/usr/</span>bin/env node</code></pre></div></li><li>命令结构  <div class="hljs code-wrapper"><pre><code class="hljs javascript">cli &lt;command&gt;  [options]  --options params&lt;!-- <span class="hljs-comment">// eg: --&gt;</span>vue create my_app -p env=...</code></pre></div></li></ul><h2 id="npm-包本地开发"><a href="#npm-包本地开发" class="headerlink" title="npm 包本地开发"></a>npm 包本地开发</h2><ul><li><p>链接本地 npm 包的依赖库</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// xxx-lib dir</span>npm link<span class="hljs-comment">// current module package.json</span><span class="hljs-attr">dependencies</span>:&#123;+    <span class="hljs-string">&quot;xxx-lib&quot;</span>:<span class="hljs-string">&quot;^1.0.0&quot;</span>&#125;<span class="hljs-comment">// current module dir</span>npm link xx-lib</code></pre></div></li><li><p>解除本地 xxx-lib 和当前包的链接</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// xxx-lib dir</span>npm unlink<span class="hljs-comment">// current module dir</span>rm -rf node_modulesnpm unlink xxx-lib</code></pre></div></li><li><p>链接当前项目到全局<code>node_modules</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">npm link/unlink</code></pre></div></li><li><p>相对于当前<code>node_modules</code>操作</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">npm link B <span class="hljs-comment">// 添加依赖B</span>npm unlink B <span class="hljs-comment">//  移除依赖B</span></code></pre></div></li></ul><h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><p>基于 Git+Npm 的多 package 项目管理工具</p><ol><li><p>解决原生脚手架开发中的重复操作</p><ul><li>多 package 本地 link</li><li>多 package 依赖安装</li><li>多 package 单元测试</li><li>多 package 代码提交</li><li>多 package 代码发布</li></ul></li><li><p>解决版本一致性</p><ul><li>package 版本一致</li><li>相互依赖版本升级</li></ul></li></ol><h3 id="lerna-开发-module-流程"><a href="#lerna-开发-module-流程" class="headerlink" title="lerna 开发 module 流程"></a>lerna 开发 module 流程</h3><ol><li><p>项目创建</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">npm initnpm i lernalerna init</code></pre></div></li><li><p>创建 package</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">lerna create <span class="hljs-comment">// 创建package</span>lerna add <span class="hljs-comment">//安装依赖</span>lerna <span class="hljs-comment">//链接依赖</span></code></pre></div></li><li><p>开发测试</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">lerna exec <span class="hljs-comment">// 执行shell脚本</span>lerna runlerna clean <span class="hljs-comment">// 清空依赖</span>lerna bootstrap <span class="hljs-comment">// 重装依赖</span></code></pre></div></li><li><p>发布上线</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">lerna version <span class="hljs-comment">// 提升版本号</span>lerna change <span class="hljs-comment">//  查看变更</span>lerna diff <span class="hljs-comment">// 查看diff</span>lerna public <span class="hljs-comment">// 发布</span></code></pre></div></li></ol><h2 id="Yeoman"><a href="#Yeoman" class="headerlink" title="Yeoman"></a>Yeoman</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>  命名规范<code>generator-&lt;name&gt;</code></li><li>  目录规范</li></ul><div class="hljs code-wrapper"><pre><code class="hljs node">-generators -app - // 默认生成器index.js - // 默认实现other - // 其他生成器index.js - // 其他生成器实现package.json; // 模块包配置文件</code></pre></div><ul><li>  新建包文件夹</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ./generator-xxx</span>yarn inityarn add yeoman-generator <span class="hljs-comment">// 必要依赖</span></code></pre></div><ul><li>  所有生成器都继承<code>yeoman-generator</code>类</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ./app/index.js</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">Generator</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;yeoman-generator&quot;</span>);</code></pre></div><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ./app/index.js</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Generator</span> &#123;<span class="hljs-title function_">writing</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// 写入文件</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">write</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">destinationPath</span>(<span class="hljs-string">&quot;random.txt&quot;</span>), <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>());&#125;&#125;;</code></pre></div><ul><li>  <code>link</code>出<code>npm</code>包并测试</li></ul><div class="hljs code-wrapper"><pre><code class="hljs bash">yarn <span class="hljs-built_in">link</span><span class="hljs-built_in">cd</span> desktopyo &lt;你的generator名&gt;<span class="hljs-comment"># desktop/random.txt</span><span class="hljs-comment"># 随机数</span></code></pre></div><h3 id="接收用户输入"><a href="#接收用户输入" class="headerlink" title="接收用户输入"></a>接收用户输入</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">prompting</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">prompt</span>([&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;input&quot;</span>,<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;your project name&quot;</span>,<span class="hljs-attr">default</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">appname</span>,&#125;,]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">answers</span> = a    <span class="hljs-comment">// 挂在到全局对象answers</span>    <span class="hljs-comment">// &#123; name: &#x27;123&#x27; &#125;</span>&#125;);&#125;</code></pre></div><h3 id="使用模版"><a href="#使用模版" class="headerlink" title="使用模版"></a>使用模版</h3><p><a href="https://ejs.co/#docs">EJS 语法</a></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- app/templates/bar.html --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&lt;%=name %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// app/index.js</span><span class="hljs-comment">// 模版文件路径</span><span class="hljs-keyword">const</span> tmpl = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">templatePath</span>(<span class="hljs-string">&quot;bar.html&quot;</span>);<span class="hljs-keyword">const</span> output = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">destinationPath</span>(<span class="hljs-string">&quot;bar.html&quot;</span>);<span class="hljs-keyword">const</span> context = <span class="hljs-variable language_">this</span>.<span class="hljs-property">answers</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">fs</span>.<span class="hljs-title function_">copyTpl</span>(tmpl, output, context);</code></pre></div><p>生成</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h2 id="Plop"><a href="#Plop" class="headerlink" title="Plop"></a>Plop</h2><p>小型的脚手架工具,<a href="https://github.com/plopjs/plop">=&gt;</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>项目中安装 plop</p> <div class="hljs code-wrapper"><pre><code class="hljs bash">yarn add plop</code></pre></div></li><li><p><code>plopfile.js</code></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function"><span class="hljs-params">plop</span> =&gt;</span> &#123;  plop.<span class="hljs-title function_">setGenerator</span>(<span class="hljs-string">&#x27;component&#x27;</span>,&#123;    <span class="hljs-attr">description</span>:<span class="hljs-string">&#x27;create a component&#x27;</span>,    <span class="hljs-attr">prompts</span>:[      &#123;        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;input&#x27;</span>,        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;name&#x27;</span>,        <span class="hljs-attr">message</span>:<span class="hljs-string">&#x27;your component name&#x27;</span>,        <span class="hljs-attr">default</span>:<span class="hljs-string">&#x27;My Component&#x27;</span>      &#125;    ],    <span class="hljs-attr">actions</span>:[ <span class="hljs-comment">// 多个action</span>      &#123;        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;add&#x27;</span><span class="hljs-comment">// 添加文件</span>        <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&#x27;</span>,        <span class="hljs-attr">templateFile</span>:<span class="hljs-string">&#x27;plop-templates/component.hbs&#x27;</span>      &#125;,      &#123;        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;add&#x27;</span>,        <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.css&#x27;</span>,        <span class="hljs-attr">templateFile</span>:<span class="hljs-string">&#x27;plop-template/component.css.hbs&#x27;</span>      &#125;    ]  &#125;)&#125;</code></pre></div></li><li><p>模版文件<br> <a href="https://github.com/handlebars-lang/handlebars.js">handlebars</a></p><div class="hljs code-wrapper"><pre><code class="hljs"> <pre><code class="hljs javascript"><span class="hljs-comment">// plop-templates/components.hbs</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; &#123;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;&#123;&#123;name&#125;&#125;&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123;name&#125;&#125; Component<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;</code></pre></div></code></pre></li><li><p>usage</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript">yarn plop component</code></pre></div></li></ol><h1 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h1><h3 id="npm-script"><a href="#npm-script" class="headerlink" title="npm script"></a>npm script</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&quot;script&quot;</span>:&#123;  <span class="hljs-string">&quot;build&quot;</span>:<span class="hljs-string">&quot;sass main.sass main.css -watch&quot;</span>,  <span class="hljs-string">&quot;preserve&quot;</span>:<span class="hljs-string">&quot;yarn build&quot;</span>,  <span class="hljs-string">&quot;serve&quot;</span>:<span class="hljs-string">&quot;browser-sync .&quot;</span>, <span class="hljs-comment">//  browser-sync</span>  <span class="hljs-string">&quot;start&quot;</span>:<span class="hljs-string">&quot;run-p build serve&quot;</span> <span class="hljs-comment">// npm-run-all</span>&#125;</code></pre></div><h2 id="Grunt-过气回个春"><a href="#Grunt-过气回个春" class="headerlink" title="Grunt(过气回个春)"></a>Grunt(过气回个春)</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// __dir/gruntfile.js</span>modules.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">grunt</span>) =&gt;</span> &#123;grunt.<span class="hljs-title function_">registerTask</span>(<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">//  使用yarn grunt就能执行</span>&#125;);grunt.<span class="hljs-title function_">registerTask</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;foo 的描述&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 使用yarn grunt foo执行</span>&#125;);grunt.<span class="hljs-title function_">registerTask</span>(<span class="hljs-string">&quot;default&quot;</span>, [<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>]);&#125;;</code></pre></div><h3 id="异步-task"><a href="#异步-task" class="headerlink" title="异步 task"></a>异步 task</h3><p>grunt task 默认是同步代码</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">grunt</span>) =&gt;</span> &#123;<span class="hljs-comment">// 异步任务要获取this,不能用=&gt;函数</span>grunt.<span class="hljs-title function_">registerTask</span>(<span class="hljs-string">&quot;async-task&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> done = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>();<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// ...</span><span class="hljs-title function_">done</span>(); <span class="hljs-comment">// 调用这个done才结束task</span>&#125;, <span class="hljs-number">3000</span>);&#125;);&#125;;</code></pre></div><h3 id="task-失败"><a href="#task-失败" class="headerlink" title="task 失败"></a>task 失败</h3><ul><li>在 task 中<code>return false</code>标记 task 失败  <div class="hljs code-wrapper"><pre><code class="hljs javascript">grup.<span class="hljs-title function_">registerTask</span>(<span class="hljs-string">&quot;fail-task&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">//...</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;);</code></pre></div></li><li>在异步 task 中给 done 传 false 参数  <div class="hljs code-wrapper"><pre><code class="hljs javascript">grup.<span class="hljs-title function_">registerTask</span>(<span class="hljs-string">&quot;fail-async-task&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> done = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">async</span>();<span class="hljs-comment">//...</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">//...</span><span class="hljs-title function_">done</span>(<span class="hljs-literal">false</span>);&#125;, <span class="hljs-number">3000</span>);&#125;);</code></pre></div></li><li>  如果是一个 task 数组，会在失败处中断</li><li>  可以加上<code>--force</code>强行执行所有 task</li></ul><h3 id="task-配置"><a href="#task-配置" class="headerlink" title="task 配置"></a>task 配置</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">grunt</span>) =&gt;</span> &#123;grunt.<span class="hljs-title function_">initConfig</span>(&#123;<span class="hljs-attr">foo</span>: &#123;<span class="hljs-attr">bar</span>: <span class="hljs-string">&quot;666&quot;</span>,&#125;,&#125;);grunt.<span class="hljs-title function_">registerTask</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 获取配置</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grunt.<span class="hljs-title function_">config</span>()); <span class="hljs-comment">// &#123; foo: &#123; bar: &#x27;666&#x27; &#125; &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grunt.<span class="hljs-title function_">config</span>(<span class="hljs-string">&quot;foo&quot;</span>)); <span class="hljs-comment">// &#123; bar: &#x27;666&#x27; &#125;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grunt.<span class="hljs-title function_">config</span>(<span class="hljs-string">&quot;foo.bar&quot;</span>)); <span class="hljs-comment">// 666</span>&#125;);&#125;;</code></pre></div><h3 id="多目标任务"><a href="#多目标任务" class="headerlink" title="多目标任务"></a>多目标任务</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">grunt.<span class="hljs-title function_">initConfig</span>(&#123;<span class="hljs-string">&quot;multi-task1&quot;</span>: &#123;<span class="hljs-attr">options</span>: &#123;<span class="hljs-comment">// 任务配置选项</span><span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;,<span class="hljs-comment">// 除了options外都会注册为目标</span><span class="hljs-attr">t1</span>: <span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-attr">t2</span>: &#123;<span class="hljs-attr">options</span>: &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;baz&quot;</span>,&#125;,<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;target222&quot;</span>,&#125;,&#125;,&#125;);grunt.<span class="hljs-title function_">registerMultiTask</span>(<span class="hljs-string">&quot;multi-task1&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">options</span>(), <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">options</span> ? <span class="hljs-string">&quot;options被覆盖&quot;</span> : <span class="hljs-string">&quot;无覆盖的options&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`target=&gt;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.target&#125;</span>;data=&gt;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.data.name&#125;</span>`</span>);<span class="hljs-comment">// Running &quot;multi:t1&quot; (multi) task</span><span class="hljs-comment">// &#123; foo: &#x27;bar&#x27; &#125; 无覆盖的options</span><span class="hljs-comment">// target=&gt;t1;data=&gt;undefined</span><span class="hljs-comment">// Running &quot;multi:t2&quot; (multi) task</span><span class="hljs-comment">// &#123; foo: &#x27;baz&#x27; &#125; options被覆盖</span><span class="hljs-comment">// target=&gt;t2;data=&gt;target222</span>&#125;);</code></pre></div><ul><li>  只执行单个目标</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">yarn gulp multi-<span class="hljs-attr">task1</span>:[目标名]</code></pre></div><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://www.gruntjs.net/plugins">https://www.gruntjs.net/plugins</a><br>命名规范:<code>grunt-contrib-[pluginName]</code></p><ul><li><p>grunt-contrib-clean</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 是一个多目标任务</span>grunt.<span class="hljs-title function_">initConfig</span>(&#123;<span class="hljs-comment">// 配置插件</span><span class="hljs-attr">clean</span>: &#123;<span class="hljs-attr">cleanTestDirText</span>: <span class="hljs-string">&quot;test/*.txt&quot;</span>, <span class="hljs-comment">// 删除./test/*.txt</span><span class="hljs-attr">cleanTestAllDir</span>: <span class="hljs-string">&quot;testAll/*&quot;</span>, <span class="hljs-comment">//  删除./testAll/*</span>&#125;,&#125;);<span class="hljs-comment">// 加载插件</span>grunt.<span class="hljs-title function_">loadNpmTasks</span>(<span class="hljs-string">&quot;grunt-contrib-clean&quot;</span>);</code></pre></div></li><li><p>grunt-sass</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">grunt.<span class="hljs-title function_">initConfig</span>(&#123;<span class="hljs-comment">// 配置插件</span><span class="hljs-attr">sass</span>: &#123;<span class="hljs-attr">options</span>: &#123;<span class="hljs-attr">sourceMap</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">implementation</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;sass&quot;</span>),&#125;,<span class="hljs-attr">main</span>: &#123;<span class="hljs-comment">// &lt;!-- output input --&gt;</span><span class="hljs-string">&quot;dist/style/main.css&quot;</span>: <span class="hljs-string">&quot;src/style/main.scss&quot;</span>,&#125;,&#125;,&#125;);<span class="hljs-comment">// 加载插件</span>grunt.<span class="hljs-title function_">loadNpmTasks</span>(<span class="hljs-string">&quot;grunt-contrib-clean&quot;</span>);</code></pre></div></li><li><p>grunt-babel</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用merge方法添加配置，直接重写会覆盖</span>grunt.<span class="hljs-property">config</span>.<span class="hljs-title function_">merge</span>(&#123;<span class="hljs-comment">// 配置插件</span><span class="hljs-attr">babel</span>: &#123;<span class="hljs-attr">options</span>: &#123;<span class="hljs-attr">presets</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>],<span class="hljs-attr">sourceMap</span>: <span class="hljs-literal">true</span>,&#125;,<span class="hljs-attr">main</span>: &#123;<span class="hljs-attr">files</span>: &#123;<span class="hljs-string">&quot;dist/js/app.js&quot;</span>: <span class="hljs-string">&quot;src/js/app.js&quot;</span>,&#125;,<span class="hljs-comment">// &lt;!-- output input --&gt;</span>&#125;,&#125;,&#125;);<span class="hljs-comment">// grunt.loadNpmTasks(&#x27;grunt-contrib-clean&#x27;)</span><span class="hljs-comment">// grunt.loadNpmTasks(&#x27;grunt-sass&#x27;)</span><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;load-grunt-tasks&quot;</span>)(grunt, &#123;<span class="hljs-attr">pattern</span>: <span class="hljs-string">&quot;grunt-babel&quot;</span>, <span class="hljs-comment">// 只匹配了babel</span>&#125;);</code></pre></div></li></ul><h4 id="load-grunt-tasks"><a href="#load-grunt-tasks" class="headerlink" title="load-grunt-tasks"></a>load-grunt-tasks</h4><p>This module will read the dependencies/devDependencies/peerDependencies/optionalDependencies in your package.json and load grunt tasks that match the provided patterns.</p><ul><li>  使用</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 上面的grunt-sass可以改为</span><span class="hljs-keyword">const</span> load = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;load-grunt-tasks&quot;</span>);<span class="hljs-title function_">load</span>(grunt); <span class="hljs-comment">// 加载dependencies/devDependencies/peerDependencies/optionalDependencies中所有tasks</span><span class="hljs-title function_">load</span>();</code></pre></div><ul><li>  选项</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;load-grunt-tasks&quot;</span>)(grunt, &#123;<span class="hljs-attr">pattern</span>: <span class="hljs-string">&quot;grunt-contrib-*&quot;</span>, <span class="hljs-comment">//  正则</span><span class="hljs-attr">config</span>: <span class="hljs-string">&quot;../package.json&quot;</span>,<span class="hljs-attr">scope</span>: <span class="hljs-string">&quot;devDependencies&quot;</span>, <span class="hljs-comment">// load范围</span><span class="hljs-attr">requireResolution</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 在全部文件中查找而不仅是 node_modules</span>&#125;);</code></pre></div><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><p>基于流的构建工具</p><p>默认任务都是异步的，需要手动调用结束任务</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// gulpfile.js</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">foo</span> = <span class="hljs-function">(<span class="hljs-params">done</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">done</span>();&#125;, <span class="hljs-number">2000</span>);&#125;;<span class="hljs-comment">// 默认任务，yarn gulp就行</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">default</span> = <span class="hljs-function">(<span class="hljs-params">done</span>) =&gt;</span> &#123;<span class="hljs-comment">//...</span><span class="hljs-title function_">done</span>();&#125;;<span class="hljs-comment">// 标记失败</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">failTask</span> = <span class="hljs-function">(<span class="hljs-params">done</span>) =&gt;</span> &#123;<span class="hljs-title function_">done</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;task fail&quot;</span>));&#125;;</code></pre></div><h3 id="串行任务"><a href="#串行任务" class="headerlink" title="串行任务"></a>串行任务</h3><p>按顺序执行，阻塞</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; series &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;gulp&quot;</span>);<span class="hljs-built_in">exports</span>.<span class="hljs-property">s1</span> = <span class="hljs-title function_">series</span>(<span class="hljs-string">&quot;t1&quot;</span>, <span class="hljs-string">&quot;t2&quot;</span>);</code></pre></div><h3 id="并行任务"><a href="#并行任务" class="headerlink" title="并行任务"></a>并行任务</h3><p>同时执行</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; parallel &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;gulp&quot;</span>);<span class="hljs-built_in">exports</span>.<span class="hljs-property">p1</span> = <span class="hljs-title function_">series</span>(<span class="hljs-string">&quot;t1&quot;</span>, <span class="hljs-string">&quot;t2&quot;</span>);</code></pre></div><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><ul><li><p>promise</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 支持promise</span><span class="hljs-built_in">exports</span>.<span class="hljs-property">p1</span> = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();&#125;;<span class="hljs-built_in">exports</span>.<span class="hljs-property">p1Fail</span> = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;task fail&quot;</span>));&#125;;</code></pre></div></li><li><p>async/await</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 支持async await</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">timeout</span> = (<span class="hljs-params">wait</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, wait));<span class="hljs-built_in">exports</span>.<span class="hljs-property">a1</span> = <span class="hljs-keyword">async</span> () =&gt; &#123;<span class="hljs-keyword">await</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-number">3000</span>);&#125;;</code></pre></div></li><li><p>stream</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">exports</span>.<span class="hljs-property">s1</span> = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">&quot;src/source.txt&quot;</span>);<span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">&quot;dist/dist.txt&quot;</span>);readStream.<span class="hljs-title function_">pipe</span>(writeStream);<span class="hljs-keyword">return</span> readStream;&#125;;</code></pre></div></li></ul><h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><pre><code class=" mermaid">graph LRA[读取流] --&gt; B[转换流] --&gt; c[写入流]</code></pre><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; src, dest &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;gulp&quot;</span>);<span class="hljs-keyword">const</span> cleanCss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;gulp-clean-css&quot;</span>);<span class="hljs-keyword">const</span> rename = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;gulp-rename&quot;</span>);<span class="hljs-built_in">exports</span>.<span class="hljs-property">sample</span> = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">src</span>(<span class="hljs-string">&quot;src/style/*.css&quot;</span>) <span class="hljs-comment">// 读取</span>.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">cleanCss</span>()) <span class="hljs-comment">//转换</span>.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">rename</span>(&#123; <span class="hljs-attr">extname</span>: <span class="hljs-string">&quot;.min.css&quot;</span> &#125;)) <span class="hljs-comment">//转换</span>.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">dest</span>(<span class="hljs-string">&quot;dist/css&quot;</span>)); <span class="hljs-comment">//  写入</span>&#125;;</code></pre></div><h3 id="自动化构建例子"><a href="#自动化构建例子" class="headerlink" title="自动化构建例子"></a>自动化构建例子</h3><ul><li>  插件命名规范</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">gulp - [name];</code></pre></div><ul><li>  自动加载插件</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> loadPlugins = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;gulp-load-plugins&quot;</span>);<span class="hljs-comment">// 使用时使用驼峰名</span><span class="hljs-keyword">const</span> plugins = <span class="hljs-title function_">loadPlugins</span>(); <span class="hljs-comment">// &#123;...plugins&#125;</span></code></pre></div><p><a href="https://github.com/Tatekii/zce-gulp-demo">zce-gulp-demo</a></p><h2 id="FIS"><a href="#FIS" class="headerlink" title="FIS"></a>FIS</h2><p>看看就好<a href="https://github.com/fex-team/fis3">JUMP TO fis3</a></p><h1 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h1><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>模块化打包工具</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>从入口 js 文件出发，通过各个模块的<code>require</code>或者<code>import</code>，解析出一颗包含所有使用到资源的依赖树</li><li>递归这颗，对不同的资源类型根据<code>rules</code>使用不同的的<code>loader</code>加载</li><li>各个模块加载的结果会作为一个个自执行函数放入<code>bundle</code>中，以拥有独立的作用域</li><li>并且模块的加载存在缓存机制，重复加载的模块将直接从缓存对象中读取</li><li>在打包过程中特定时机广播出特定钩子，<code>plugin</code>在对应的时机自动执行</li></ol><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p><a href="https://webpack.js.org/api/compiler-hooks/">https://webpack.js.org/api/compiler-hooks/</a></p><h4 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span>&#123;<span class="hljs-attr">module</span>: &#123;<span class="hljs-attr">rules</span>: [&#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/i</span>,<span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;html-loader&#x27;</span>,<span class="hljs-string">&quot;./md-loader.js&quot;</span>]&#125;,],&#125;,&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// markdown-loader</span><span class="hljs-keyword">const</span> &#123; parse &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;marked&quot;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">source</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">parse</span>(source); <span class="hljs-comment">// 交给下一个loader导出</span><span class="hljs-keyword">return</span> <span class="hljs-string">`module.exports = <span class="hljs-subst">$&#123;parse(source)&#125;</span>`</span>; <span class="hljs-comment">// 这是最后的一个loader</span>&#125;;</code></pre></div><h4 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// webpack.config.js</span>&#123;<span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>()],&#125;</code></pre></div><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><ul><li><p>html-webpack-plugin</p><ul><li>魔法字符串<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">plugins</span>: &#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&quot;my title&quot;</span>,&#125;);&#125;</code></pre></div></li></ul></li><li><p>webpack-dev-server</p><ul><li>  HMR 热更新</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// js</span><span class="hljs-keyword">import</span> myModule <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./myModule.js&quot;</span>;<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;./myModule&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 回调函数中是新的状态</span><span class="hljs-comment">//...手动处理热替换逻辑</span>&#125;);<span class="hljs-comment">// pic</span><span class="hljs-keyword">import</span> pic1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./pic1&quot;</span>;<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&quot;./pic1&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 更换图片src</span>&#125;);</code></pre></div><ul><li>  <code>devServer:&#123;hotOnly:true&#125;</code> 只替换不自动刷新</li></ul></li><li><p>  cheap-module-eval-sourceMap</p></li><li><p>webpack-merge</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>)<span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">merge</span>(common,&#123;    <span class="hljs-attr">mode</span>:<span class="hljs-string">&quot;development&quot;</span>,    <span class="hljs-attr">plugins</span>:[...],    <span class="hljs-attr">module</span>:&#123;...&#125;&#125;)</code></pre></div></li><li><p>DefinePlugin</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DefinePlugin</span>(&#123;<span class="hljs-attr">API_ROOT</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&quot;http:www.example.com/api&quot;</span>),&#125;),];</code></pre></div></li></ul><h4 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">optimization</span>:&#123;    <span class="hljs-comment">// 摇树</span>    <span class="hljs-attr">usedExports</span>:<span class="hljs-literal">true</span>,    <span class="hljs-comment">// 作用域提升，尽量将模块合并到一个函数中</span>    <span class="hljs-attr">concatenateModules</span>:<span class="hljs-literal">true</span>,    <span class="hljs-comment">// 压缩</span>    <span class="hljs-attr">minimize</span>:<span class="hljs-literal">true</span>,    <span class="hljs-comment">// 检查package.json中声明代码有无副作用</span>    <span class="hljs-attr">sideEffects</span>:<span class="hljs-literal">true</span>，    <span class="hljs-comment">// 提取公共模块</span>    <span class="hljs-attr">splitChunks</span>:<span class="hljs-literal">true</span>&#125;,<span class="hljs-attr">plugins</span>:&#123;    <span class="hljs-comment">// 多入口打包</span>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;        <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;Home&#x27;</span>,        <span class="hljs-attr">template</span>:<span class="hljs-string">&#x27;./src/index.html&#x27;</span>,        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;index.html&#x27;</span>,        <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;index&#x27;</span>]    &#125;),    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;        <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;About&#x27;</span>,        <span class="hljs-attr">template</span>:<span class="hljs-string">&#x27;./src/about.html&#x27;</span>,        <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;about.html&#x27;</span>,        <span class="hljs-attr">chunks</span>:[<span class="hljs-string">&#x27;about&#x27;</span>]    &#125;)&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//&lt;!-- package.json --&gt;</span>&#123;<span class="hljs-attr">sideEffects</span>: [<span class="hljs-string">&quot;/src/*.js&quot;</span>, <span class="hljs-string">&quot;/src/**/*.css&quot;</span>];&#125;</code></pre></div><ul><li><p>动态导入</p><ul><li>  import 资源返回一个 promise</li></ul></li><li><p>  魔法注释</p></li><li><p>MiniCssExtractPlugin 提取 css</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">module</span>:&#123;    <span class="hljs-attr">rules</span>:[        &#123;            <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.css$/</span>,            <span class="hljs-attr">use</span>:[                <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,                <span class="hljs-comment">//&#x27;style-loader&#x27;用来添加style标签</span>                <span class="hljs-string">&#x27;css-loader&#x27;</span>            ]        &#125;    ]&#125;, <span class="hljs-attr">plugins</span>:[     <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()]<span class="hljs-comment">// js，css代码压缩</span><span class="hljs-attr">optimization</span>:&#123;    <span class="hljs-attr">minimizer</span>:&#123; <span class="hljs-comment">// 手动指定压缩选项</span>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCssAssetsWebpackPlugin</span>()        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserWebpackPlugin</span>()    &#125;&#125;</code></pre></div></li><li><p>hash</p><ul><li>  <code>[hash]</code>项目级别</li><li>  <code>[chunkhash]</code>chunk 级别，同一个 chunk 到文件 hash 都相同</li><li>  <code>[contenthash]</code>文件级别，根据内容生成</li><li>  <code>[hash:8]</code>手动指定 hash 长度</li></ul></li></ul><h2 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h2><p>ESModule 模块打包器</p><ul><li>  自动摇树</li><li>  打包 npm 模块能力(node_module/)</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> resolve <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-plugin-node-resolve&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">resolve</span>()],&#125;;</code></pre></div><ul><li>  支持 commonjs 模块</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> commonjs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;rollup-commonjs-plugin&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">commonjs</span>()],&#125;;</code></pre></div><ul><li>  动态引入/代码分割</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">output</span>:&#123;  <span class="hljs-comment">// file:&#x27;dist/bundle.js&#x27;,</span>  <span class="hljs-comment">// format:&#x27;iife&#x27;</span>  <span class="hljs-attr">dir</span>:<span class="hljs-string">&#x27;dist&#x27;</span>,<span class="hljs-comment">// 只能指定目录</span>  <span class="hljs-attr">format</span>:<span class="hljs-string">&#x27;amd&#x27;</span><span class="hljs-comment">// 不能使用iife格式</span>&#125;,</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// moduleA.js</span><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./moduleB.js&#x27;</span>).<span class="hljs-title function_">then</span>(&#123;m&#125;=&gt;&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-property">default</span>)&#125;)</code></pre></div><ul><li>  多入口打包</li></ul><p>自动代码分割提取公共模块</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<span class="hljs-attr">input</span>: [<span class="hljs-comment">// 直接改成数组</span>],&#125;;</code></pre></div><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p><strong>0 配置</strong></p><p><a href="https://parceljs.org/">https://parceljs.org/</a></p><h1 id="代码校验"><a href="#代码校验" class="headerlink" title="代码校验"></a>代码校验</h1><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p><a href="https://eslint.org/docs/user-guide/getting-started">https://eslint.org/docs/user-guide/getting-started</a></p><h2 id="StyleLint"><a href="#StyleLint" class="headerlink" title="StyleLint"></a>StyleLint</h2><h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><h2 id="Git-Hooks"><a href="#Git-Hooks" class="headerlink" title="Git Hooks"></a>Git Hooks</h2><ul><li>husky</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>工程化</tag>
      
      <tag>cli</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript性能优化</title>
    <link href="/2022/03/31/js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/03/31/js%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>js 的内存管理是自动的</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj1 = &#123;&#125;; <span class="hljs-comment">// 申请空间</span>obj1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;mmm&quot;</span>; <span class="hljs-comment">// 使用空间</span>obj1 = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 释放</span></code></pre></div><h3 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h3><ul><li>  内存泄漏</li><li>  内存膨胀</li><li>  频繁垃圾回收</li></ul><h3 id="分离-DOM"><a href="#分离-DOM" class="headerlink" title="分离 DOM"></a>分离 DOM</h3><ul><li>  页面上不装载的 DOM</li><li>  垃圾对象引用的 DOM</li><li>  活动对象引用的 DOM</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>不是可达对象就被视为内存垃圾</p><h2 id="可达对象"><a href="#可达对象" class="headerlink" title="可达对象"></a><strong>可达对象</strong></h2><ul><li>  可以访问到的对象</li><li>  从根（全局）出发访问</li></ul><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数器判断引用计数</p><ul><li>  发现垃圾时立即回收（对象上保存了计数器）</li><li>  最大限度减少程序暂停</li><li>  无法回收循环引用</li><li>  资源开销较大（计数记录）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> o1 = &#123;&#125;;<span class="hljs-keyword">const</span> o2 = &#123;&#125;;<span class="hljs-comment">// 从根无法访问到o1,o2</span><span class="hljs-comment">// 但是o1,o2的引用计数都不是0</span><span class="hljs-comment">// 无法被回收</span>o1.<span class="hljs-property">a</span> = o2;o2.<span class="hljs-property">a</span> = o1;<span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;&#125;<span class="hljs-title function_">test</span>();</code></pre></div><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><em>两次遍历</em>所有对象，1 标记可达对象，2 清除没有标记的对象</p><ul><li>  空间碎片化：回收的空间可能很碎（ 内存地址不连续）不能满足新变量的需求</li><li>  可以回收循环引用</li><li>  不能立即回收</li></ul><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>标记清除并且会把对象存储的内存地址进行整理移动</p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><h2 id="性能工具"><a href="#性能工具" class="headerlink" title="性能工具"></a>性能工具</h2><ul><li>performance<ul><li>  timeline</li></ul></li><li>memory<ul><li>  Head Snapshot =&gt; 分离 DOM</li></ul></li></ul><h1 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h1><ul><li>  js 执行引擎</li><li>  优秀的垃圾回收</li><li>  即时编译</li><li>  内存设限</li></ul><h2 id="v8-使用的-GC-算法"><a href="#v8-使用的-GC-算法" class="headerlink" title="v8 使用的 GC 算法"></a>v8 使用的 GC 算法</h2><h3 id="分代回收-1"><a href="#分代回收-1" class="headerlink" title="分代回收"></a>分代回收</h3><blockquote><p>内存分为新生代，老生代对象</p></blockquote><table style="text-align:center"><thead><td colspan=2>新生代</td><td>老生代</td></thead><tbody><tr><td colspan=2>64位:32M  / 32位:16M</td><td>64位:1.4G  / 32位:700M</td></tr><tr><td>From</td><td>To</td><td>老生代存储区</td></tr></tbody></table><h4 id="新生代空间"><a href="#新生代空间" class="headerlink" title="新生代空间"></a>新生代空间</h4><p>存活时间较短的对象</p><ul><li>  平分两个等大空间</li><li>  使用空间为<code>From</code>，空闲空间为<code>To</code></li><li>  活动对象存储在<code>From</code></li><li>  <code>标记整理</code>后将活动对象拷贝到<code>To</code></li><li>  <code>From</code>完全释放与<code>To</code>交换</li></ul><blockquote><p>晋升</p></blockquote><ul><li>  将新生代对象移动到老生代</li><li>  一轮 GC 后还存活的对象进行晋升</li><li>  <code>To</code>空间使用率超过 25%</li></ul><h4 id="老生代空间"><a href="#老生代空间" class="headerlink" title="老生代空间"></a>老生代空间</h4><p>存活时间较长的对象（全局变量，闭包内的变量）</p><ul><li>  主要使用<code>标记清除</code></li><li>  <code>晋升</code>发生时，如果出现空间不足则会<code>标记整理</code></li><li>  <code>增量标记</code>提高效率(将垃圾回收分步执行，与程序执行交替进行，减少程序单次等待时间)</li></ul><h2 id="堆栈处理"><a href="#堆栈处理" class="headerlink" title="堆栈处理"></a>堆栈处理</h2><h3 id="堆栈准备"><a href="#堆栈准备" class="headerlink" title="堆栈准备"></a>堆栈准备</h3><ul><li>  执行环境栈<code>ECStack - execution context stack</code></li><li>  执行上下文<code>EC(G)</code></li><li>  全局上下文<code>VO(G)</code></li><li>  全局对象<code>GO</code></li></ul><table style="text-align:center"><thead><td colspan=5>执行环境栈ECStack</td><td>全局对象GO</td></thead><tbody><tr><td colspan=2>执行上下文EC(G)</td><td colspan=2>私有执行上下文EC(func)</td><td rowspan=3>......</td><td colspan=1 rowspan=3>setInterval</br>setTimeout</td></tr><tr><td>全局上下文VO(G)</td><td>其他代码</td><td>局部上下文AO</td><td>其他代码</td></tr><tr><td>可通过window 访问GO</br>存放全局变量</td><td>{..func().}</td><td>...</td><td>...</td></tr></tbody></table>堆内存<div style="display:flex;"><div style="height:100px;min-width:100px;border:1px solid"><div style="border-bottom:1px solid">0x000</div></div><div style="height:100px;min-width:100px;border:1px solid"><div style="border-bottom:1px solid">0x001</div></div><div style="height:100px;min-width:100px;border:1px solid"><div style="border-bottom:1px solid">0x002</div></div><div style="height:100px;min-width:100px;border:1px solid"><div style="border-bottom:1px solid">0x003 【func】</div><div style="padding:5px"><p>[[scope]]:EC(G)</p><p>确定作用域链</p></div></div><div style="height:100px;min-width:100px;border:1px solid"><div style="border-bottom:1px solid">...</div><div>...</div></div></div></br><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;<span class="hljs-keyword">var</span> obj2 = obj1obj1.<span class="hljs-property">y</span> = obj1 = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">200</span>&#125;<span class="hljs-comment">// 先执行 obj1.y = &#123;x:200&#125;</span><span class="hljs-comment">// 后执行 obj1 = &#123;x:200&#125;</span><span class="hljs-comment">// &#123;x:200&#125;里没有.y</span>obj1.<span class="hljs-property">y</span> =&gt; <span class="hljs-literal">undefined</span>obj2 =&gt; &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>,<span class="hljs-attr">y</span>:&#123;<span class="hljs-attr">x</span>:<span class="hljs-number">200</span>&#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;xxx&#x27;</span>,<span class="hljs-string">&#x27;aaa&#x27;</span>]<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>)&#123;  obj[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;yyy&#x27;</span> <span class="hljs-comment">// obj = arr = [&#x27;yyy&#x27;,&#x27;aaa&#x27;]</span>  obj = [<span class="hljs-string">&#x27;nb&#x27;</span>]  obj[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;mmm&#x27;</span> <span class="hljs-comment">// obj[&#x27;nb&#x27;,&#x27;mmm&#x27;]</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)&#125;<span class="hljs-title function_">foo</span>(arr)</code></pre></div><blockquote><p>变量查找：顺着作用域链依次访问外部上下文 &lt;AO1,AO2,…VO&gt;</p></blockquote><blockquote><p>[[scope]] 函数书写时确定，所在上下文</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c+b++)  &#125;&#125;<span class="hljs-keyword">var</span> f = <span class="hljs-title function_">foo</span>()<span class="hljs-title function_">f</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// 7 5+2</span><span class="hljs-title function_">f</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">// 13 10+3</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>)&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b+(++a))  &#125;&#125;<span class="hljs-keyword">let</span> fn = <span class="hljs-title function_">foo</span>(<span class="hljs-number">10</span>)<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// 16</span><span class="hljs-title function_">foo</span>(<span class="hljs-number">6</span>)(<span class="hljs-number">7</span>) <span class="hljs-comment">// 14</span><span class="hljs-title function_">fn</span>(<span class="hljs-number">20</span>) <span class="hljs-comment">// 32</span></code></pre></div><h1 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h1><h3 id="变量局部化"><a href="#变量局部化" class="headerlink" title="变量局部化"></a>变量局部化</h3><p>缩短访问数据时查找路径,变量存储位置离使用的地方越近越好</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><span class="hljs-keyword">var</span> i,str = <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">packageDom</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ;i++&gt;)&#123;    str += i <span class="hljs-comment">//  每次循环都要去VO(G)中才能找到str,i</span>  &#125;  <span class="hljs-keyword">return</span> str&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">packageDom</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ;i++&gt;)&#123;    str += i <span class="hljs-comment">//  不用访问EC(G)</span>  &#125;  <span class="hljs-keyword">return</span> str&#125;</code></pre></div><h3 id="减少访问层级"><a href="#减少访问层级" class="headerlink" title="减少访问层级"></a>减少访问层级</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;personnnn&#x27;</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>  &#125;&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()p1.<span class="hljs-title function_">getName</span>()</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;personnnn&#x27;</span>&#125;<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()p1.<span class="hljs-property">name</span></code></pre></div><h3 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h3><p>缓存需要多次使用的数据</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">100000</span> ;i++)&#123;  <span class="hljs-title function_">handle</span>(xxxObj.<span class="hljs-property">key1</span>)&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><span class="hljs-keyword">const</span> cacheItem = xxxObj.<span class="hljs-property">key1</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">100000</span> ;i++)&#123;  <span class="hljs-title function_">handle</span>(cacheItem)&#125;</code></pre></div><h3 id="减少判断，提前return"><a href="#减少判断，提前return" class="headerlink" title="减少判断，提前return"></a>减少判断，提前return</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  bad</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-keyword">function</span> <span class="hljs-title function_">do</span>(<span class="hljs-params">k1,k2</span>)&#123;  <span class="hljs-keyword">if</span>(k1)&#123;    <span class="hljs-keyword">if</span>(arr.<span class="hljs-title function_">includes</span>(k1))&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;includes&#x27;</span>      <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">5</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>      &#125;    &#125;  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;no argument&#x27;</span>  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  good</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-keyword">function</span> <span class="hljs-title function_">do</span>(<span class="hljs-params">k1,k2</span>)&#123;  <span class="hljs-keyword">if</span>(!k1) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;no argument&#x27;</span>  <span class="hljs-keyword">if</span>(!arr.<span class="hljs-title function_">includes</span>(k1)) <span class="hljs-keyword">return</span>   <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">5</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span>  &#125;&#125;</code></pre></div><h3 id="减少循环体内操作"><a href="#减少循环体内操作" class="headerlink" title="减少循环体内操作"></a>减少循环体内操作</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt; arr.<span class="hljs-property">length</span> ; i++)&#123;  ...&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; len ; i++)&#123;  ...&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// better</span><span class="hljs-keyword">while</span>(len--)&#123;  ...&#125;</code></pre></div><h3 id="字面量和构造函数"><a href="#字面量和构造函数" class="headerlink" title="字面量和构造函数"></a>字面量和构造函数</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><span class="hljs-keyword">const</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()o1.<span class="hljs-property">a</span> = <span class="hljs-number">666</span><span class="hljs-keyword">const</span> str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;mmm&#x27;</span>) <span class="hljs-comment">// 特别是基本类型，性能损耗很大</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><span class="hljs-keyword">const</span> o1 = &#123;  a : <span class="hljs-number">666</span>&#125; <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;mmm&#x27;</span> <span class="hljs-comment">// 字面量调用方法时会被包装为对象</span></code></pre></div><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typescript</title>
    <link href="/2022/03/30/typescript/"/>
    <url>/2022/03/30/typescript/</url>
    
    <content type="html"><![CDATA[<h1 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h1><h2 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h2><ul><li>  强类型 （不允许隐式类型转换）</li><li>  弱类型 （允许隐式转换）</li></ul><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><ul><li><p>  静态类型语言 （变量类型书写时就确定且不能修改）</p></li><li><p>  动态类型语言 （变量类型运行时才能确定，且可以修改）</p></li></ul><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><ul><li>  弱类型</li><li>  动态类型</li><li>  脚本语言，无需编译</li></ul><h1 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h1><p><code>javascript</code>类型检查器</p><p>JUMP TO:<a href="https://github.com/facebook/flow">Flow</a></p><p>…略过</p><h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><ul><li>  <code>javascript</code>的超集</li><li>  加入<code>ECMAScript</code>新特性和类型系统</li><li>  最终会被编译回<code>javascript</code></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>原始值类型</p></blockquote><ul><li>  <code>string</code></li><li>  <code>number(NaN Infinity)</code></li><li>  <code>boolean</code></li><li>  <code>void</code></li><li>  <code>null</code></li><li>  <code>undefined</code></li><li>  <code>symbol</code></li></ul><hr><ul><li>  <code>object</code></li><li>  <code>array</code></li><li>  <code>tuple</code></li><li>  <code>enum</code></li><li>  <code>function</code></li><li>  <code>any</code></li></ul><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-number">123</span>;<span class="hljs-comment">// num1:number</span>num1 = <span class="hljs-string">&quot;mmm&quot;</span>; <span class="hljs-comment">// error</span></code></pre></div><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> num1 = n1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>;<span class="hljs-keyword">const</span> num2 = &lt;<span class="hljs-built_in">number</span>&gt;n2;</code></pre></div><h2 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface 接口"></a>interface 接口</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Post</span> &#123;[<span class="hljs-attr">prop</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 动态成员</span>content?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 可选</span><span class="hljs-keyword">readonly</span> <span class="hljs-attr">author</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 只读</span>&#125;</code></pre></div><h2 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<span class="hljs-comment">// 必须要类型声明</span><span class="hljs-keyword">public</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 默认 共有属性</span><span class="hljs-keyword">private</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 私有属性，子类不能访问</span><span class="hljs-keyword">protected</span> <span class="hljs-attr">gender</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 只能在子类中访问</span><span class="hljs-keyword">private</span> <span class="hljs-comment">/*默认public*/</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;&#125; <span class="hljs-comment">// 设置private后不能在外部new</span><span class="hljs-keyword">static</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(name, age); <span class="hljs-comment">// 可以在这里创建实例</span>&#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Eat</span> &#123;<span class="hljs-title function_">eat</span>(<span class="hljs-attr">food</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Run</span> &#123;<span class="hljs-title function_">run</span>(<span class="hljs-attr">distance</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Eat</span>, <span class="hljs-title class_">Run</span> &#123;<span class="hljs-title function_">eat</span>(<span class="hljs-attr">food</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;吃了&quot;</span> + food);&#125;<span class="hljs-title function_">run</span>(<span class="hljs-attr">distance</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;跑了&quot;</span> + distance);&#125;&#125;</code></pre></div><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>只能被继承不能被<code>new</code></p><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;  <span class="hljs-title function_">eat</span>(<span class="hljs-attr">food</span>:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">void</span>&#123;    ...  &#125;  <span class="hljs-keyword">abstract</span> run (<span class="hljs-attr">distance</span>:<span class="hljs-built_in">number</span>):<span class="hljs-built_in">void</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span>&#123;  <span class="hljs-comment">// 提示 Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;run&#x27; from class &#x27;Animal&#x27;.</span>  <span class="hljs-comment">// 需要自己写出符合run形状的run方法</span>  <span class="hljs-title function_">run</span>(<span class="hljs-attr">distance</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Method not implemented.&quot;</span>);  &#125;&#125;</code></pre></div><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> createArray&lt;T&gt;(<span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">value</span>: T): T[] &#123;<span class="hljs-keyword">const</span> arr = <span class="hljs-title class_">Array</span>&lt;T&gt;(length).<span class="hljs-title function_">fill</span>(value);<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h2 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h2><h2 id="interface-接口-和-type-类型别名-的区别"><a href="#interface-接口-和-type-类型别名-的区别" class="headerlink" title="interface(接口) 和 type(类型别名)的区别"></a>interface(接口) 和 type(类型别名)的区别</h2><ol><li><code>interface</code>不能实现类型别名<code>number | string</code></li><li><code>interface</code>不能实现<code>utility type</code></li></ol><h2 id="utility-type"><a href="#utility-type" class="headerlink" title="utility type"></a>utility type</h2><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span>&#123;<span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span><span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span>&#125;<span class="hljs-comment">// name age可选</span><span class="hljs-keyword">const</span> xiaoming = <span class="hljs-title class_">Partial</span>&lt;<span class="hljs-title class_">Person</span>&gt;<span class="hljs-comment">// 只有name属性</span><span class="hljs-keyword">const</span> xiaohong  = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">Person</span>,<span class="hljs-string">&quot;name&quot;</span>&gt;<span class="hljs-comment">// name age 都删除</span><span class="hljs-keyword">const</span> huahua = <span class="hljs-title class_">Omit</span>&lt;<span class="hljs-title class_">Person</span>,<span class="hljs-string">&quot;name&quot;</span> | <span class="hljs-string">&quot;age&quot;</span>&gt;<span class="hljs-comment">// [name,age]</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonKeys</span> = keyof <span class="hljs-title class_">Person</span><span class="hljs-comment">// &#123;name:string&#125;</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">PersonOnlyName</span> = <span class="hljs-title class_">Pick</span>&lt;<span class="hljs-title class_">Person</span>,<span class="hljs-string">&#x27;name&#x27;</span>&gt;<span class="hljs-comment">// age string</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Age</span> = <span class="hljs-title class_">Exclude</span>&lt;<span class="hljs-title class_">PersonKey</span>,<span class="hljs-string">&#x27;name&#x27;</span>&gt;</code></pre></div><ul><li>  <code>Partial</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 模拟</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Partial</span>&lt;T&gt; = &#123;[P <span class="hljs-keyword">in</span> keyof T]?: T[P]; <span class="hljs-comment">// 改成可选的</span>&#125;;</code></pre></div><ul><li>  <code>Pick</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 模拟</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Pick</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof T&gt; = &#123;[P <span class="hljs-keyword">in</span> K]: T[P]; <span class="hljs-comment">// 选出你要的属性</span>&#125;;</code></pre></div><ul><li>  <code>Exclude</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 删除联合类型中的类型</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Exclude</span> = &lt;T,U&gt; = T <span class="hljs-keyword">extends</span> U ? <span class="hljs-built_in">never</span> : U</code></pre></div><ul><li>  <code>Omit</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-comment">// 删除联合类型中的属性</span><span class="hljs-keyword">type</span> <span class="hljs-title class_">Omit</span>&lt;T, K <span class="hljs-keyword">extends</span> keyof <span class="hljs-built_in">any</span>&gt; = <span class="hljs-title class_">Pick</span>&lt;T, <span class="hljs-title class_">Exclude</span>&lt;keyof T, K&gt;&gt;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/2022/03/29/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/03/29/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><ul><li>  对数据之间的运算过程进行抽象</li><li>  “函数”是数学中的“函数”<code>a = sin(30)</code>，是一种映射关系</li><li>  相同的输入一定会得到相同的输出（副作用）</li></ul><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><ul><li>  函数可以存储在变量中</li><li>  函数可以作为参数 <em>（高阶函数）</em></li><li>  函数可以作为返回值 <em>（高阶函数）</em></li></ul><blockquote><p>高阶函数 =&gt; 抽象通用问题，屏蔽实现的细节</p></blockquote><h2 id="闭包closure"><a href="#闭包closure" class="headerlink" title="闭包closure"></a>闭包<code>closure</code></h2><p>JUMP To:<a href="https://tatekii33.cool/2022/02/24/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85">闭包</a></p><h2 id="纯函数pf"><a href="#纯函数pf" class="headerlink" title="纯函数pf"></a>纯函数<code>pf</code></h2><ul><li>  不修改参数</li><li>  不产生副作用</li><li>  不调用不纯的方法</li></ul><h3 id="纯函数的好处"><a href="#纯函数的好处" class="headerlink" title="纯函数的好处"></a>纯函数的好处</h3><ul><li>  可缓存</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// lodash.memoize()</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-keyword">const</span> cache = &#123;&#125;;<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">arguments</span>);cache[key] = cache[key] || fn.<span class="hljs-title function_">apply</span>(fn, <span class="hljs-variable language_">arguments</span>);<span class="hljs-keyword">return</span> cache[key];&#125;;&#125;</code></pre></div><ul><li>  可测试</li><li>  并行处理(<code>webWorker</code>)</li></ul><h3 id="副作用effect"><a href="#副作用effect" class="headerlink" title="副作用effect"></a>副作用<code>effect</code></h3><ul><li>  函数的状态依赖外部的状态就会带来副作用</li><li>  副作用会使函数不纯</li></ul><h2 id="柯里化curry"><a href="#柯里化curry" class="headerlink" title="柯里化curry"></a>柯里化<code>curry</code></h2><p>JUMP To:<a href="https://tatekii33.cool/2022/02/24/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85">柯里化</a></p><ul><li>  缓存函数的参数</li><li>  将多元函数转化为多个一元函数</li><li>  降低函数的粒度，方便组合</li><li></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// lodash.curry()</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) &#123;<span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &lt; func.<span class="hljs-property">length</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">curried</span>(...args.<span class="hljs-title function_">concat</span>([...<span class="hljs-variable language_">arguments</span>]));&#125;;&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(...args);&#125;;&#125;</code></pre></div><h2 id="函数组合compose"><a href="#函数组合compose" class="headerlink" title="函数组合compose"></a>函数组合<code>compose</code></h2><ul><li>  封装洋葱代码<code>_.toUpper(._first(._reverse(array)))</code></li><li>  忽略中间状态 <em>(数据管道)</em></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">fn</span>: A -&gt; B -&gt; C -&gt; D<span class="hljs-attr">fn</span>: A -----------&gt; D</code></pre></div><ul><li>  默认从右向左执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// lodash.flowRight()</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">flowRight</span>(<span class="hljs-params">...fns</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<span class="hljs-keyword">return</span> fns.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">acc, fn</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(acc);&#125;, ...args);&#125;;&#125;<span class="hljs-comment">// es6</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> =(<span class="hljs-params">...fns</span>) =&gt;<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>fns.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">acc, fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(acc), ...args);</code></pre></div><h3 id="lodash-fp-模块"><a href="#lodash-fp-模块" class="headerlink" title="lodash/fp 模块"></a>lodash/fp 模块</h3><ul><li>  柯里化的 lodash 方法</li><li>  函数参数在前，数据在后</li></ul><p>(FP Guide)[<a href="https://github.com/lodash/lodash/wiki/FP-Guide]">https://github.com/lodash/lodash/wiki/FP-Guide]</a></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">_.<span class="hljs-title function_">map</span>([<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>], <span class="hljs-built_in">parseInt</span>);<span class="hljs-comment">// [1,NaN,NaN]</span><span class="hljs-comment">// mapFn(item,index|key,array)</span><span class="hljs-comment">// parseInt(string,radix)// 将radix进制的string转为十进制</span>fp.<span class="hljs-title function_">map</span>(<span class="hljs-built_in">parseInt</span>, [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>]);<span class="hljs-comment">// [1,2,3]</span></code></pre></div><h3 id="PointFree"><a href="#PointFree" class="headerlink" title="PointFree"></a><code>PointFree</code></h3><ul><li>  不需要指明处理的数据</li><li>  只需要合成运算的过程</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Hello World =&gt; hello_world</span><span class="hljs-keyword">const</span> f = fp.<span class="hljs-title function_">flowRight</span>(fp.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">&quot;_&quot;</span>), fp.<span class="hljs-property">toLower</span>);<span class="hljs-title function_">f</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);</code></pre></div><h2 id="函子Functor"><a href="#函子Functor" class="headerlink" title="函子Functor"></a>函子<code>Functor</code></h2><ul><li>  一个包裹值的盒子</li><li>  不直接对外暴露值</li><li>  实现 map 契约</li></ul><h3 id="Either函子"><a href="#Either函子" class="headerlink" title="Either函子"></a><code>Either</code>函子</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Either函子</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Left</span> &#123;<span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">value</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Left</span>(value);&#125;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value;&#125;<span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Right</span> &#123;<span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">value</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Right</span>(value);&#125;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value;&#125;<span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Right</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>));&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseJSON</span>(<span class="hljs-params">str</span>) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Right</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str));&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Left</span>.<span class="hljs-title function_">of</span>(&#123; <span class="hljs-attr">error</span>: e.<span class="hljs-property">message</span> &#125;);&#125;&#125;</code></pre></div><h3 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a><code>IO</code>函子</h3><ul><li>  将不纯的函数用函子保存</li><li>  延迟执行副作用，并且不纯的操作交由调用者处理</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IO</span> &#123;<span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">value</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> value;&#125;);&#125;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = fn;&#125;<span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(fp.<span class="hljs-title function_">flowRight</span>(fn, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>));&#125;&#125;<span class="hljs-keyword">const</span> path = <span class="hljs-variable constant_">IO</span>.<span class="hljs-title function_">of</span>(process).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.<span class="hljs-property">execPath</span>);<span class="hljs-comment">// 输出的path是一个包裹了副作用的纯函数</span>path.<span class="hljs-title function_">_value</span>();<span class="hljs-comment">// 直到执行._value()时才会处理副作用</span></code></pre></div><h2 id="folktale"><a href="#folktale" class="headerlink" title="folktale"></a><code>folktale</code></h2><p>JUMP TO:<a href="https://folktale.origamitower.com/">https://folktale.origamitower.com/</a></p><h3 id="Task函子"><a href="#Task函子" class="headerlink" title="Task函子"></a><code>Task</code>函子</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; task &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;folktale/concurrency/task&quot;</span>);<span class="hljs-keyword">const</span> &#123; split, find &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;lodash/fp&quot;</span>);<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params">filename</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">task</span>(<span class="hljs-function">(<span class="hljs-params">resolver</span>) =&gt;</span> &#123;fs.<span class="hljs-title function_">readFile</span>(filename, <span class="hljs-string">&quot;utf-8&quot;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (err) resolver.<span class="hljs-title function_">reject</span>(err);resolver.<span class="hljs-title function_">resolve</span>(data);&#125;);&#125;);&#125;<span class="hljs-keyword">const</span> readVersion = <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;package.json&quot;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;\n&quot;</span>)).<span class="hljs-title function_">map</span>(<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;version&quot;</span>))).<span class="hljs-title function_">run</span>().<span class="hljs-title function_">listen</span>(&#123;<span class="hljs-attr">onRejected</span>: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err),<span class="hljs-attr">onResolved</span>: <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;res=&gt;&quot;</span>, val),&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(readVersion);<span class="hljs-comment">// TaskExecution &#123;</span><span class="hljs-comment">//   _task: Task &#123; _computation: [Function (anonymous)] &#125;,</span><span class="hljs-comment">//   _deferred: Object [folktale:Deferred] &#123;&#125;,</span><span class="hljs-comment">//   _links: []</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// res=&gt;   &quot;version&quot;: &quot;1.0.0&quot;,</span></code></pre></div><h3 id="Point函子"><a href="#Point函子" class="headerlink" title="Point函子"></a><code>Point</code>函子</h3><ul><li>  实现了<code>of</code>静态方法的函子</li><li>  避免使用<code>new</code>来创建对象</li><li>  上面的都属于 point 函子,将值包裹到上下文中</li></ul><h3 id="Monad函子"><a href="#Monad函子" class="headerlink" title="Monad函子"></a><code>Monad</code>函子</h3><ul><li>  返回一个函子</li><li>  可以扁平化的<code>Point</code>函子</li><li>  实现了静态<code>join``of</code>方法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IO</span> &#123;<span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">value</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> value;&#125;);&#125;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = fn;&#125;<span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(fp.<span class="hljs-title function_">flowRight</span>(fn, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>));&#125;<span class="hljs-title function_">join</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_value</span>();&#125;<span class="hljs-title function_">flatMap</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">map</span>(fn).<span class="hljs-title function_">join</span>();&#125;&#125;<span class="hljs-keyword">const</span> readFile = <span class="hljs-keyword">function</span> (<span class="hljs-params">filename</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">&quot;utf-8&quot;</span>);&#125;);&#125;;<span class="hljs-keyword">const</span> print = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> x;&#125;);&#125;;<span class="hljs-keyword">const</span> res = <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;package.json&quot;</span>).<span class="hljs-title function_">flatMap</span>(print).<span class="hljs-title function_">join</span>();</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router@4.x实现分析</title>
    <link href="/2022/03/22/vue3-router/"/>
    <url>/2022/03/22/vue3-router/</url>
    
    <content type="html"><![CDATA[<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ROUTER_KEY</span> = <span class="hljs-title class_">Symbol</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">useRouter</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">inject</span>(<span class="hljs-variable constant_">ROUTER_KEY</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createRouter</span>(<span class="hljs-params">options</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(options);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createWebHashHistory</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">function</span> <span class="hljs-title function_">bindEvent</span>(<span class="hljs-params">fn</span>) &#123;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;hashchange&quot;</span>, fn);&#125;<span class="hljs-keyword">const</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>) || <span class="hljs-string">&quot;/&quot;</span>;<span class="hljs-keyword">return</span> &#123;bindEvents,url,&#125;;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = options.<span class="hljs-property">history</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = options.<span class="hljs-property">routes</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-title function_">ref</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>.<span class="hljs-property">url</span>);<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">bindEvents</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);&#125;);&#125;<span class="hljs-title function_">install</span>(<span class="hljs-params">app</span>) &#123;app.<span class="hljs-title function_">provide</span>(<span class="hljs-variable constant_">ROUTER_KEY</span>, <span class="hljs-variable language_">this</span>);&#125;&#125;<span class="hljs-keyword">export</span> &#123; createRouter, createWebHashHistory, useRouter &#125;;</code></pre></div><h2 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h2><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;&lt;component :is=&quot;comp&quot;&gt;&lt;/component&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; computed &#125; from &quot;vue&quot;;import &#123; useRouter &#125; from &quot;👆&quot;;const router = useRouter();const comp = computed(() =&gt; &#123;const route = router.routes.find((route) =&gt; route.path === router.current.value); // 使用path查找return route ? route.component : null;&#125;);&lt;/script&gt;</code></pre></div><h2 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h2><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;&lt;a :href=&quot;&#x27;#&#x27; + props.to&quot;&gt;  &lt;!-- 简单的改变地址栏hash --&gt;&lt;slot /&gt;&lt;/a&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps(&#123;to: &#123;type: String,required: true,&#125;,&#125;);&lt;/script&gt;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
      <tag>vue-router</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写系列</title>
    <link href="/2022/03/16/%E6%89%8B%E5%86%99/"/>
    <url>/2022/03/16/%E6%89%8B%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="事件中心-EventCenter"><a href="#事件中心-EventCenter" class="headerlink" title="事件中心 EventCenter"></a>事件中心 EventCenter</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventCenter</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();&#125;<span class="hljs-title function_">register</span>(<span class="hljs-params">event, isOnce, fn, ...args1</span>) &#123;<span class="hljs-keyword">const</span> curEvent = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">has</span>(event) ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">get</span>(event) : <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">set</span>(event, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()).<span class="hljs-title function_">get</span>(event);curEvent.<span class="hljs-title function_">set</span>(fn, <span class="hljs-function">(<span class="hljs-params">...args2</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> res = <span class="hljs-title function_">fn</span>(...args1, ...args2);<span class="hljs-keyword">if</span> (isOnce) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(event, fn);&#125;<span class="hljs-keyword">return</span> res;&#125;);&#125;<span class="hljs-title function_">on</span>(<span class="hljs-params">event, fn, ...args</span>) &#123;<span class="hljs-title function_">register</span>(event, <span class="hljs-literal">false</span>, fn, ...args);&#125;<span class="hljs-title function_">once</span>(<span class="hljs-params">event, fn, ...args</span>) &#123;<span class="hljs-title function_">register</span>(event, <span class="hljs-literal">true</span>, fn, ...args);&#125;<span class="hljs-title function_">off</span>(<span class="hljs-params">event, fn</span>) &#123;<span class="hljs-keyword">if</span> (!event || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">has</span>(event)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (!fn) &#123;<span class="hljs-comment">// 删除整个事件</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">delete</span>(event);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 删除单个订阅</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">get</span>(event).<span class="hljs-title function_">delete</span>(fn);&#125;&#125;<span class="hljs-title function_">fire</span>(<span class="hljs-params">event, ...args</span>) &#123;<span class="hljs-keyword">const</span> curEvents = <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">get</span>(event);<span class="hljs-keyword">if</span> (!curEvents) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cb <span class="hljs-keyword">of</span> curEvents.<span class="hljs-title function_">values</span>()) &#123;<span class="hljs-title function_">cb</span>(...args);&#125;&#125;&#125;<span class="hljs-comment">// 请使用原生代码实现一个Events模块，可以实现自定义事件的订阅、触发、移除功能</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn1</span> = (<span class="hljs-params">...args</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I want sleep1&quot;</span>, ...args);<span class="hljs-keyword">const</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params">...args</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I want sleep2&quot;</span>, ...args);<span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Events</span>();event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;sleep&quot;</span>, fn1, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;sleep&quot;</span>, fn2, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);event.<span class="hljs-title function_">fire</span>(<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<span class="hljs-comment">// I want sleep1 1 2 3 4 5 6</span><span class="hljs-comment">// I want sleep2 1 2 3 4 5 6</span>event.<span class="hljs-title function_">off</span>(<span class="hljs-string">&quot;sleep&quot;</span>, fn1);event.<span class="hljs-title function_">once</span>(<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;I want sleep&quot;</span>));event.<span class="hljs-title function_">fire</span>(<span class="hljs-string">&quot;sleep&quot;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span><span class="hljs-comment">// I want sleep</span>event.<span class="hljs-title function_">fire</span>(<span class="hljs-string">&quot;sleep&quot;</span>);<span class="hljs-comment">// I want sleep2 1 2 3</span></code></pre></div><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><code>new</code> 操作符</h2><p><code>new(constructor)</code>过程中发生了什么？</p><ol><li>创建一个空对象</li><li>将这个空对象链接到构造函数的原型</li><li>将<code>this</code>指向创建出来的空对象并执行构造函数</li><li>如果执行结果是对象则返回这个结果</li><li>否则返回<code>this</code></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObj</span> = o =&gt; o !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&#x27;object&#x27;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">func,...args</span>)&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">&quot;function&quot;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;must new a function&quot;</span>);  <span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(func.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)  <span class="hljs-keyword">const</span> res = func.<span class="hljs-title function_">call</span>(newObj...args)  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isObj</span>(res) ? res : newObj&#125;</code></pre></div><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a><code>Object.create</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property">_create</span> = <span class="hljs-function">(<span class="hljs-params">instance, propertiesObject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance !== <span class="hljs-string">&quot;function&quot;</span> || <span class="hljs-keyword">typeof</span> instance !== <span class="hljs-string">&quot;object&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;instance can only be object or function&quot;</span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = instance;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<span class="hljs-keyword">if</span> (propertiesObject) &#123;<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(propertiesObject).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(res, key, propertiesObject[key]);&#125;);&#125;&#125;;</code></pre></div><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p>检测右侧的原型是否在左侧的原型链上游，但它不能检测<code>null</code> 和 <code>undefined</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_instanceof</span>(<span class="hljs-params">L, R</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> L !== <span class="hljs-string">&quot;object&quot;</span> || L === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;need object data&quot;</span>);&#125;L = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(L); <span class="hljs-comment">// L = L.__proto__</span>R = R.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">if</span> (L === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 原型连到头</span><span class="hljs-keyword">if</span> (L === R) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;L = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(L);&#125;&#125;</code></pre></div><h2 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h2><ul><li>  将高频调用函数更改为固定时间不再调用才执行回调</li><li>  输入框联想，提交按钮</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> func 回调</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wait 间隔时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">boolean</span>&#125; immediate 立即执行？</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait = <span class="hljs-number">300</span>, immediate = <span class="hljs-literal">true</span>, ...args1</span>) &#123;<span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">_debounce</span>(<span class="hljs-params">...args2</span>) &#123;<span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);<span class="hljs-keyword">const</span> init = immediate &amp;&amp; !timer;timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;timer = <span class="hljs-literal">null</span>;!immediate ? func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [...args1, ...args2]) : <span class="hljs-literal">null</span>;&#125;, wait);init ? func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [...args1, ...args2]) : <span class="hljs-literal">null</span>;&#125;_debounce.<span class="hljs-property">cancel</span> = <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">clearTimeout</span>(timer);timer = <span class="hljs-literal">null</span>;&#125;;<span class="hljs-keyword">return</span> _debounce;&#125;</code></pre></div><h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><ul><li>  将高频调用函数更改为固定间隔执行回调</li><li>  窗口滚动，窗口缩放</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> func 回调</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wait 间隔时间</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait = <span class="hljs-number">300</span>, ...args1</span>) &#123;<span class="hljs-keyword">let</span> previous = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">_throttle</span>(<span class="hljs-params">...args2</span>) &#123;<span class="hljs-keyword">const</span> now = +<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<span class="hljs-keyword">const</span> interval = wait - (now - previous);<span class="hljs-keyword">if</span> (interval &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 凑巧和设定频率相同，两个if都会满足，则先执行这里</span><span class="hljs-comment">// 也要清理定时器</span><span class="hljs-built_in">clearTimeout</span>(timer)timer = <span class="hljs-literal">null</span><span class="hljs-comment">// 操作频率慢于设定间隔</span>func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [...args1, ...args2]);previous = now;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!timer) &#123;<span class="hljs-comment">// 如果操作频率过快</span><span class="hljs-comment">// 并且还没有定时器</span><span class="hljs-comment">// 设置一个达到规定间隔后执行回调的定时器</span><span class="hljs-comment">// 如果有定时器则return</span>timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">clearTimeout</span>(timer);timer = <span class="hljs-literal">null</span>;func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [...args1, ...args2]);previous = +<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();&#125;);&#125;&#125;<span class="hljs-keyword">return</span> _throttle;&#125;</code></pre></div><h2 id="重试函数"><a href="#重试函数" class="headerlink" title="重试函数"></a>重试函数</h2><p>实现一个重试函数，按一定间隔不断尝试执行一个 promise</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">retry</span>(<span class="hljs-params">func, wait, limit</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">function</span> <span class="hljs-title function_">attempt</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(func).<span class="hljs-title function_">then</span>(resolve <span class="hljs-comment">/*尝试resolve*/</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (limit-- === <span class="hljs-number">1</span>) &#123;<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;达到最大尝试次数&quot;</span>);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">attempt</span>();<span class="hljs-built_in">clearTimeout</span>(timer);timer = <span class="hljs-literal">null</span>;&#125;, wait);&#125;&#125;);&#125;<span class="hljs-title function_">attempt</span>();&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);&#125;);&#125;</code></pre></div><h2 id="并发线程池"><a href="#并发线程池" class="headerlink" title="并发线程池"></a>并发线程池</h2><p>同时执行几个函数（or 不同参数的同一个函数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  <span class="hljs-doctag">@params</span> limit 并行限制</span><span class="hljs-comment"> *  <span class="hljs-doctag">@params</span> args 参数数组</span><span class="hljs-comment"> *  <span class="hljs-doctag">@params</span> func 函数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncPool</span>(<span class="hljs-params">limit, args, func</span>) &#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> len = args.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> ret = []; <span class="hljs-comment">// 所有任务</span><span class="hljs-keyword">const</span> executing = []; <span class="hljs-comment">// 并行中的任务</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">if</span> (i &gt; len - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(); <span class="hljs-comment">// 执行完所有参数，resolve</span><span class="hljs-keyword">const</span> curArg = args[i]; <span class="hljs-comment">//  当前参数</span><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">func</span>(curArg)); <span class="hljs-comment">// 包装为promise</span><span class="hljs-keyword">const</span> e = p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 封装为fulfilled后从并发池中删除</span>executing.<span class="hljs-title function_">splice</span>(executing.<span class="hljs-title function_">indexOf</span>(e), <span class="hljs-number">1</span>);&#125;);ret.<span class="hljs-title function_">push</span>(p); <span class="hljs-comment">// 添加进待所有任务数组</span>executing.<span class="hljs-title function_">push</span>(e); <span class="hljs-comment">// 添加进待处理任务数组</span><span class="hljs-keyword">let</span> r = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<span class="hljs-keyword">if</span> (executing.<span class="hljs-property">length</span> === limit) &#123;<span class="hljs-comment">// 如果并行任务数达到限制，开启race</span>r = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>(executing);&#125;<span class="hljs-keyword">return</span> r.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">enqueue</span>());&#125;<span class="hljs-keyword">return</span> enqueue.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(ret));&#125;<span class="hljs-comment">// Promise.all 在所有promise fulfilled后才会输出</span><span class="hljs-comment">// 同时executing又保证了同时在改变中的promise不会超出限制</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">cb</span> = (<span class="hljs-params">str</span>) =&gt; <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str), <span class="hljs-number">2000</span>);<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">123</span>, <span class="hljs-number">124</span>, <span class="hljs-number">666</span>, <span class="hljs-number">777</span>, <span class="hljs-number">888</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">asyncPool</span>(<span class="hljs-number">2</span>, arr, cb));</code></pre></div><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul><li>  浅拷贝<code>Object.assign/&#123;...originObj&#125;</code>面对引用类型只拷贝了指针</li><li>  <code>JSON.parse(JSON.stringify(originObj))</code>面对<em>函数</em>和<em>Symbol</em>会报错</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObj</span> = (<span class="hljs-params">o</span>) =&gt; <span class="hljs-number">0</span> !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> o === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source, cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>()</span>) &#123;<span class="hljs-comment">// cache处理循环引用</span><span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObj</span>(source) || cache.<span class="hljs-title function_">has</span>(source)) <span class="hljs-keyword">return</span> source;<span class="hljs-keyword">const</span> _constructor = source.<span class="hljs-property">constructor</span>;<span class="hljs-keyword">const</span> newObj = _constructor === <span class="hljs-title class_">Object</span> ? &#123;&#125; : <span class="hljs-keyword">new</span> <span class="hljs-title function_">_constructor</span>(source);<span class="hljs-comment">// 不只是对象或者数组，也处理其他的类型像日期和正则</span>cache.<span class="hljs-title function_">add</span>(newObj);<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(source).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;newObj[key] = <span class="hljs-title function_">deepClone</span>(source[key], cache);&#125;);<span class="hljs-keyword">return</span> newObj;&#125;</code></pre></div><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property">_assign</span> = <span class="hljs-function">(<span class="hljs-params">target, ...properties</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&quot;object&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;can only assign an object&quot;</span>);&#125;properties.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, acc</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (acc === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> pre;<span class="hljs-comment">// 不可遍历属性也会被拷贝</span><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(acc).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;pre[key] = acc[key];&#125;);<span class="hljs-keyword">return</span> pre;&#125;, target);&#125;;</code></pre></div><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">_typeof</span> = (<span class="hljs-params">o</span>) =&gt; <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">call</span>(o).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>).<span class="hljs-title function_">toLowerCase</span>();</code></pre></div><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call/apply/bind"></a>call/apply/bind</h2><p>非严格模式下，则 <code>context</code> 指定为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，原始值会被包装。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_call</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args</span>) &#123;<span class="hljs-keyword">const</span> func = <span class="hljs-variable language_">this</span>;context = context || <span class="hljs-variable language_">window</span>;<span class="hljs-keyword">const</span> caller = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);context[caller] = func;<span class="hljs-keyword">const</span> res = context[caller](...args);<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">delete</span>(context, caller);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_apply</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, args</span>) &#123;<span class="hljs-keyword">const</span> func = <span class="hljs-variable language_">this</span>;context = context || <span class="hljs-variable language_">window</span>;<span class="hljs-keyword">const</span> caller = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&quot;caller&quot;</span>);context[caller] = func;<span class="hljs-keyword">const</span> res = context[caller](...args);<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">delete</span>(context, caller);<span class="hljs-keyword">return</span> res;&#125;;<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_bind</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">context, ...args1</span>) &#123;<span class="hljs-keyword">const</span> func = <span class="hljs-variable language_">this</span>;context = context || <span class="hljs-variable language_">window</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">boundFn</span>(<span class="hljs-params">...args2</span>) &#123;<span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> func ? <span class="hljs-variable language_">this</span> : context, [...args1, ...args2]);&#125;boundFn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(func.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<span class="hljs-keyword">return</span> boundFn;&#125;;</code></pre></div><h2 id="实现一个迭代器"><a href="#实现一个迭代器" class="headerlink" title="实现一个迭代器"></a>实现一个迭代器</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIterator</span>(<span class="hljs-params">arrayLike</span>) &#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> &#123;<span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: arrayLike[i],<span class="hljs-attr">done</span>: i &gt;= arrayLike.<span class="hljs-property">length</span>,&#125;;&#125;,[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">Iterator</span>]() &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;&#125;,&#125;;&#125;</code></pre></div><h2 id="封装-ajax"><a href="#封装-ajax" class="headerlink" title="封装 ajax"></a>封装 ajax</h2><p>使用 promise 封装 ajax,<code>async javascript xml</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">request</span> = (<span class="hljs-params">method, url, params = &#123;&#125;</span>) =&gt; &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>));&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-title function_">reject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);&#125;&#125;;xhr.<span class="hljs-property">onerror</span> = reject;xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(get)$|^(GET)$/</span>.<span class="hljs-title function_">test</span>(method)) &#123;<span class="hljs-keyword">let</span> paramsStr = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(params).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> [k, v] = item;paramsStr += <span class="hljs-string">`<span class="hljs-subst">$&#123;k&#125;</span>=<span class="hljs-subst">$&#123;v&#125;</span>&amp;`</span>;&#125;);xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url + <span class="hljs-string">`?<span class="hljs-subst">$&#123;paramsStr&#125;</span>`</span>);xhr.<span class="hljs-title function_">send</span>();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(post)$|^(POST)$/</span>.<span class="hljs-title function_">test</span>(method)) &#123;xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-type&quot;</span>, <span class="hljs-string">&quot;application/x-www-urlencode&quot;</span>);xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>, url);xhr.<span class="hljs-title function_">send</span>(<span class="hljs-built_in">encodeURIComponent</span>(params));&#125;&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);&#125;);&#125;;</code></pre></div><h2 id="sleep-函数"><a href="#sleep-函数" class="headerlink" title="sleep 函数"></a>sleep 函数</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-params">wait</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(resolve, wait);&#125;);&#125;</code></pre></div><h2 id="fill-方法"><a href="#fill-方法" class="headerlink" title="fill 方法"></a>fill 方法</h2><p>如果 start 是个负数, 则开始索引会被自动计算成为 length+start, 其中 length 是 this 对象的 length 属性值。如果 end 是个负数, 则结束索引会被自动计算成为 length+end。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_fill</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">value, startIndex, endIndex</span>) &#123;<span class="hljs-keyword">let</span> i = startIndex &gt;= <span class="hljs-number">0</span> ? startIndex : startIndex + <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;endIndex = endIndex &gt;= <span class="hljs-number">0</span> ? endIndex : endIndex + <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<span class="hljs-keyword">while</span> (i &lt; endIndex) &#123;<span class="hljs-variable language_">this</span>[i++] = value;&#125;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;&#125;;</code></pre></div><h2 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">LRU</span>(<span class="hljs-params">capacity</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity;<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();&#125;<span class="hljs-variable constant_">LRU</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) &#123;<span class="hljs-comment">// 如果有这个缓存，取出并调整在map中的位置</span><span class="hljs-keyword">const</span> val = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key);<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, val);<span class="hljs-keyword">return</span> val;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;;<span class="hljs-variable constant_">LRU</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">key, val</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key)) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key);<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, val);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">const</span> size = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span>;<span class="hljs-keyword">if</span> (size === <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>) &#123;<span class="hljs-comment">// 缓存满了，删除最旧的</span><span class="hljs-keyword">const</span> _key = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(_key);<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, val);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key, val);&#125;&#125;&#125;;</code></pre></div><h2 id="co-自执行generator函数"><a href="#co-自执行generator函数" class="headerlink" title="co 自执行generator函数"></a>co 自执行generator函数</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">co</span>(<span class="hljs-params">generator</span>) &#123;<span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">generator</span>()<span class="hljs-keyword">let</span> ret<span class="hljs-keyword">try</span>&#123;ret = gen.<span class="hljs-title function_">next</span>()&#125;<span class="hljs-keyword">catch</span>(e)&#123;ret = gen.<span class="hljs-keyword">throw</span>(e)&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">step</span>(ret)<span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">res</span>)&#123;<span class="hljs-keyword">if</span>(res.<span class="hljs-property">done</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">value</span>)&#125;<span class="hljs-comment">// promise化</span><span class="hljs-keyword">if</span>(!(res.<span class="hljs-property">value</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>))&#123;res.<span class="hljs-property">value</span> = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">value</span>)&#125;<span class="hljs-keyword">return</span> res.<span class="hljs-property">value</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span><span class="hljs-title function_">step</span>(gen.<span class="hljs-title function_">next</span>(v)),<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span><span class="hljs-title function_">step</span>(gen.<span class="hljs-keyword">throw</span>(e)))&#125;&#125;<span class="hljs-comment">// test</span><span class="hljs-keyword">const</span> gen1 = <span class="hljs-keyword">function</span>* ()&#123;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> ret = <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(res)<span class="hljs-keyword">return</span> ret&#125;<span class="hljs-title function_">co</span>(g1).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)); <span class="hljs-comment">// 1</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex@3.x实现分析</title>
    <link href="/2022/03/14/vue2-vuex/"/>
    <url>/2022/03/14/vue2-vuex/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h1><h2 id="安装-Vuex"><a href="#安装-Vuex" class="headerlink" title="安装 Vuex"></a>安装 Vuex</h2><p>在组件<code>beforeCreate</code>的钩子中将 vuex 的<code>Store</code>实例挂载在实例<code>this.$store</code>上；</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">vuexInit</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>;<span class="hljs-comment">// store injection</span><span class="hljs-keyword">if</span> (options.<span class="hljs-property">store</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span> = <span class="hljs-keyword">typeof</span> options.<span class="hljs-property">store</span> === <span class="hljs-string">&quot;function&quot;</span> ? options.<span class="hljs-title function_">store</span>() : options.<span class="hljs-property">store</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.<span class="hljs-property">parent</span> &amp;&amp; options.<span class="hljs-property">parent</span>.<span class="hljs-property">$store</span>) &#123;<span class="hljs-comment">// 如果是子组件中执行，也会指向最顶层的$store</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span> = options.<span class="hljs-property">parent</span>.<span class="hljs-property">$store</span>;&#125;&#125;</code></pre></div><h2 id="实例化-Store"><a href="#实例化-Store" class="headerlink" title="实例化 Store"></a>实例化 Store</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用new Store()</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">options = &#123;&#125;</span>) &#123;<span class="hljs-comment">// options是vue实例化的options</span><span class="hljs-keyword">const</span> &#123; plugins = [], strict = <span class="hljs-literal">false</span> &#125; = options;<span class="hljs-comment">// store internal state</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">_committing</span> = <span class="hljs-literal">false</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">_actions</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<span class="hljs-variable language_">this</span>.<span class="hljs-property">_actionSubscribers</span> = [];<span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<span class="hljs-variable language_">this</span>.<span class="hljs-property">_wrappedGetters</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<span class="hljs-variable language_">this</span>.<span class="hljs-property">_modules</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleCollection</span>(options); <span class="hljs-comment">/* ⭐️初始化模块 */</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">_modulesNamespaceMap</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<span class="hljs-variable language_">this</span>.<span class="hljs-property">_subscribers</span> = [];<span class="hljs-variable language_">this</span>.<span class="hljs-property">_watcherVM</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(); <span class="hljs-comment">/*用一个新的vue实例作为vuexWatcher*/</span><span class="hljs-comment">// bind commit and dispatch to self</span><span class="hljs-keyword">const</span> store = <span class="hljs-variable language_">this</span>;<span class="hljs-keyword">const</span> &#123; dispatch, commit &#125; = <span class="hljs-variable language_">this</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">dispatch</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundDispatch</span>(<span class="hljs-params">type, payload</span>) &#123;<span class="hljs-keyword">return</span> dispatch.<span class="hljs-title function_">call</span>(store, type, payload);&#125;;<span class="hljs-variable language_">this</span>.<span class="hljs-property">commit</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">boundCommit</span>(<span class="hljs-params">type, payload, options</span>) &#123;<span class="hljs-keyword">return</span> commit.<span class="hljs-title function_">call</span>(store, type, payload, options);&#125;;<span class="hljs-comment">// 根store就是_module.root</span><span class="hljs-keyword">const</span> state = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_modules</span>.<span class="hljs-property">root</span>.<span class="hljs-property">state</span>;<span class="hljs-comment">/* ⭐️安装模块 */</span><span class="hljs-title function_">installModule</span>(<span class="hljs-variable language_">this</span>, state, [], <span class="hljs-variable language_">this</span>.<span class="hljs-property">_modules</span>.<span class="hljs-property">root</span>);<span class="hljs-comment">// 初始化 store vm, 负责提供相应式</span><span class="hljs-comment">// (also registers _wrappedGetters as computed properties)</span><span class="hljs-title function_">resetStoreVM</span>(<span class="hljs-variable language_">this</span>, state);<span class="hljs-comment">// 应用plugin</span>plugins.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">plugin</span>) =&gt;</span> <span class="hljs-title function_">plugin</span>(<span class="hljs-variable language_">this</span>));<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">devtools</span>) &#123;<span class="hljs-comment">// devtool</span><span class="hljs-title function_">devtoolPlugin</span>(<span class="hljs-variable language_">this</span>);&#125;&#125;&#125;</code></pre></div><h3 id="初始化模块"><a href="#初始化模块" class="headerlink" title="初始化模块"></a>初始化模块</h3><p>从根<code>module</code>开始，按照层级关系递归实例化所有的子<code>module</code>为一整个树形结构的对象</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ModuleCollection</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">rawRootModule</span>) &#123;<span class="hljs-comment">// 为根store模块开始执行register方法</span><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">register</span>([], rawRootModule, <span class="hljs-literal">false</span>);&#125;<span class="hljs-comment">// 根据path去查找模块</span><span class="hljs-title function_">get</span>(<span class="hljs-params">path</span>) &#123;<span class="hljs-keyword">return</span> path.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">module</span>, key</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">getChild</span>(key);<span class="hljs-comment">/**</span><span class="hljs-comment"> * getChild (key) &#123;</span><span class="hljs-comment"> *   return this._children[key]</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span>&#125;, <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>);&#125;<span class="hljs-title function_">register</span>(<span class="hljs-params">path, rawModule, runtime = <span class="hljs-literal">true</span></span>) &#123;<span class="hljs-comment">/// ...</span><span class="hljs-keyword">const</span> newModule = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Module</span>(rawModule, runtime);<span class="hljs-comment">// 生成单个的module实例</span><span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// path长度是0说明是根module</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = newModule;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 否则添加为上级的子模块</span><span class="hljs-keyword">const</span> parent = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(path.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));parent.<span class="hljs-title function_">addChild</span>(path[path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>], newModule);<span class="hljs-comment">/**</span><span class="hljs-comment"> * addChild (key, module) &#123;</span><span class="hljs-comment"> *   this._children[key] = module</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span>&#125;<span class="hljs-comment">// 为当前模块中的所有子模块递归调用register</span><span class="hljs-keyword">if</span> (rawModule.<span class="hljs-property">modules</span>) &#123;<span class="hljs-title function_">forEachValue</span>(rawModule.<span class="hljs-property">modules</span>, <span class="hljs-function">(<span class="hljs-params">rawChildModule, key</span>) =&gt;</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">register</span>(path.<span class="hljs-title function_">concat</span>(key), rawChildModule, runtime);&#125;);&#125;&#125;&#125;</code></pre></div><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">installModule</span>(<span class="hljs-params">store, rootState, path, <span class="hljs-variable language_">module</span>, hot</span>) &#123;<span class="hljs-comment">// 判断是否根模块</span><span class="hljs-keyword">const</span> isRoot = !path.<span class="hljs-property">length</span>;<span class="hljs-comment">// 判断有没有命名空间</span><span class="hljs-keyword">const</span> namespace = store.<span class="hljs-property">_modules</span>.<span class="hljs-title function_">getNamespace</span>(path);<span class="hljs-comment">// return namespace + (module.namespaced ? key + &#x27;/&#x27; : &#x27;&#x27;)</span><span class="hljs-comment">// 注册到namespace map</span><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">namespaced</span>) &#123;store.<span class="hljs-property">_modulesNamespaceMap</span>[namespace] = <span class="hljs-variable language_">module</span>;&#125;<span class="hljs-comment">// set state</span><span class="hljs-keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;<span class="hljs-keyword">const</span> parentState = <span class="hljs-title function_">getNestedState</span>(rootState, path.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));<span class="hljs-keyword">const</span> moduleName = path[path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];store.<span class="hljs-title function_">_withCommit</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(parentState, moduleName, <span class="hljs-variable language_">module</span>.<span class="hljs-property">state</span>);&#125;);&#125;<span class="hljs-keyword">const</span> local = (<span class="hljs-variable language_">module</span>.<span class="hljs-property">context</span> = <span class="hljs-title function_">makeLocalContext</span>(store, namespace, path));<span class="hljs-comment">// 创建一个local上下文</span><span class="hljs-comment">// 对于有namespace的dispatch和commit会拼接上namespace</span><span class="hljs-comment">// 对于有namespace的getter有特殊处理，不是直接返回而是用Object。defineProperty设置了getter</span><span class="hljs-comment">/** </span><span class="hljs-comment">   * function makeLocalContext (store, namespace, path) &#123;</span><span class="hljs-comment">        const noNamespace = namespace === &#x27;&#x27;</span><span class="hljs-comment">        const local = &#123;</span><span class="hljs-comment">          dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =&gt; &#123;...&#125;),</span><span class="hljs-comment">          commit: noNamespace ? store.commit : (_type, _payload, _options) =&gt; &#123;...&#125;)</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">        </span><span class="hljs-comment">        Object.defineProperties(local, &#123;</span><span class="hljs-comment">          getters: &#123;</span><span class="hljs-comment">            get: noNamespace</span><span class="hljs-comment">              ? () =&gt; store.getters</span><span class="hljs-comment">              : () =&gt; makeLocalGetters(store, namespace)</span><span class="hljs-comment">          &#125;,</span><span class="hljs-comment">          state: &#123;</span><span class="hljs-comment">            get: () =&gt; getNestedState(store.state, path)</span><span class="hljs-comment">          &#125;</span><span class="hljs-comment">        &#125;)</span><span class="hljs-comment">        return local</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">  */</span> <span class="hljs-comment">// 注册 各种方法</span><span class="hljs-variable language_">module</span>.<span class="hljs-title function_">forEachMutation</span>(<span class="hljs-function">(<span class="hljs-params">mutation, key</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> namespacedType = namespace + key;<span class="hljs-title function_">registerMutation</span>(store, namespacedType, mutation, local);&#125;);<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">forEachAction</span>(<span class="hljs-function">(<span class="hljs-params">action, key</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> type = action.<span class="hljs-property">root</span> ? key : namespace + key;<span class="hljs-keyword">const</span> handler = action.<span class="hljs-property">handler</span> || action;<span class="hljs-title function_">registerAction</span>(store, type, handler, local);&#125;);<span class="hljs-variable language_">module</span>.<span class="hljs-title function_">forEachGetter</span>(<span class="hljs-function">(<span class="hljs-params">getter, key</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> namespacedType = namespace + key;<span class="hljs-title function_">registerGetter</span>(store, namespacedType, getter, local);&#125;);<span class="hljs-comment">// 遍历安装子模块</span><span class="hljs-variable language_">module</span>.<span class="hljs-title function_">forEachChild</span>(<span class="hljs-function">(<span class="hljs-params">child, key</span>) =&gt;</span> &#123;<span class="hljs-title function_">installModule</span>(store, rootState, path.<span class="hljs-title function_">concat</span>(key), child, hot);&#125;);&#125;</code></pre></div><h3 id="实例化store-vm"><a href="#实例化store-vm" class="headerlink" title="实例化store.vm"></a>实例化store.vm</h3><ul><li>建立<code>getter</code>和<code>state</code>之间的联系</li><li>使用一个vue实例来存储<code>state</code>，访问了 <code>store._vm[key]</code>，也就是 <code>computed[key]</code></li><li><code>computed</code>的特性可以缓存并且<code>state</code>变化的时候才会重新计算</li><li>当 <code>store.state</code> 发生变化的时候，下一次再访问 <code>store.getters</code> 的时候会重新计算。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resetStoreVM</span> (store, state, hot) &#123;  <span class="hljs-keyword">const</span> oldVm = store.<span class="hljs-property">_vm</span>  <span class="hljs-comment">// bind store public getters</span>  store.<span class="hljs-property">getters</span> = &#123;&#125;  <span class="hljs-keyword">const</span> wrappedGetters = store.<span class="hljs-property">_wrappedGetters</span>  <span class="hljs-keyword">const</span> computed = &#123;&#125;  <span class="hljs-title function_">forEachValue</span>(wrappedGetters, <span class="hljs-function">(<span class="hljs-params">fn, key</span>) =&gt;</span> &#123;    <span class="hljs-comment">// use computed to leverage its lazy-caching mechanism</span>    computed[key] = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(store)    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(store.<span class="hljs-property">getters</span>, key, &#123;      <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">_vm</span>[key],      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// for local getters</span>    &#125;)  &#125;)  <span class="hljs-comment">// 使用一个vue实例来存储state，访问state就是访问computed[key]，</span><span class="hljs-comment">// 实现state改变的时候getter才改变，并且被缓存</span>  store.<span class="hljs-property">_vm</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;    <span class="hljs-attr">data</span>: &#123;      <span class="hljs-attr">$$state</span>: state    &#125;,    computed  &#125;)  <span class="hljs-comment">// enable strict mode for new vm</span>  <span class="hljs-keyword">if</span> (store.<span class="hljs-property">strict</span>) &#123;    <span class="hljs-title function_">enableStrictMode</span>(store)  &#125;<span class="hljs-comment">// 严格模式会添加一个watch监测state的改变是否来自非vuex接口</span><span class="hljs-comment">// function enableStrictMode (store) &#123;</span><span class="hljs-comment">// store._vm.$watch(function () &#123; return this._data.$$state &#125;, () =&gt; &#123;</span><span class="hljs-comment">// if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><span class="hljs-comment">// assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// &#125;, &#123; deep: true, sync: true &#125;)</span><span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">if</span> (oldVm) &#123;    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> oldVm.$destroy())  &#125;&#125;</code></pre></div><h1 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h1><ol><li>在<code>beforeCreate</code>钩子中混入<code>vuexInit()</code>方法</li><li>通过递归判断是否有父组件，绑定<code>this.$store</code>指向到实例化的<code>Store</code></li><li>从根<code>module</code>按照父子层级计算出完整的<code>module</code>树</li><li>从根<code>module</code>开始梳理有<code>namespace</code>的模块，会在他路径前拼接上<code>namespace</code>，并保存下一个<code>_modulesNamespaceMap</code></li><li>遍历模块中的所有子 modules，递归执行 installModule 方法，计算各自<code>state``getter``commit``dispatch</code>的访问路径</li><li>按照各个API的入口，将自定义的回调函数加入入口数组</li><li><code>getter</code>的特性会使用一个vue实例和<code>computed</code>属性实现，只有getter依赖的state变化后getter的结果也会变化</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
      <tag>源码</tag>
      
      <tag>vuex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router@3.x实现分析</title>
    <link href="/2022/03/10/vue2-router/"/>
    <url>/2022/03/10/vue2-router/</url>
    
    <content type="html"><![CDATA[<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><h3 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a><code>hash</code>模式</h3><p>原理：监听<code>onHashChange</code>和修改<code>URL</code>的<code>hash</code>值<code>#xxx</code></p><ul><li>  不刷新页面</li><li>  <code>hash</code>不会发送到服务器</li><li>  <code>hash</code>的改变会保存历史记录</li><li>  通过<code>&lt;a&gt;</code>标签的<code>href</code>或者<code>location.hash</code>修改</li></ul><h3 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a><code>history</code>模式</h3><p>原理：监听<code>history.popState</code>，通过<code>pushState``replaceState</code>修改历史栈</p><ul><li>  不刷新页面</li><li>  H5 <code>history API</code></li><li>  服务器需要配合设置地址不匹配回退</li><li>  <code>SEO</code>比 hash 好</li></ul><h2 id="abstract模式"><a href="#abstract模式" class="headerlink" title="abstract模式"></a><code>abstract</code>模式</h2><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>  params</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<span class="hljs-comment">// 动态字段以冒号开始</span>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/users/:id&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;,];</code></pre></div><ul><li>  query</li></ul><p>URL 地址的 query 部分</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">/users?id=<span class="hljs-number">123</span></code></pre></div><h2 id="路由钩子"><a href="#路由钩子" class="headerlink" title="路由钩子"></a>路由钩子</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 全局</span>router.<span class="hljs-title function_">beforeEach</span>((to,form,next)) <span class="hljs-comment">// 导航触发时</span>router.<span class="hljs-title function_">beforeResolve</span>((to,form,next)) <span class="hljs-comment">// 所有组件内守卫和异步路由组件被解析之后</span>router.<span class="hljs-title function_">afterEach</span>((to, <span class="hljs-keyword">from</span>, failure))<span class="hljs-comment">// 全局钩子可以定义多个，顺序执行完后才会resolve路由</span><span class="hljs-comment">// 路由</span><span class="hljs-title function_">beforeEnter</span>() <span class="hljs-comment">// 不会在 params、query 或 hash 改变触发，只会在导航路径改变触发</span>&#123;  <span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/a&#x27;</span>,  <span class="hljs-attr">component</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;@/component/A&#x27;</span>),  <span class="hljs-attr">beforeEnter</span>:<span class="hljs-function">(<span class="hljs-params">(to,<span class="hljs-keyword">from</span>,next)</span>)=&gt;</span>&#123;&#125; <span class="hljs-comment">//</span>&#125;<span class="hljs-comment">// 组件内</span><span class="hljs-title function_">beforeRouteEnter</span>((to,<span class="hljs-keyword">from</span>,<span class="hljs-attr">next</span>:<span class="hljs-function">(<span class="hljs-params">vm</span>)=&gt;</span>&#123;<span class="hljs-comment">/*访问this*/</span>&#125;)) <span class="hljs-comment">// 组件实例创建之前</span><span class="hljs-title function_">beforeRouteUpdate</span>((to,<span class="hljs-keyword">from</span>))<span class="hljs-comment">/* CompositionAPI onBeforeRouteUpdate */</span><span class="hljs-title function_">beforeRouteLeave</span>((to,<span class="hljs-keyword">from</span>))<span class="hljs-comment">/* CompositionAPI onBeforeRouteLeave */</span></code></pre></div><h3 id="触发流程：pageA-gt-pageB"><a href="#触发流程：pageA-gt-pageB" class="headerlink" title="触发流程：pageA=&gt;pageB"></a>触发流程：pageA=&gt;pageB</h3><ol><li><p>pageA.<code>beforeRouteLeave</code></p></li><li><p>router.<code>beforeEach</code></p></li><li><p>routes[pageB].<code>beforeEnter</code></p></li><li><p>pageB.<code>beforeRouteEnter</code></p><blockquote><p>如果 pageB 渲染过，忽略【3，4】执行 pageB.beforeRouteUpdate</p></blockquote></li><li><p>router.<code>beforeResolve</code></p></li><li><p>router.<code>afterEach</code></p></li><li><p>DOM 更新/挂载</p></li><li><p>执行第【4】步中<code>next</code>回调</p></li></ol><h1 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h1><h2 id="Vue-use-安装路由"><a href="#Vue-use-安装路由" class="headerlink" title="Vue.use 安装路由"></a>Vue.use 安装路由</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) &#123;<span class="hljs-keyword">if</span> (install.<span class="hljs-property">installed</span> &amp;&amp; _Vue === <span class="hljs-title class_">Vue</span>) <span class="hljs-keyword">return</span>;install.<span class="hljs-property">installed</span> = <span class="hljs-literal">true</span>;_Vue = <span class="hljs-title class_">Vue</span>;<span class="hljs-keyword">const</span> <span class="hljs-title function_">isDef</span> = (<span class="hljs-params">v</span>) =&gt; v !== <span class="hljs-literal">undefined</span>;<span class="hljs-keyword">const</span> <span class="hljs-title function_">registerInstance</span> = (<span class="hljs-params">vm, callVal</span>) =&gt; &#123;<span class="hljs-keyword">let</span> i = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">_parentVnode</span>;<span class="hljs-comment">// 伪代码</span><span class="hljs-title function_">registerRouteInstance</span>(vm, callVal);<span class="hljs-comment">// router-view render函数的registerRouteInstance方法</span>&#125;;<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>)) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">//  路由的root组件</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>; <span class="hljs-comment">// 路由实例</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// init见下文</span><span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;_route&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-property">history</span>.<span class="hljs-property">current</span>);<span class="hljs-comment">// 🔥对router-view的响应式绑定</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">_routerRoot</span>) || <span class="hljs-variable language_">this</span>;<span class="hljs-comment">// 如果是子组件，将追溯到拥有router的父组件作为root，执行上面几行逻辑</span>&#125;<span class="hljs-title function_">registerInstance</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">this</span>);&#125;,<span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">registerInstance</span>(<span class="hljs-variable language_">this</span>);&#125;,&#125;);<span class="hljs-comment">// 为Vue的原型绑定`$router``$route`的getter和全局注册两个组件</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;$router&quot;</span>, &#123;<span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span>.<span class="hljs-property">_router</span>;&#125;,&#125;);<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;$route&quot;</span>, &#123;<span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span>.<span class="hljs-property">_route</span>;&#125;,&#125;);<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;RouterView&quot;</span>, <span class="hljs-title class_">View</span>);<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;RouterLink&quot;</span>, <span class="hljs-title class_">Link</span>);<span class="hljs-keyword">const</span> strats = <span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">optionMergeStrategies</span>;strats.<span class="hljs-property">beforeRouteEnter</span> = strats.<span class="hljs-property">beforeRouteLeave</span> = strats.<span class="hljs-property">beforeRouteUpdate</span> = strats.<span class="hljs-property">created</span>;&#125;</code></pre></div><h2 id="实例化一个-router"><a href="#实例化一个-router" class="headerlink" title="实例化一个 router"></a>实例化一个 router</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">options: RouterOptions = &#123;&#125;</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 根组件</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">apps</span> = []; <span class="hljs-comment">// options中有router项的实例</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options; <span class="hljs-comment">//  路由配置</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">beforeHooks</span> = [];<span class="hljs-variable language_">this</span>.<span class="hljs-property">resolveHooks</span> = []; <span class="hljs-comment">// 钩子</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">afterHooks</span> = [];<span class="hljs-variable language_">this</span>.<span class="hljs-property">matcher</span> = <span class="hljs-title function_">createMatcher</span>(options.<span class="hljs-property">routes</span> || [], <span class="hljs-variable language_">this</span>);<span class="hljs-keyword">let</span> mode = options.<span class="hljs-property">mode</span> || <span class="hljs-string">&quot;hash&quot;</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">fallback</span> = mode === <span class="hljs-string">&quot;history&quot;</span> &amp;&amp; !supportsPushState &amp;&amp; options.<span class="hljs-property">fallback</span> !== <span class="hljs-literal">false</span>;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">fallback</span>) &#123;<span class="hljs-comment">// 回退到hash模式</span>mode = <span class="hljs-string">&quot;hash&quot;</span>;&#125;<span class="hljs-keyword">if</span> (!inBrowser) &#123;mode = <span class="hljs-string">&quot;abstract&quot;</span>;&#125;<span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode;<span class="hljs-keyword">switch</span> (mode) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;history&quot;</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTML5History</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hash&quot;</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashHistory</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">fallback</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;abstract&quot;</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbstractHistory</span>(<span class="hljs-variable language_">this</span>, options.<span class="hljs-property">base</span>);<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-title function_">init</span>(<span class="hljs-params">app: any</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">apps</span>.<span class="hljs-title function_">push</span>(app);<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span> = app;<span class="hljs-keyword">const</span> history = <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>;<span class="hljs-keyword">if</span> (history <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HTML5History</span>) &#123;history.<span class="hljs-title function_">transitionTo</span>(history.<span class="hljs-title function_">getCurrentLocation</span>());&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (history <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">HashHistory</span>) &#123;<span class="hljs-keyword">const</span> <span class="hljs-title function_">setupHashListener</span> = (<span class="hljs-params"></span>) =&gt; &#123;history.<span class="hljs-title function_">setupListeners</span>();&#125;;history.<span class="hljs-title function_">transitionTo</span>(history.<span class="hljs-title function_">getCurrentLocation</span>(), setupHashListener, setupHashListener);&#125;history.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">apps</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">app</span>) =&gt;</span> &#123;app.<span class="hljs-property">_route</span> = route;&#125;);&#125;);&#125;&#125;</code></pre></div><h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><h3 id="createMatcher"><a href="#createMatcher" class="headerlink" title="createMatcher"></a>createMatcher</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMatcher</span>(<span class="hljs-params">routes: <span class="hljs-built_in">Array</span>&lt;RouteConfig&gt;, router: VueRouter</span>): <span class="hljs-title class_">Matcher</span> &#123;<span class="hljs-comment">// 根据routes构建出path的集合pathList,</span><span class="hljs-comment">// path 到 RouteRecord的映射表pathMap</span><span class="hljs-comment">// name 到 RouteRecord的映射表nameMap</span><span class="hljs-comment">//  const record: RouteRecord = &#123;</span><span class="hljs-comment">//   path: normalizedPath,</span><span class="hljs-comment">//   regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),</span><span class="hljs-comment">//   components: route.components || &#123; default: route.component &#125;,</span><span class="hljs-comment">//   instances: &#123;&#125;,</span><span class="hljs-comment">//   name,</span><span class="hljs-comment">//   parent,</span><span class="hljs-comment">//   matchAs,</span><span class="hljs-comment">//   redirect: route.redirect,</span><span class="hljs-comment">//   beforeEnter: route.beforeEnter,</span><span class="hljs-comment">//   meta: route.meta || &#123;&#125;,</span><span class="hljs-comment">//   props: route.props == null</span><span class="hljs-comment">//     ? &#123;&#125;</span><span class="hljs-comment">//     : route.components</span><span class="hljs-comment">//       ? route.props</span><span class="hljs-comment">//       : &#123; default: route.props &#125;</span><span class="hljs-comment">// &#125;</span><span class="hljs-keyword">const</span> &#123; pathList, pathMap, nameMap &#125; = <span class="hljs-title function_">createRouteMap</span>(routes);<span class="hljs-comment">// 动态添加路由的方法</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">addRoutes</span>(<span class="hljs-params">routes</span>) &#123;<span class="hljs-title function_">createRouteMap</span>(routes, pathList, pathMap, nameMap);&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location</span>): <span class="hljs-title class_">Route</span> &#123;<span class="hljs-keyword">const</span> location = <span class="hljs-title function_">normalizeLocation</span>(raw, currentRoute, <span class="hljs-literal">false</span>, router);<span class="hljs-keyword">const</span> &#123; name &#125; = location;<span class="hljs-keyword">if</span> (name) &#123;<span class="hljs-keyword">const</span> record = nameMap[name];<span class="hljs-keyword">if</span> (!record) <span class="hljs-keyword">return</span> <span class="hljs-title function_">_createRoute</span>(<span class="hljs-literal">null</span>, location);<span class="hljs-keyword">const</span> paramNames = record.<span class="hljs-property">regex</span>.<span class="hljs-property">keys</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> !key.<span class="hljs-property">optional</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> key.<span class="hljs-property">name</span>);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> location.<span class="hljs-property">params</span> !== <span class="hljs-string">&quot;object&quot;</span>) &#123;location.<span class="hljs-property">params</span> = &#123;&#125;;&#125;<span class="hljs-keyword">if</span> (currentRoute &amp;&amp; <span class="hljs-keyword">typeof</span> currentRoute.<span class="hljs-property">params</span> === <span class="hljs-string">&quot;object&quot;</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> currentRoute.<span class="hljs-property">params</span>) &#123;<span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> location.<span class="hljs-property">params</span>) &amp;&amp; paramNames.<span class="hljs-title function_">indexOf</span>(key) &gt; -<span class="hljs-number">1</span>) &#123;location.<span class="hljs-property">params</span>[key] = currentRoute.<span class="hljs-property">params</span>[key];&#125;&#125;&#125;<span class="hljs-keyword">if</span> (record) &#123;location.<span class="hljs-property">path</span> = <span class="hljs-title function_">fillParams</span>(record.<span class="hljs-property">path</span>, location.<span class="hljs-property">params</span>, <span class="hljs-string">`named route &quot;<span class="hljs-subst">$&#123;name&#125;</span>&quot;`</span>);<span class="hljs-keyword">return</span> <span class="hljs-title function_">_createRoute</span>(record, location, redirectedFrom);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (location.<span class="hljs-property">path</span>) &#123;location.<span class="hljs-property">params</span> = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pathList.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">const</span> path = pathList[i];<span class="hljs-keyword">const</span> record = pathMap[path];<span class="hljs-keyword">if</span> (<span class="hljs-title function_">matchRoute</span>(record.<span class="hljs-property">regex</span>, location.<span class="hljs-property">path</span>, location.<span class="hljs-property">params</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">_createRoute</span>(record, location, redirectedFrom);&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">_createRoute</span>(<span class="hljs-literal">null</span>, location);&#125;<span class="hljs-comment">// ...</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">_createRoute</span>(<span class="hljs-params">record: ?RouteRecord, location: Location, redirectedFrom?: Location</span>): <span class="hljs-title class_">Route</span> &#123;<span class="hljs-comment">// 重定向</span><span class="hljs-keyword">if</span> (record &amp;&amp; record.<span class="hljs-property">redirect</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">redirect</span>(record, redirectedFrom || location);&#125;<span class="hljs-comment">// alias</span><span class="hljs-keyword">if</span> (record &amp;&amp; record.<span class="hljs-property">matchAs</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">alias</span>(record, location, record.<span class="hljs-property">matchAs</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">createRoute</span>(record, location, redirectedFrom, router);&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRoute</span>(<span class="hljs-params"></span><span class="hljs-params">record: ?RouteRecord,</span><span class="hljs-params">location: Location,</span><span class="hljs-params">redirectedFrom?: ?Location,</span><span class="hljs-params">router?: VueRouter</span><span class="hljs-params"></span>): <span class="hljs-title class_">Route</span> &#123;<span class="hljs-keyword">const</span> stringifyQuery = router &amp;&amp; router.<span class="hljs-property">options</span>.<span class="hljs-property">stringifyQuery</span>;<span class="hljs-keyword">let</span> <span class="hljs-attr">query</span>: any = location.<span class="hljs-property">query</span> || &#123;&#125;;<span class="hljs-keyword">try</span> &#123;query = <span class="hljs-title function_">clone</span>(query);&#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<span class="hljs-keyword">const</span> <span class="hljs-attr">route</span>: <span class="hljs-title class_">Route</span> = &#123;<span class="hljs-attr">name</span>: location.<span class="hljs-property">name</span> || (record &amp;&amp; record.<span class="hljs-property">name</span>),<span class="hljs-attr">meta</span>: (record &amp;&amp; record.<span class="hljs-property">meta</span>) || &#123;&#125;,<span class="hljs-attr">path</span>: location.<span class="hljs-property">path</span> || <span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-attr">hash</span>: location.<span class="hljs-property">hash</span> || <span class="hljs-string">&quot;&quot;</span>,query,<span class="hljs-attr">params</span>: location.<span class="hljs-property">params</span> || &#123;&#125;,<span class="hljs-attr">fullPath</span>: <span class="hljs-title function_">getFullPath</span>(location, stringifyQuery),<span class="hljs-attr">matched</span>: record ? <span class="hljs-title function_">formatMatch</span>(record) : [],&#125;;<span class="hljs-keyword">if</span> (redirectedFrom) &#123;route.<span class="hljs-property">redirectedFrom</span> = <span class="hljs-title function_">getFullPath</span>(redirectedFrom, stringifyQuery);&#125;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(route);&#125;<span class="hljs-keyword">return</span> &#123;match,addRoutes,&#125;;&#125;</code></pre></div><h2 id="路径切换"><a href="#路径切换" class="headerlink" title="路径切换"></a>路径切换</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">transitionTo (<span class="hljs-attr">location</span>: <span class="hljs-title class_">RawLocation</span>, onComplete?: <span class="hljs-title class_">Function</span>, onAbort?: <span class="hljs-title class_">Function</span>) &#123;  <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">match</span>(location, <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>)  <span class="hljs-comment">// 根据目标 location 和当前路径 this.current 执行 this.router.match 方法去匹配到目标的路径</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">confirmTransition</span>(route, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateRoute</span>(route)    onComplete &amp;&amp; <span class="hljs-title function_">onComplete</span>(route)    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">ready</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">ready</span> = <span class="hljs-literal">true</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">readyCbs</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> &#123; <span class="hljs-title function_">cb</span>(route) &#125;)    &#125;  &#125;  <span class="hljs-comment">//...</span>  )&#125;updateRoute (<span class="hljs-attr">route</span>: <span class="hljs-title class_">Route</span>) &#123;  <span class="hljs-keyword">const</span> prev = <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = route  <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(route)  <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">afterHooks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">hook</span> =&gt;</span> &#123; <span class="hljs-comment">/* router.afterEach */</span>    hook &amp;&amp; <span class="hljs-title function_">hook</span>(route, prev)  &#125;)&#125;</code></pre></div><h3 id="confirmTransition"><a href="#confirmTransition" class="headerlink" title="confirmTransition"></a>confirmTransition</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">confirmTransition (<span class="hljs-attr">route</span>: <span class="hljs-title class_">Route</span>, <span class="hljs-attr">onComplete</span>: <span class="hljs-title class_">Function</span>, onAbort?: <span class="hljs-title class_">Function</span>) &#123;  <span class="hljs-keyword">const</span> current = <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>  <span class="hljs-keyword">const</span> &#123;    updated,    deactivated,    activated  &#125; = <span class="hljs-title function_">resolveQueue</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>.<span class="hljs-property">matched</span>, route.<span class="hljs-property">matched</span>)  <span class="hljs-comment">// matched数组属性保存了从匹配到的record循环向上一直到最外层的所有的record</span>  <span class="hljs-comment">// resolve解析出三个队列</span>  <span class="hljs-comment">// a/b/c =&gt; a/b/d</span>  <span class="hljs-comment">// deactivated : [c]</span>  <span class="hljs-comment">// activate : [d]</span>  <span class="hljs-comment">// updated : [a,b]</span>  <span class="hljs-comment">// 生成一个按照路由钩子顺序的队列</span>  <span class="hljs-keyword">const</span> queue = [].<span class="hljs-title function_">concat</span>(    <span class="hljs-title function_">extractLeaveGuards</span>(deactivated), <span class="hljs-comment">/* 执行离开的钩子 */</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">beforeHooks</span>, <span class="hljs-comment">/* router.beforeEach */</span>    <span class="hljs-title function_">extractUpdateHooks</span>(updated), <span class="hljs-comment">/*  beforeRouteUpdate */</span>    activated.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">beforeEnter</span>), <span class="hljs-comment">/* beforeRouteEnter */</span>    <span class="hljs-title function_">resolveAsyncComponents</span>(activated) <span class="hljs-comment">/*解析异步路由组件*/</span>  )  <span class="hljs-title function_">runQueue</span>(queue, iterator, <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">const</span> postEnterCbs = []    <span class="hljs-keyword">const</span> <span class="hljs-title function_">isValid</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> === route    <span class="hljs-comment">// beforeRouteEnter</span>    <span class="hljs-keyword">const</span> enterGuards = <span class="hljs-title function_">extractEnterGuards</span>(activated, postEnterCbs, isValid)    <span class="hljs-comment">// ⭐️beforeRouteEnter的回调会添加到postEnterCbs数组中，等路由更新后在最后执行</span>    <span class="hljs-comment">// router.beforeResolve</span>    <span class="hljs-keyword">const</span> queue = enterGuards.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">resolveHooks</span>)    <span class="hljs-title function_">runQueue</span>(queue, iterator, <span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-title function_">onComplete</span>(route)      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">app</span>) &#123;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">app</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;          postEnterCbs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> &#123; <span class="hljs-title function_">cb</span>() &#125;)          <span class="hljs-comment">// ⭐️执行postEnterCbs中的回调</span>        &#125;)      &#125;    &#125;)  &#125;)&#125;</code></pre></div><h2 id="lt-router-view-gt"><a href="#lt-router-view-gt" class="headerlink" title="&lt;router-view&gt;"></a><code>&lt;router-view&gt;</code></h2><p>把根 <code>Vue</code> 实例的 <code>_route</code> 属性是响应式的，在每个 <code>&lt;router-view&gt;</code>的<code>render</code> 函数的时候，都会访问 <code>parent.$route</code>，该<code>&lt;router-view&gt;</code> 就订阅了<code>router</code>的变化</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;RouterView&quot;</span>,<span class="hljs-attr">functional</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">props</span>: &#123;<span class="hljs-attr">name</span>: &#123;<span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<span class="hljs-attr">default</span>: <span class="hljs-string">&quot;default&quot;</span>,&#125;,&#125;,<span class="hljs-title function_">render</span>(<span class="hljs-params">_, &#123; props, children, parent, data &#125;</span>) &#123;data.<span class="hljs-property">routerView</span> = <span class="hljs-literal">true</span>;<span class="hljs-keyword">const</span> h = parent.<span class="hljs-property">$createElement</span>;<span class="hljs-keyword">const</span> name = props.<span class="hljs-property">name</span>;<span class="hljs-keyword">const</span> route = parent.<span class="hljs-property">$route</span>; <span class="hljs-comment">// 🔥执行时会触发响应式收集为router的依赖，当router更新时重新执行</span><span class="hljs-keyword">const</span> cache = parent.<span class="hljs-property">_routerViewCache</span> || (parent.<span class="hljs-property">_routerViewCache</span> = &#123;&#125;);<span class="hljs-keyword">while</span> (parent &amp;&amp; parent.<span class="hljs-property">_routerRoot</span> !== parent) &#123;parent = parent.<span class="hljs-property">$parent</span>;&#125;<span class="hljs-keyword">const</span> component = (cache[name] = matched.<span class="hljs-property">components</span>[name]);<span class="hljs-comment">// 给 matched.instances[name] 赋值当前组件的 vm 实例</span>data.<span class="hljs-property">registerRouteInstance</span> = <span class="hljs-function">(<span class="hljs-params">vm, val</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> current = matched.<span class="hljs-property">instances</span>[name];<span class="hljs-keyword">if</span> ((val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm)) &#123;matched.<span class="hljs-property">instances</span>[name] = val;&#125;&#125;;(data.<span class="hljs-property">hook</span> || (data.<span class="hljs-property">hook</span> = &#123;&#125;)).<span class="hljs-property">prepatch</span> = <span class="hljs-function">(<span class="hljs-params">_, vnode</span>) =&gt;</span> &#123;matched.<span class="hljs-property">instances</span>[name] = vnode.<span class="hljs-property">componentInstance</span>;&#125;;<span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(component, data, children);&#125;,&#125;;</code></pre></div><h1 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h1><ol><li>在每个组件的<code>beforeCreate</code>和<code>destroyed</code>钩子中混入路由方法</li><li>依据<code>routes</code>中子路，递归生成<code>path/name</code>映射组件位置的映射表<code>RouteRecords</code></li><li>对实例的<code>_route</code>属性绑定响应式</li><li>根据选择的<code>mode</code>不同，生成不同的<code>history</code>模式，与地址栏绑定修改</li><li><code>&lt;router-view&gt;</code>组件的渲染函数会访问<code>_route</code>属性，订阅了路由状态的改变</li><li>地址栏或者<code>router-link</code>改变后修改了<code>_route</code></li><li><code>matcher</code>计算出从当前url到目标url的改变路径（<code>matched</code>record数组）</li><li>对比新旧的<code>[matched]</code>从第一个不同的位置解析出<code>activated``updated``deactivated</code>三个队列</li><li>按照路由钩子构造队列，分别对队列中的组件执行离开钩子，更新钩子和进入钩子，并且混入全局的钩子</li><li>通知订阅了的<code>router-view</code>组件重新渲染，<code>router-view</code>会计算自己组件在vue组件树中位置，去<code>matched</code>中找到该渲染的组件</li><li>最后更新路由的新状态</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
      <tag>vue-router</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks</title>
    <link href="/2022/03/02/react_hooks/"/>
    <url>/2022/03/02/react_hooks/</url>
    
    <content type="html"><![CDATA[<h1 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h1><h2 id="Why-Hooks"><a href="#Why-Hooks" class="headerlink" title="Why Hooks"></a>Why Hooks</h2><ul><li><p>Class 组件的复用不能直接继承，往往需要无页面逻辑的高阶组件；</p></li><li><p>Hooks 使函数式组件获得类组件能力，拥有自己的状态和响应式；</p></li><li><p>副作用代码不用分散到各种生命周期中；</p><blockquote><p>除了转为视图的代码都是副作用代码</p></blockquote></li></ul><h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><ol><li>Hooks 只能在组件顶层作用域使用</li><li><em>必须保证所有 Hooks 都能被执行到并且按顺序执行</em></li><li>Hooks 只能在函数和其他 Hook 中使用</li></ol><h2 id="常用-Hooks"><a href="#常用-Hooks" class="headerlink" title="常用 Hooks"></a>常用 Hooks</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a><code>useState</code></h3><p>定义状态和改变状态的函数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> [currentValue,setNewValue] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(initState)<span class="hljs-comment">// 改变状态</span><span class="hljs-title function_">setNewValue</span>(newValue)<span class="hljs-title function_">setNewValue</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;...newValue&#125;)<span class="hljs-comment">//  如果initState只需要在组件mount时执行一次，可以设置惰性返回值</span><span class="hljs-keyword">const</span> [state1, setState1] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">const</span> initialState = <span class="hljs-title function_">someExpensiveComputation</span>(props);  <span class="hljs-keyword">return</span> initialState;&#125;);</code></pre></div><p><code>setState</code>的同步和异步</p><ol><li>合成事件和生命周期中的<code>setState</code>是异步的</li><li>原生事件和<code>setTimeout</code>中的<code>setState</code>是同步的</li><li>使用<code>setState</code>的<code>callback</code>总能拿到最新的值</li><li>setState自带批处理优化，多次调用只会执行最新的一次</li></ol><blockquote><p>合成事件</p><p>React对原生DOM事件都做了代理，且事件都是绑定到app根节点上，<br>通过事件冒泡时的 <code>srcElement</code>查找到目标节点上的事件标识，再去合成事件库中寻找相应的回调。</p></blockquote><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a><code>useContext</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title function_">createContext</span>()&lt;<span class="hljs-title class_">Mycontext</span>.<span class="hljs-property">Provider</span> value=&#123;<span class="hljs-number">666</span>&#125;&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span></span>  &lt;/<span class="hljs-title class_">Mycontext</span>.<span class="hljs-property">Provider</span>&gt;<span class="hljs-comment">//...MyContext</span><span class="hljs-keyword">const</span> &#123;value&#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>)</code></pre></div><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a><code>useEffect</code></h3><p>定义副作用</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 副作用操作</span><span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 在组件销毁和effect重新执行之前执行</span>&#125;;&#125;, [stateValue]); <span class="hljs-comment">// 为[]则相当于didMount</span><span class="hljs-title function_">useEffect</span>(fn); <span class="hljs-comment">//  组建每次渲染都执行</span><span class="hljs-title function_">useEffect</span>(fn, []); <span class="hljs-comment">//  Mount时执行</span><span class="hljs-title function_">useEffect</span>(fn, [dep]); <span class="hljs-comment">//  Mount 和 dep 变化时</span><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;&#125;;&#125;, []); <span class="hljs-comment">//  unMount执行</span><span class="hljs-comment">// useEffect中使用异步函数</span><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;(<span class="hljs-title function_">async</span>()=&gt;&#123;<span class="hljs-keyword">await</span> ...&#125;)()&#125;)<span class="hljs-title function_">useEffect</span>(<span class="hljs-title function_">async</span>()=&gt;&#123;...&#125;)<span class="hljs-comment">// 报错！useEffect返回的是cleanup函数，加上async后回返回一个promise</span></code></pre></div><p><code>useEffect</code>和 <code>componentDidMount</code> 的区别</p><ol><li><code>useEffect</code>在<code>commit</code>执行完之后异步执行 fn 回调</li><li><code>componentDidMount</code>在<code>commit中的mutation</code>执行完时候和<code>layout</code>同步执行</li><li><code>useLayoutEffect</code>能实现和<code>👆</code>一样的效果</li></ol><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a><code>useCallback</code></h3><p>缓存函数实例</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleIncrement</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>)<span class="hljs-comment">// 默认每次重新渲染组件，都会创建新的handleElement函数</span><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleIncrement&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="hljs-comment">// ⚠️同时由于创建了新函数，会导致接收函数的组件也重新渲染</span><span class="hljs-keyword">const</span> handleIncrement = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>),[count])<span class="hljs-comment">// 将count加入这个callback的依赖数组，只有当count改变时才创建新的函数，创建新的闭包并更新组件</span>&#125;</code></pre></div><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a><code>useMemo</code></h3><p>缓存计算结果</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果某个数据是通过其它数据计算得到的，那么只有当用到的数据，也就是依赖的数据发生变化的时候，才应该需要重新计算,进而也可以避免不必要的渲染</span><span class="hljs-keyword">const</span> usersToShow = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(!users) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-keyword">return</span> users.<span class="hljs-property">data</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> user.<span class="hljs-property">first_name</span>.<span class="hljs-title function_">includes</span>(searchKey)  &#125;)&#125;,[users，searchKey])<span class="hljs-comment">// 脑补Vue的computed就懂了</span></code></pre></div><blockquote><p>useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps)</p></blockquote><blockquote><p>useCallback 和 useMemo 的 dep 数组传空则只返回首次执行结果</p></blockquote><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a><code>useRef</code></h3><p>保存的数据发生变化不会处罚重新渲染</p><ol><li>存储跨组建的数据<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> timer = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<span class="hljs-comment">//  一个存活在活动组件中的定时器</span><span class="hljs-keyword">const</span> startTimer = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;timer.<span class="hljs-property">current</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*do some*/</span>&#125;);&#125;, []);<span class="hljs-keyword">const</span> stopTimer = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">cleatInterval</span>(timer.<span class="hljs-property">current</span>);timer.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;&#125;, []);</code></pre></div></li><li>存储DOM引用<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xxxRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;xxxRef&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span>;</code></pre></div></li></ol><h3 id="useContext-1"><a href="#useContext-1" class="headerlink" title="useContext"></a><code>useContext</code></h3><p>使用 provide 的 context</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> text1 = &#123;  <span class="hljs-attr">p1</span>:<span class="hljs-string">&#x27;请输入&#x27;</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">SomeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(text1)&lt;<span class="hljs-title class_">SomeContext</span>.<span class="hljs-property">Provider</span> value=&#123;text1&#125;&gt;      <span class="hljs-comment">// 内部的组件就可以通过</span>      <span class="hljs-keyword">const</span> xxx = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">SomeContext</span>)      <span class="hljs-comment">// 来使用xxx数据</span>      &lt;input placeholder=&#123;xxx.<span class="hljs-property">p1</span>&#125;&gt;&lt;/<span class="hljs-title class_">SomeContext</span>&gt;</code></pre></div><h3 id="路由Hooks"><a href="#路由Hooks" class="headerlink" title="路由Hooks"></a>路由Hooks</h3><ul><li><code>useHistory</code></li><li><code>useLocation</code></li><li><code>useRouteMatch</code></li><li><code>useParams</code></li></ul><h2 id="校验-Hooks"><a href="#校验-Hooks" class="headerlink" title="校验 Hooks"></a>校验 Hooks</h2><p>通过 eslint 插件<code>eslint-plugin-react-hooks</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<span class="hljs-comment">//eslint config</span>...<span class="hljs-string">&quot;rules&quot;</span>:&#123;  <span class="hljs-string">&quot;react-hooks/rules-of-hooks&quot;</span>:<span class="hljs-string">&quot;error&quot;</span>,  <span class="hljs-comment">//检查依赖项的声明</span>  <span class="hljs-string">&quot;react-hooks/exhaustive-deps&quot;</span>:<span class="hljs-string">&quot;warn&quot;</span>  &#125;...&#125;</code></pre></div><h2 id="自定义-Hooks"><a href="#自定义-Hooks" class="headerlink" title="自定义 Hooks"></a>自定义 Hooks</h2><blockquote><p> 命名约定以<code>use</code>开头；</p></blockquote><blockquote><p> 在函数内使用到了其他 Hooks</p></blockquote><ul><li>  获取异步请求结果</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useAsyncReq</span> = (<span class="hljs-params">reqFunc</span>) =&gt; &#123;<span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<span class="hljs-keyword">const</span> [isLoading, setLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);<span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<span class="hljs-keyword">const</span> execute = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 在mount和reqFunc变化都会开始一次新请求</span><span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">true</span>);<span class="hljs-title function_">setData</span>(<span class="hljs-literal">null</span>);<span class="hljs-title function_">setError</span>(<span class="hljs-literal">null</span>);<span class="hljs-keyword">return</span> <span class="hljs-title function_">reqFunc</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<span class="hljs-title function_">setData</span>(res);&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<span class="hljs-title function_">setError</span>(err);&#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-title function_">setLoading</span>(<span class="hljs-literal">false</span>);&#125;);      &#125;, [reqFunc]);<span class="hljs-keyword">export</span> &#123; execute, isLoading, data, error &#125;;&#125;;</code></pre></div><ul><li><p>监听页面滚动</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getPosition</span> = (<span class="hljs-params"></span>)  =&gt; &#123;  <span class="hljs-attr">x</span>:<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollLeft</span>,  <span class="hljs-attr">y</span>:<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>&#125;<span class="hljs-keyword">const</span> <span class="hljs-title function_">useScroll</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-keyword">const</span> [position,setPosition] = <span class="hljs-title function_">useState</span>(<span class="hljs-title function_">getPosition</span>())  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;    <span class="hljs-comment">// mount时执行一次</span>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handler</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">setPosition</span>(<span class="hljs-title function_">getPosition</span>())    <span class="hljs-comment">// 添加监听scroll</span>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>,handler)    <span class="hljs-comment">// 组件销毁时取消监听</span>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>,handler)  &#125;,[])  <span class="hljs-keyword">return</span> position&#125;</code></pre></div></li><li><p>input hook</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useInput</span> = (<span class="hljs-params">initValue</span>) =&gt; &#123;<span class="hljs-keyword">const</span> [value,setValue] = <span class="hljs-title function_">useState</span>(initValue) <span class="hljs-keyword">return</span> &#123;value,<span class="hljs-attr">onChange</span>:<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span><span class="hljs-title function_">setValue</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>)&#125;&#125;<span class="hljs-keyword">const</span> nameInput = <span class="hljs-title function_">useInput</span>(<span class="hljs-string">&#x27;&#x27;</span>)&lt;input &#123;...nameInput&#125; placeholder=<span class="hljs-string">&quot;please input username&quot;</span>&gt;&lt;/input&gt;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2022/02/24/HTTP/"/>
    <url>/2022/02/24/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP（HyperText-Transfer-Protocol，超文本传输协议"><a href="#HTTP（HyperText-Transfer-Protocol，超文本传输协议" class="headerlink" title="HTTP（HyperText Transfer Protocol，超文本传输协议"></a>HTTP（HyperText Transfer Protocol，超文本传输协议</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议，用于客户端和服务器之间的通信</p><blockquote><p>链路层，网络层，传输层，应用层</p></blockquote><h2 id="HTTP-报文组成部分"><a href="#HTTP-报文组成部分" class="headerlink" title="HTTP 报文组成部分"></a>HTTP 报文组成部分</h2><ul><li><p>请求报文</p><ul><li>  请求行 <code>Request Method</code>,<code>Request URL</code></li><li>  请求头 包含若干属性，key:value 值</li><li>  空行</li><li>  请求体</li></ul></li><li><p>响应报文</p><ul><li>  状态行 <code>Request Version</code>,<code>Status Code</code></li><li>  响应头 包含若干属性，key:value 值</li><li>  空行</li><li>  响应体</li></ul></li></ul><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ul><li><p>缓存相关</p><ul><li>  <code>Cache-Control</code></li><li>  <code>Pragma</code></li><li>  <code>Expires</code>实体首部</li><li>  <code>Last-Modified</code>实体首部</li><li>  <code>If-Modified-Since</code></li><li>  <code>ETag</code></li><li>  <code>If-None-Match</code></li></ul></li><li><p>Cookie 相关</p><ul><li>  <code>Cookie</code></li><li>  <code>Set-Cookie</code></li></ul></li><li><p>跨域相关</p><ul><li>  <code>Origin</code></li><li>  <code>Access-Control-Request-Method</code></li><li>  <code>Access-Control-Allow-Origin</code></li><li>  <code>Access-Control-Allow-Methods</code></li><li>  <code>Access-Control-Max-Age</code></li><li>  <code>Access-Control-Allow-Credentials</code></li></ul></li><li><p>请求来源</p><ul><li>  <code>Connection</code>:keep-alive / close / upgrade</li><li>  <code>Referer</code>请求来源域</li><li><code>Origin</code>请求来源域<blockquote><p>这个单词是错的</p></blockquote></li><li>  <code>Host</code>服务器域名</li><li>  <code>Upgrade</code>:websocket</li></ul></li></ul><h2 id="HTTP-的响应状态码"><a href="#HTTP-的响应状态码" class="headerlink" title="HTTP 的响应状态码"></a>HTTP 的响应状态码</h2><blockquote><p>消息</p></blockquote><ul><li>  100 继续发送</li><li>  101 协议升级<blockquote><p>请求成功</p></blockquote></li><li>  200 OK</li><li>  206 处理了部分请求<blockquote><p>重定向</p></blockquote></li><li>  301 永久性重定向，资源已经分配了新的 URl</li><li>  302 临时重定向</li><li>303 表示资源存在着另一个 URL，应使用 GET 方法获取资源<blockquote><p>对于 301/302/303 响应，几乎所有浏览器都会删除报文主体并自动用 GET 重新请求</p></blockquote></li><li>  304 资源未修改<blockquote><p>请求错误</p></blockquote></li><li>  400 Bad Request 请求报文语法错误</li><li>  401 Unauthorized 需要认证</li><li>  403 Forbidden 禁止访问</li><li>  404 Not Found</li><li>  405 请求方法非法</li><li>  408 请求超时<blockquote><p>服务器错误</p></blockquote></li><li>  500 服务器错误</li><li>  503 服务器过载</li><li>  505 不支持该版本 HTTP 协议</li></ul><h2 id="HTTP-发展历程"><a href="#HTTP-发展历程" class="headerlink" title="HTTP 发展历程"></a>HTTP 发展历程</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><ul><li>  <code>GET</code></li><li>  只能且直接返回 html</li></ul><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul><li><p>  串行连接：每次通信完后断开 TCP 通道，每个新请求都需要建立新的连接</p></li><li><p><code>GET</code></p><ol><li>请求放在参数放在 URL 地址后</li><li>刷新无副作用</li><li>能保存书签，会被浏览器缓存，加入历史记录</li><li>编码 urlencoded</li><li>浏览器或者服务器会对 URL 长度做限制</li></ol></li><li><p><code>POST</code></p><ol><li>请求参数放在 body 中</li><li>刷新提示再次提交？</li><li>不缓存不保存不记录</li><li>数据类型无限制</li></ol></li><li><p>  <code>HEAD</code> 与 get 相同的请求，不过只请求头部，获取其中“关于该资源的信息”(元信息或称元数据)</p></li></ul><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul><li><p>  持久连接：一定时间内，只要不是主动断开则保持连接（keep-alive 设定这个时长），但是下一个请求必须等待上一个请求响应完成（线头阻塞）</p></li><li><p>  管线化持久连接：在同一条长连接上发出连续的请求，而不用等待应答返回,只能用于<code>GET</code>,<code>HEAD</code>,<code>PUT</code>,<code>DELETE</code>请求</p></li><li><p>  <code>OPTIONS</code>询问获取当前资源所支持的方法</p></li><li><p>  <code>PUT</code>从客户端向服务器传送新文件</p></li><li><p>  <code>PATCH</code>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p></li><li><p>  <code>DELETE</code>请求服务器删除指定文件</p></li><li><p>  <code>TRACE</code>回显服务器收到的请求，主要用于测试或诊断。</p></li><li><p>  <code>CONNECT</code> HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p></li></ul><h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><ul><li>  2009 年推出，试验性</li><li>  位于 HTTP 与 SSl 之间，是对 HTTP 的增强</li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>多路复用：通过一个 TCP 连接，可以无限制处理多个 HTTP 请求。</p></li><li><p>赋予请求优先级：给请求逐个分配优先级顺序。可以解决在发送多个请求时，因带宽低而导致响应变慢的问题。</p></li><li><p>压缩 HTTP 头部：压缩方式：DELEFT</p></li><li><p>服务端推送</p></li><li><p>SPDY 位于 HTTP 下，TCP 和 SSL 之上，可以兼容老版本 http 同时使用可用的 ssl 功能</p></li><li><p>SPDY 强制使用 SSL</p></li></ol><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><ul><li><p>  2015 年发布，基于 SPDY 协议</p></li><li><p>  http/1.x 是一个超文本协议，而 http2 是一个二进制协议</p></li></ul><blockquote><p>特性：</p></blockquote><ol><li><p>二进制分帧</p><p> 当客户端同时向服务端发起多个请求，那么这些请求会被分解成一一个的帧，每个帧都会在一个 TCP 链路中无序的传输，当帧到达服务端之后，就可以根据 <code>Stream Identifier</code> 来重新组合得到完整的请求。</p></li><li><p>头部压缩</p><ul><li>请求和响应首部压缩</li><li><code>HPACK</code> 算法，客户端和服务器建立字典（首部表）重复头部不用再发送</li></ul></li><li><p>服务端推送<code>Server Push</code></p><ul><li>服务端能主动返回多的觉得客户端会用到的资源</li></ul></li><li><p>多路复用</p><ul><li>同域名的通信都在单个连接上完成(只占用一个 tcp 连接</li><li>单连接可以承受任意数量的双向数据流</li></ul></li></ol><h3 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h3><ul><li>  http3 使用新的 UDP 协议<code>QUIC</code>代替 TCP</li><li>  解决 http2 时代丢包阻塞</li><li>  切换网络时的连接保持（快速重启会话）</li><li>  加密传输</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="TLS-SSl"><a href="#TLS-SSl" class="headerlink" title="TLS/SSl"></a>TLS/SSl</h3><ul><li><p>  传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p></li><li><p>  TLS 协议的特点是与应用层协议（HTTP，FTP）无耦合，应用层协议能透明运行在 TLS 协议上层（HTTP 与 TCP 之间）</p></li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>【非对称加密】</p><p>  只有使用私钥才能解开公钥加密</p></li><li><p>【摘要算法】</p><p>  输出固定长度的数据，用来计算数据指纹，比如 SHA256</p></li><li><p>【数字签名】<br>  使用私钥对摘要算法得出的指纹加密</p></li></ul><h3 id="SSL-证书"><a href="#SSL-证书" class="headerlink" title="SSL 证书"></a>SSL 证书</h3><ul><li>  证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号，摘要算法等信息的明文</li><li>  CA 使用 CA 私钥对证书明文摘要算法后得出的指纹进行加密得到签名</li></ul><h3 id="浏览器验证证书合法性"><a href="#浏览器验证证书合法性" class="headerlink" title="浏览器验证证书合法性"></a>浏览器验证证书合法性</h3><ol><li>从操作系统中找到相应的<code>CA机构证书</code></li><li>使用<code>CA证书</code>的公钥<code>解密``站点证书</code>的<code>签名</code>得到校验码 1</li><li>使用证书制定的摘要算法对<code>站点证书</code>明文计算得到校验码 2</li><li>比较两个校验码相同则说明证书没被篡改</li><li>后面就开始查看证书是否在有效期，是否对应当前域名，是否在吊销列表中等</li></ol><h3 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h3><ol><li>用户访问:443,发送客户端支持的加密算法列表和随机数<code>Random_C</code></li><li>服务器根据支持的贾母算法计算并返回证书和随机数<code>Random_S</code></li><li>用户浏览器使用 <strong><em>CA 公钥</em></strong> 打开并验证证书的合法性得到证书中的 <strong><em>服务器公钥</em></strong></li><li>用户生成生新的随机数<code>Premaster secret</code>，并使用 <strong><em>服务器公钥</em></strong> 加密发送给服务器</li><li>服务器使用自己的 <strong><em>服务器私钥</em></strong> 解密，得到 <code>Premaster secret</code></li><li>此后双方使用同样的加密算法对三个随机数进行计算得到对称的密钥<code>enc_key</code></li><li>至此双方得到了对称加密密钥,之后的连接都只使用对称加密</li></ol><h2 id="TCP-握手"><a href="#TCP-握手" class="headerlink" title="TCP 握手"></a>TCP 握手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol><li>为了确保通信双方收发能力正常</li><li>指定自己的初始化序列号，为后面的可靠传送做准备</li><li>过程：<ul><li>第一次握手：<br>客户端给服务端发一个 <code>SYN</code> 报文，并指明客户端的初始化序列号 <code>ISN(c)</code>。此时客户端处于 <code>SYN_Send</code> 状态。</li><li>第二次握手：<br>服务器收到客户端的 <code>SYN</code> 报文之后，会以自己的 <code>SYN</code> 报文作为应答，并且也是指定了自己的初始化序列号 <code>ISN(s)</code>，同时会把客户端的 <code>ISN(c) + 1</code> 作为 <code>ACK(确认字符)</code> 的值，表示自己已经收到了客户端的 <code>SYN</code>，此时服务器处于 <code>SYN_REVD</code> 的状态。</li><li>第三次握手：<br>客户端收到 <code>SYN</code> 报文之后，会发送一个 <code>ACK</code> 报文，当然，也是一样把服务器的 <code>ISN(s) + 1</code> 作为 <code>ACK</code> 的值，表示已经收到了服务端的 <code>SYN</code> 报文，此时客户端处于 <code>establised</code> 状态。<blockquote><p>同时该 tcp 栈已经允许请求数据，例如可以同时带上一个 GET 请求</p></blockquote></li><li>服务器收到 ACK 报文之后，也处于 <code>establised</code> 状态，此时，双方以建立起了链接。</li></ul></li></ol><blockquote><p><code>半连接队列</code>：在 TCP 协议三次握手的连接过程中，如果一个用户向服务器发送了 SYN 报文，服务器又发出 SYN+ACK 应答报文后未收到客户端的 ACK 报文回应，这种情况下服务器端会再次发送 SYN+ACK 给客户端，并等待一段时间后丢弃这个未完成的连接，这段时间的长度称为 SYN Timeout，一般来说这个时间是分钟级。</p></blockquote><blockquote><p><code>泛洪攻击</code>：SYN 泛洪攻击通过发送大量的伪造 TCP 连接报文而造成大量的 TCP 半连接,服务器端将为了维护这样一个庞大的半连接列表而消耗非常多的资源。这样服务器端将忙于处理攻击者伪造的 TCP 连接请求而无法处理正常连接请求,甚至会导致堆栈的溢出崩溃。</p></blockquote><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ol><li>断开 tcp 连接</li><li>过程：<ul><li>第一次挥手：<br>客户端发送<code>FIN</code> 报文，报文中会指定一个序列号<code>SYN(c)</code>。此时客户端处于 <code>FIN_WAIT1</code> 状态。</li><li>第二次握手：<br>服务端收到 <code>FIN</code> 之后，会把客户端的序列号值<code>SYN(c) + 1</code> 作为 <code>ACK</code> 报文的序列号值并发送给客户端，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code>状态。</li><li>第三次挥手：<br>如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <code>FIN</code> 报文，且指定一个序列号<code>SYN(s)</code>。此时服务端处于 <code>LAST_ACK</code> 的状态。</li><li>第四次挥手：<br>客户端收到 FIN 之后，也把服务端的序列号值<code>SYN(s) + 1</code> 作为自己 <code>ACK</code> 报文的序列号值并发送给服务端,此时客户端处于 <code>TIME_WAIT</code> 状态。之后才会进入 <code>CLOSED</code> 状态</li><li>服务端收到 <code>ACK</code> 报文之后，就处于关闭连接了，处于 <code>CLOSED</code> 状态。</li></ul></li></ol><blockquote><p><code>TIME_WAIT</code> 状态:客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭,确保服务器是否已经收到了 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p></blockquote><blockquote><p>也可缩短为三次挥手，上述二三步骤合并，服务器同时回复 ACK 和 FIN</p></blockquote><h2 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h2><ul><li>  websocket 的出现解决了传统 http 请求只能由客户端发起的缺陷</li><li>  http 无法得知服务器连续的状态变化，只能靠轮询</li><li>  ws 构造函数就要传入<code>绝对URL</code>，且连接不能转发只能是直接连接</li><li>  全双工，双向通信</li><li>  服务端推送</li><li>  持久连接</li><li>  基于 TCP 传输，复用 HTTP 的握手通道</li><li>协议升级为 ws<ol><li>客户端请求<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Connection</span>: <span class="hljs-title class_">Upgrade</span>;<span class="hljs-title class_">Upgrade</span>: websocket;</code></pre></div></li><li>服务端响应协议升级<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">101</span> <span class="hljs-title class_">Switching</span> <span class="hljs-title class_">Protocols</span></code></pre></div></li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现符合A+规范的Promise</title>
    <link href="/2022/02/24/Promise/"/>
    <url>/2022/02/24/Promise/</url>
    
    <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 对象用于处理异步操作，它表示一个尚未完成且预计在未来完成的异步操作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>  解决回调地狱，使用统一的 API 接口处理异步任务</li><li>  链式调用</li><li>  返回值穿透（onFulfilled 不是 function 时，上一步的执行结果 value 将继续向后传递）</li><li>  错误冒泡（</li></ul><blockquote><p>回调地狱</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-comment">//f2的执行需要等待f1的结果</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>)&#123;     <span class="hljs-title function_">f3</span>(<span class="hljs-params"></span>)&#123;      <span class="hljs-title function_">f4</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-title function_">f5</span>(<span class="hljs-params"></span>)&#123;          ...        &#125;        ...      &#125;    &#125;  &#125;&#125;</code></pre></div><h2 id="Promise-对象有以下两个特点"><a href="#Promise-对象有以下两个特点" class="headerlink" title="Promise 对象有以下两个特点"></a>Promise 对象有以下两个特点</h2><ol><li><p>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><ul><li>  为 Promise 实例添加状态改变时的回调函数</li><li>  then 方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数</li><li>  then 方法返回的是一个新的 Promise 实例,可以 then 方法后面再调用另一个 then 方法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">getJSON</span>(<span class="hljs-string">&quot;/post/1.json&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">post</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">getJSON</span>(post.<span class="hljs-property">commentURL</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">funcA</span>(<span class="hljs-params">comments</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;resolved: &quot;</span>, comments);&#125;,<span class="hljs-keyword">function</span> <span class="hljs-title function_">funcB</span>(<span class="hljs-params">err</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;rejected: &quot;</span>, err);&#125;);<span class="hljs-comment">// 第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。</span></code></pre></div><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><ul><li><p>  指定发生错误时的回调函数</p></li><li><p>  Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。</span><span class="hljs-comment">// bad</span>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<span class="hljs-comment">// success</span>&#125;,<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<span class="hljs-comment">// error</span>&#125;);<span class="hljs-comment">// good</span>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<span class="hljs-comment">//cb</span><span class="hljs-comment">// success</span>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<span class="hljs-comment">// error</span>&#125;);</code></pre></div><blockquote><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应</p></blockquote><ul><li>  catch 方法返回的还是一个 Promise 对象，因此后面还可以接着调用 then 方法</li></ul><h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h3><ul><li><p>  finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作</p></li><li><p>  finally 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是 fulfilled 还是 rejected。这表明，finally 方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p></li></ul><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><ul><li>  Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</li></ul><p><code>const p = Promise.all([p1, p2, p3]);</code></p><ul><li>  p 的状态由 p1、p2、p3 决定，分成两种情况。</li></ul><ol><li><p>只有 p1、p2、p3 的状态都变成<code>fulfilled</code>，p 的状态才会变成<code>fulfilled</code>，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p></li><li><p>只要 p1、p2、p3 之中有一个被<code>rejected</code>，p 的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给 p 的回调函数</p></li></ol><blockquote><p>如果作为参数的 Promise 实例，自己定义了 catch 方法，那么它一旦被 rejected，并不会触发 Promise.all()的 catch 方法</p></blockquote><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p><code>const p = Promise.race([p1, p2, p3]);</code></p><p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的回调函数。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//example</span><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/resource-that-may-take-a-while&quot;</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;request timeout&quot;</span>)), <span class="hljs-number">5000</span>);&#125;), <span class="hljs-comment">// 5s内请求不resolve则抛出错误</span>]);p.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);</code></pre></div><h3 id="promise-try"><a href="#promise-try" class="headerlink" title="promise.try()"></a>promise.try()</h3><p>不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;  database.<span class="hljs-property">users</span>.<span class="hljs-title function_">get</span>(&#123;<span class="hljs-attr">id</span>: userId&#125;)  .<span class="hljs-title function_">then</span>(...)  .<span class="hljs-title function_">catch</span>(...) <span class="hljs-comment">// promise错误</span>&#125; <span class="hljs-keyword">catch</span> (e) &#123; <span class="hljs-comment">// 同步错误</span>  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-comment">// try catch捕获同步错误</span><span class="hljs-comment">// 用promise.try改写</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">try</span>(<span class="hljs-function">() =&gt;</span> database.<span class="hljs-property">users</span>.<span class="hljs-title function_">get</span>(&#123;<span class="hljs-attr">id</span>: userId&#125;))  .<span class="hljs-title function_">then</span>(...)  .<span class="hljs-title function_">catch</span>(...)</code></pre></div><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>  立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行</li></ul><blockquote><p>Promise.resolve()方法允许调用时不带参数，直接返回一个 resolved 状态的 Promise 对象。</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;three&quot;</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;two&quot;</span>);&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;one&quot;</span>);<span class="hljs-comment">// one</span><span class="hljs-comment">// two</span><span class="hljs-comment">// three</span></code></pre></div><ul><li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为 reject 的理由，变成后续方法的参数</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> thenable = &#123;<span class="hljs-title function_">then</span>(<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;出错了&quot;</span>);&#125;,&#125;;<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(thenable).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);&#125;);<span class="hljs-comment">// catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。</span></code></pre></div></li></ul><h2 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h2><ul><li>  测试 a+规范</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">promises-aplus-testsnode promises-aplus-tests yourpeomise.<span class="hljs-property">js</span><span class="hljs-comment">// yourpromise.js</span><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">defer</span> = <span class="hljs-title class_">MyPromise</span>.<span class="hljs-property">deferred</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">let</span> dfd = &#123;&#125;;dfd.<span class="hljs-property">promise</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;dfd.<span class="hljs-property">resolve</span> = resolve;dfd.<span class="hljs-property">reject</span> = reject;&#125;);<span class="hljs-keyword">return</span> dfd;&#125;;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">MyPromise</span></code></pre></div><ul><li>  resolvePromise</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isComplex</span> = (<span class="hljs-params">obj</span>) =&gt; obj !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;function&quot;</span> || <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>);<span class="hljs-comment">// 判断then之后的状态</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolvePromise</span>(<span class="hljs-params">x, promise2, resolve, reject</span>) &#123;<span class="hljs-keyword">if</span> (x === promise2) &#123;<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Chaining cycle detected for promise&quot;</span>));&#125;<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isComplex</span>(x)) &#123;<span class="hljs-keyword">let</span> hasRes = <span class="hljs-literal">false</span>;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">const</span> then = x.<span class="hljs-property">then</span>;<span class="hljs-comment">// 如果x是promise，继续判断</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>) &#123;then.<span class="hljs-title function_">call</span>(x,<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (hasRes) <span class="hljs-keyword">return</span>;hasRes = <span class="hljs-literal">true</span>;<span class="hljs-title function_">resolvePromise</span>(v, promise2, resolve, reject);&#125;,<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (hasRes) <span class="hljs-keyword">return</span>;hasRes = <span class="hljs-literal">true</span>;<span class="hljs-title function_">reject</span>(r);&#125;);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果x是个对象</span><span class="hljs-title function_">resolve</span>(x);&#125;&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-keyword">if</span> (hasRes) <span class="hljs-keyword">return</span>;hasRes = <span class="hljs-literal">true</span>;<span class="hljs-title function_">reject</span>(e);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-title function_">resolve</span>(x);&#125;&#125;<span class="hljs-comment">// 通用常量</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-variable constant_">PENDING</span>);<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-variable constant_">FULFILLED</span>);<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-variable constant_">REJECTED</span>);</code></pre></div><ul><li>  function 版</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyPromise</span>(<span class="hljs-params">executor</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-literal">undefined</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCb</span> = [];<span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCd</span> = [];<span class="hljs-keyword">const</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 放在下个宏任务等promise2都执行得出状态</span><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = value;<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCb</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>());&#125;&#125;);&#125;;<span class="hljs-keyword">const</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">// 放在下个宏任务等promise2都执行得出状态</span><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = reason;<span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCd</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>());&#125;&#125;);&#125;;<span class="hljs-keyword">try</span> &#123;<span class="hljs-title function_">executor</span>(resolve, reject);&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-title function_">reject</span>(e);&#125;&#125;<span class="hljs-title class_">MyPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfill, onReject</span>) &#123;onFulfill = <span class="hljs-keyword">typeof</span> onFulfill === <span class="hljs-string">&quot;function&quot;</span> ? onFulfill : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value;onReject =<span class="hljs-keyword">typeof</span> onReject === <span class="hljs-string">&quot;function&quot;</span>? onReject: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<span class="hljs-keyword">throw</span> err;  &#125;;<span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<span class="hljs-comment">// push进去的时候promise2还没有执行完</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">onFulfilledCb</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfill</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);<span class="hljs-title function_">resolvePromise</span>(x, promise2, resolve, reject);&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-title function_">reject</span>(e);&#125;&#125;);<span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCd</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onReject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>);<span class="hljs-title function_">resolvePromise</span>(x, promise2, resolve, reject);&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-title function_">reject</span>(e);&#125;&#125;);<span class="hljs-comment">// 由于new Promise构造函数逻辑</span><span class="hljs-comment">// 可以简写</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<span class="hljs-comment">// 如果返回一个promise，依然需要判断他后续的状态,交给下一个then时去判断👆的代码</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onFulfill</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>)); <span class="hljs-comment">// setTimeout(()=&gt;&#123;</span><span class="hljs-comment">// try&#123;</span><span class="hljs-comment">// let x = onFulfill(this.data)</span><span class="hljs-comment">// resolvePromise(x,promise2,resolve,reject)</span><span class="hljs-comment">// &#125;catch(e)&#123;</span><span class="hljs-comment">// reject(e)</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// &#125;)</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onReject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>)); &#125;&#125;);<span class="hljs-keyword">return</span> promise2;&#125;;</code></pre></div><ul><li>  class 版</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPromise</span> &#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">executor</span>) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-title function_">executor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">resolve</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reject</span>);&#125; <span class="hljs-keyword">catch</span> (e) &#123;<span class="hljs-variable language_">this</span>, <span class="hljs-title function_">reject</span>(e);&#125;&#125;status = <span class="hljs-variable constant_">PENDING</span>;data = <span class="hljs-literal">undefined</span>;successCallback = [];failCallback = [];resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">resolve</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">reject</span>);&#125;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = value;<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">successCallback</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>());&#125;&#125;);&#125;;reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = reason;<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">failCallback</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>());&#125;&#125;);&#125;;<span class="hljs-title function_">then</span>(<span class="hljs-params">onResolve, onReject</span>) &#123;onResolve = <span class="hljs-keyword">typeof</span> onResolve === <span class="hljs-string">&quot;function&quot;</span> ? onResolve : <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val;onReject =<span class="hljs-keyword">typeof</span> onReject === <span class="hljs-string">&quot;function&quot;</span>? onReject: <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<span class="hljs-keyword">throw</span> err;  &#125;;<span class="hljs-keyword">const</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPromise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">successCallback</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onResolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>)<span class="hljs-title function_">resolvePromise</span>(x,promise2,resolve,reject)&#125;<span class="hljs-keyword">catch</span>(e)&#123;<span class="hljs-title function_">reject</span>(e)&#125;&#125;)<span class="hljs-variable language_">this</span>.<span class="hljs-property">failCallback</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">const</span> x = <span class="hljs-title function_">onReject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>)<span class="hljs-title function_">resolvePromise</span>(x,promise2,resolve,reject)&#125;<span class="hljs-keyword">catch</span>(e)&#123;<span class="hljs-title function_">reject</span>(e)&#125;&#125;)&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>)&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">onResolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>))&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>)&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">onReject</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>))&#125;&#125;)<span class="hljs-keyword">return</span> promise2&#125;&#125;</code></pre></div><ul><li>  API</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">resolve</span> = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(value));<span class="hljs-title class_">Promise</span>.<span class="hljs-property">reject</span> = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> <span class="hljs-title function_">reject</span>(reason));<span class="hljs-comment">// catch</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-function">(<span class="hljs-params">onReject</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">null</span>, onReject);&#125;;<span class="hljs-comment">// finally</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> value);&#125;,<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-keyword">throw</span> reason;&#125;);&#125;);&#125;;<span class="hljs-comment">// race</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) &#123;<span class="hljs-comment">// 抛出第一个改变的状态</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;pArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pItem</span>) =&gt;</span> pItem.<span class="hljs-title function_">then</span>(resolve, reject));&#125;);&#125;;<span class="hljs-comment">// any</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">any</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) &#123;<span class="hljs-comment">// 有resolve就resolve</span><span class="hljs-comment">// 都没有resolve则返回一个由所有err组成的AggregateError对象</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!pArr.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>([]));<span class="hljs-keyword">const</span> res = [];pArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pItem, index</span>) =&gt;</span> &#123;pItem.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;<span class="hljs-title function_">resolve</span>(v);&#125;,<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;res[index] = e;&#125;);&#125;);<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AggregateError</span>(res));&#125;);&#125;;<span class="hljs-comment">// all</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) &#123;<span class="hljs-comment">// resolve全部value</span><span class="hljs-comment">// 有err就reject</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!pArr.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>([]);<span class="hljs-keyword">const</span> res = [];pArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pItem, index</span>) =&gt;</span> &#123;pItem.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;res[index] = v;&#125;,<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<span class="hljs-title function_">reject</span>(e);&#125;);&#125;);<span class="hljs-title function_">resolve</span>(res);&#125;);&#125;;<span class="hljs-comment">// allSettled</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property">allSettled</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">pArr</span>) &#123;<span class="hljs-comment">// 记录每个promise的状态</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (!pArr.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>([]);<span class="hljs-keyword">const</span> res = [];pArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pItem, index</span>) =&gt;</span> &#123;<span class="hljs-comment">// if (pItem instanceof Promise) &#123;</span>pItem.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> &#123;res[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;resolve&quot;</span>, <span class="hljs-attr">value</span>: v &#125;;&#125;,<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;res[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;reject&quot;</span>, <span class="hljs-attr">reason</span>: e &#125;;&#125;);<span class="hljs-comment">// &#125; else &#123;</span><span class="hljs-comment">//   res[index] = &#123; status: &quot;resolve&quot;, value: pItem &#125;;</span><span class="hljs-comment">// &#125;</span>&#125;);<span class="hljs-title function_">resolve</span>(res);&#125;);&#125;;</code></pre></div><h2 id="同步函数-promise-化"><a href="#同步函数-promise-化" class="headerlink" title="同步函数 promise 化"></a>同步函数 promise 化</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">promisify</span> =(<span class="hljs-params">func</span>) =&gt;<span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;args.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err, value</span>) &#123;<span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err);<span class="hljs-keyword">else</span> <span class="hljs-title function_">resolve</span>(value);&#125;);func.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);&#125;);</code></pre></div><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-comment">// ...</span>&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-comment">// ...</span><span class="hljs-title function_">resolve</span>(p1);&#125;);<span class="hljs-comment">//p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;fail&quot;</span>)), <span class="hljs-number">3000</span>);&#125;);<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(p1), <span class="hljs-number">1000</span>);&#125;);p2.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error));<span class="hljs-comment">// Error: fail</span><span class="hljs-comment">// 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>es6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios和fetch</title>
    <link href="/2022/02/24/axios%E5%92%8Cfetch/"/>
    <url>/2022/02/24/axios%E5%92%8Cfetch/</url>
    
    <content type="html"><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><blockquote><p>基于XHR的Promise封装</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>PromiseAPI</li><li>客户端防止<code>CSRF</code></li><li>提供并发请求的接口</li><li>从node创建http请求</li><li>拦截器</li><li>取消请求abort</li></ol><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ul><li><p>添加拦截器</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    &lt;!-- 加入参数 --&gt;    config.<span class="hljs-property">params</span> = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">666</span>&#125;    <span class="hljs-keyword">return</span> config  &#125;,  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(err)  &#125;);</code></pre></div></li><li><p>执行顺序</p><ul><li>请求拦截器 后面的拦截器先执行</li><li>响应拦截器 前面的拦截器先执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request1&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;err1&#x27;</span>)&#125;)axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span>=&gt;</span>&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;request2&#x27;</span>)&#125;,<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;err2&#x27;</span>)&#125;)axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response1&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resErr1&#x27;</span>)&#125;)axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response2&#x27;</span>)&#125;，err=&gt;&#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resErr2&#x27;</span>)&#125;)&lt;!-- <span class="hljs-variable language_">console</span> --&gt;request2request1response1response2</code></pre></div></li></ul><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CancelToken</span> = axios.<span class="hljs-property">CancelToken</span>;<span class="hljs-keyword">let</span> cancel = <span class="hljs-literal">null</span>btn.<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">if</span>(cancel !== <span class="hljs-literal">null</span>) <span class="hljs-title function_">cancel</span>()  &lt;!-- 执行取消函数 --&gt;  <span class="hljs-title function_">axios</span>(&#123;    <span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;GET&#x27;</span>,    <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://xxxxxxx&#x27;</span>,    &lt;!--  --&gt;    cancelToken : <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancelToken</span>(<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span>&#123;      cancel = c      &lt;!-- cancelToken --&gt;    &#125;)  &#125;)&#125;.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;  cancel = <span class="hljs-literal">null</span>&#125;)</code></pre></div><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><blockquote><p>原生api</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>只针对网络请求报错(请求不能完成)</li><li>携带cookie要添加配置</li><li>不支持取消请求abort</li><li>无法检测请求进度</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS面试题</title>
    <link href="/2022/02/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/02/24/css%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ul><li><p><code>*</code>【0】</p></li><li><p>类选择器<code>class</code>【10】</p></li><li><p><code>id</code>选择器【100】</p></li><li><p>标签选择器<code>tag</code>【1】</p></li><li><p>组合</p>  <div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>&#123;<span class="hljs-selector-tag">a</span> or <span class="hljs-selector-tag">b</span>&#125; <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span>&#123;<span class="hljs-selector-tag">b</span>是<span class="hljs-selector-tag">a</span>的后代节点&#125;<span class="hljs-selector-tag">a</span>+<span class="hljs-selector-tag">b</span>&#123;<span class="hljs-selector-tag">b</span>是<span class="hljs-selector-tag">a</span>的兄弟下一个节点&#125;<span class="hljs-selector-tag">a</span>&gt;<span class="hljs-selector-tag">b</span>&#123;<span class="hljs-selector-tag">b</span>是<span class="hljs-selector-tag">a</span>的直接子节点&#125;<span class="hljs-selector-tag">a</span>~<span class="hljs-selector-tag">b</span>&#123;<span class="hljs-selector-tag">b</span>是<span class="hljs-selector-tag">a</span>之后的任意兄弟节点&#125;</code></pre></div></li><li><p>属性选择器，子串值选择器</p>  <div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[key]</span> // 有属性key<span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[key=val]</span> // 属性key值为val<span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[key~=val]</span> // key的值包含val<span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[key|=val]</span>  // key的值<span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[key^=val]</span> // key的值以val开头<span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[key$=val]</span>// key的值以val结尾<span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[key*=val]</span>// key的值包含val</code></pre></div></li><li><p>伪类</p><p>  期望元素在特定情况下呈现不同样式，如鼠标滑过<code>hover</code>，选中<code>checked</code>，激活状态<code>active</code>等。伪类开头为单冒号<code>:</code>。</p></li><li><p>伪元素</p><p>  伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的HTML元素一样，而不是向现有的元素上应用类，常见的像<code>after``before</code>。伪元素开头为双冒号<code>::</code>。</p></li></ul><h2 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h2><ul><li>  边框属性<code>border-radius</code>，<code>box-shadow</code>，<code>border-image</code></li><li>  背景控制<code>background-size,background-origin</code></li><li>  文字效果和自动换行<code>text-shadow,word-wrap</code></li><li>  自定义字体<code>@font-face</code></li><li>  2d/3d 变换，过渡和动画<code>transition``animation</code></li><li>  CSS 多列布局<code>CSS Multi-column Layout</code></li><li>  盒模型属性<code>box-sizing</code></li><li>  弹性盒子<code>flex</code></li><li>  更强大的多媒体查询</li></ul><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><p>我们假定用户正面向（浏览器）视窗或网页，而 HTML 元素沿着其相对于用户的一条虚构的 z 轴排开，层叠上下文就是对这些 HTML 元素的一个三维构想。</p><p>文档中的层叠上下文由满足以下任意一个条件的元素形成：</p><ul><li>根元素<code>&lt;html&gt;</code>；</li><li><code>position</code> 值为 <code>absolute</code>（绝对定位）或  <code>relative</code>（相对定位）且 <code>z-index</code> 值不为 <code>auto</code> 的元素；</li><li><code>position</code> 值为 <code>fixed</code>（固定定位）或 <code>sticky</code>（粘滞定位）的元素</li><li><code>flex</code> 容器的子元素，且 <code>z-index</code> 值不为 <code>auto</code>；</li><li><code>grid</code> 容器的子元素，且 <code>z-index</code> 值不为 <code>auto</code>；</li><li><code>opacity</code> 属性值小于1；</li><li>以下任意属性值不为 none 的元素：<ul><li><code>transform</code></li><li><code>filter</code></li><li><code>perspective</code></li><li><code>clip-path</code><ul><li><code>mask / mask-image / mask-border</code></li><li><code>isolation</code> 属性值为 <code>isolate</code> 的元素；</li><li><code>-webkit-overflow-scrolling</code> 属性值为 <code>touch</code> 的元素；</li><li><code>will-change</code> 值设定了任一属性</li></ul></li></ul></li></ul><blockquote><p>层叠水平不能跨级别比较，只能在同一上下文中才有意义</p></blockquote><blockquote><p>没有创建层叠上下文的元素其层叠水平又父级层叠上下文决定</p></blockquote><h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ul><li><p>IE</p><ul><li>双边距<ul><li>  <code>display:inline</code></li></ul></li><li>默认高度<code>16px</code><ul><li>  <code>font-size:0</code></li><li>  <code>overflow:hidden</code></li></ul></li><li>超链接内 img 会有边框<ul><li>  <code>border:0</code></li></ul></li></ul></li><li><p>3px bug</p><ul><li>  <code>display:block</code></li><li>  <code>vertical-align:top</code></li></ul></li></ul><h2 id="position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样"><a href="#position-跟-display、margin-collapse、overflow、float-这些特性相互叠加后会怎样" class="headerlink" title="position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样"></a>position 跟 display、margin collapse、overflow、float 这些特性相互叠加后会怎样</h2><ul><li>  如果元素的 display 为 none，那么元素不被渲染，position，float 不起作用；</li><li>  如果元素拥有 position:absolute;或 position:fixed;属性，那么元素将为绝对定位，float 不起作用。</li><li>  如果元素 float 属性不是 none，元素会脱离文档流，根据 float 属性值来显示。</li><li>  有浮动、绝对定位，inline-block 属性的元素，margin 不会和垂直方向上的其他元素 margin 折叠。</li></ul><h2 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h2><ul><li>  不同边 border 之间 45 度拼接</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">50px</span> red solid;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">50px</span> $(背景色) solid;  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> $(背景色) solid;&#125;</code></pre></div><h2 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h2><p><code>border-radius属性</code></p><ul><li>border-radius 是简写属性<ul><li>  border-top-left-radius</li><li>  border-top-right-radius</li><li>  border-bottom-right-radius</li><li>  border-bottom-left-radius</li><li>  top 左右，bottom 右左，顺时针顺序</li><li>  “/“ 用来分隔水平方向和垂直方向</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-comment">/* 绘制半椭圆 */</span><span class="hljs-selector-tag">div</span>&#123; <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">border-style</span>: solid; <span class="hljs-attribute">border-color</span>: <span class="hljs-number">#f00</span>; <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>/<span class="hljs-number">100%</span> <span class="hljs-number">100%</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>； <span class="hljs-comment">/* 水平方向上四个角的半径都为50% /  垂直方向 左右上半径为100%，左右下为0*/</span>&#125;</code></pre></div><h2 id="文本控制"><a href="#文本控制" class="headerlink" title="文本控制"></a>文本控制</h2><ul><li>  单行文本居中，多行文本左对齐</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">div</span>&#123;  <span class="hljs-attribute">text-align</span>:center&#125;<span class="hljs-selector-tag">p</span>&#123;  <span class="hljs-attribute">display</span>:inline-block;  <span class="hljs-attribute">text-align</span><span class="hljs-selector-pseudo">:left</span>&#125;</code></pre></div><ul><li>  多行文本省略号</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:after</span>&#123;  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;...&#x27;</span>&#125;</code></pre></div><ul><li>  单行文本溢出省略</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-attribute">overflow</span>: hidden；<span class="hljs-comment">/* （文字长度超出限定宽度，则隐藏超出的内容） */</span>white-space: nowrap；<span class="hljs-comment">/* （设置文字在一行显示，不能换行） */</span>text-overflow: ellipsis；<span class="hljs-comment">/* （规定当文本溢出时，显示省略符号来代表被修剪的文本） */</span></code></pre></div><ul><li>  多行文本溢出</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS">-webkit-line-clamp: <span class="hljs-number">2</span>；<span class="hljs-comment">/* （用来限制在一个块元素显示的文本的行数，2 表示最多显示 2 行。为了实现该效果，它需要组合其他的 WebKit 属性） */</span>display: -webkit-box；<span class="hljs-comment">/* （和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ） */</span>-webkit-box-orient: vertical；<span class="hljs-comment">/* （和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ） */</span>overflow: hidden；<span class="hljs-comment">/* （文本溢出限定的宽度就隐藏内容） */</span>text-overflow: ellipsis；<span class="hljs-comment">/* （多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本) */</span></code></pre></div><h2 id="dpr-1px-边框"><a href="#dpr-1px-边框" class="headerlink" title="dpr 1px 边框"></a>dpr 1px 边框</h2><ul><li>  伪元素配合媒体查询<code>transform:scale()</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-class">.onePx_border</span><span class="hljs-selector-pseudo">:after</span>&#123;    <span class="hljs-comment">/* 整个div边框 */</span>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#cccccc</span>;    <span class="hljs-comment">/* 注意宽高和圆角单位都要配合媒体查询 */</span>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">26px</span>;？？？    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>/<span class="hljs-number">200%</span>/<span class="hljs-number">333%</span>    height: <span class="hljs-number">100%</span>/<span class="hljs-number">200%</span>/<span class="hljs-number">333%</span>    <span class="hljs-comment">/* 单独一边的边框 */</span>    content: <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">background</span>: <span class="hljs-number">#cccccc</span>;    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;&#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>) &#123;  <span class="hljs-selector-class">.onePx_border</span><span class="hljs-selector-pseudo">:after</span> &#123;    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.5</span>);    -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;  &#125;<span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">3</span>) &#123;  <span class="hljs-selector-class">.onePx_border</span><span class="hljs-selector-pseudo">:after</span> &#123;    -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.3</span>);    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(<span class="hljs-number">0.3</span>);    -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;  &#125;&#125;</code></pre></div><ul><li><p>rem + viewport</p><ol><li>整体缩放 px 单位</li></ol>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;  (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// scale</span>    <span class="hljs-keyword">var</span> clientWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">screen</span>.<span class="hljs-property">width</span>;    <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span>;    <span class="hljs-keyword">var</span> vp = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;meta&#x27;</span>);    vp.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;viewport&#x27;</span>;    vp.<span class="hljs-property">content</span> = <span class="hljs-string">`initial-scale=<span class="hljs-subst">$&#123;<span class="hljs-number">1.0</span> * <span class="hljs-number">1</span> / dpr&#125;</span>, maximum-scale=<span class="hljs-subst">$&#123;<span class="hljs-number">1.0</span> * <span class="hljs-number">1</span> / dpr&#125;</span>, minimum-scale=<span class="hljs-subst">$&#123;<span class="hljs-number">1.0</span> * <span class="hljs-number">1</span> / dpr&#125;</span>, user-scalable=no, width=device-width`</span>;    <span class="hljs-keyword">var</span> m = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;meta&#x27;</span>)[<span class="hljs-number">0</span>];    m.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">insertBefore</span>(vp, m);    <span class="hljs-comment">// rem</span>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = ?  &#125;)();&lt;/script&gt;</code></pre></div><ol start="2"><li>其他元素使用 rem 单位</li></ol></li></ul><h2 id="垂直居中-div"><a href="#垂直居中-div" class="headerlink" title="垂直居中 div"></a>垂直居中 div</h2><ul><li>  绝对定位+上下左右 0+ margin:auto</li><li>  绝对定位+上50%左50%+负<code>margin</code>自身宽高一半</li><li>  绝对定位+上50%左50%+负<code>translate</code>自己宽高一半</li><li>  <code>flex</code>+<code>justify-content</code>+<code>align-items</code></li><li>  <code>table-cell</code>+<code>vertical-align:middle</code></li></ul><h2 id="三栏布局-左右固定中间自适应"><a href="#三栏布局-左右固定中间自适应" class="headerlink" title="三栏布局(左右固定中间自适应)"></a>三栏布局(左右固定中间自适应)</h2><ol><li><p>绝对定位</p></li><li><p>左右浮动【自适应元素要放在最后】</p> <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">* &#123;</span><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-tag">body</span> &#123;</span><span class="language-css"><span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css"><span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.column</span> &#123;</span><span class="language-css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css"><span class="hljs-attribute">float</span>: left;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css"><span class="hljs-attribute">float</span>: right;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-comment">/*左右浮动至左右并处于同一行</span></span><span class="hljs-comment"><span class="language-css">          *未浮动的center内容会被浮动元素环绕</span></span><span class="hljs-comment"><span class="language-css">          */</span></span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>全部左浮，-margin 移到上一行【自适应元素放在最前】</p> <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">* &#123;</span><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-tag">body</span> &#123;</span><span class="language-css"><span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><span class="language-css"><span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.column</span> &#123;</span><span class="language-css"><span class="hljs-attribute">position</span>: relative;</span><span class="language-css"><span class="hljs-comment">/**</span></span><span class="hljs-comment"><span class="language-css">        *设置定位，元素需要手动移动至padding空隙中</span></span><span class="hljs-comment"><span class="language-css">        */</span></span><span class="language-css"><span class="hljs-attribute">float</span>: left;</span><span class="language-css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css"><span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;</span><span class="language-css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css"><span class="hljs-attribute">left</span>: <span class="hljs-number">150px</span>;</span><span class="language-css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span><span class="language-css">&#125;</span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>全部左浮，center 元素需要撑开 center-wrapper【自适应元素放在最前】</p> <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">* &#123;</span><span class="language-css"><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-tag">body</span> &#123;</span><span class="language-css"><span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.container</span> &#123;</span><span class="language-css"><span class="hljs-attribute">overflow</span>: hidden;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.column</span> &#123;</span><span class="language-css"><span class="hljs-attribute">float</span>: left;</span><span class="language-css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.left</span> &#123;</span><span class="language-css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffbbff</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.center-wrapper</span> &#123;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.center</span> &#123;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><span class="language-css"><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">150px</span> <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#bfefff</span>;</span><span class="language-css"><span class="hljs-attribute">min-height</span>: <span class="hljs-number">100px</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-selector-class">.right</span> &#123;</span><span class="language-css"><span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;</span><span class="language-css"><span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;</span><span class="language-css"><span class="hljs-attribute">background</span>: <span class="hljs-number">#eeee00</span>;</span><span class="language-css">&#125;</span><span class="language-css"><span class="hljs-comment">/**</span></span><span class="hljs-comment"><span class="language-css">       *3，4方法类似</span></span><span class="hljs-comment"><span class="language-css">       * -100%的margin-left将元素移到上行最左</span></span><span class="hljs-comment"><span class="language-css">       * -自身宽度margin-left将元素移到上行最右</span></span><span class="hljs-comment"><span class="language-css">       * 并通过给center加padding</span></span><span class="hljs-comment"><span class="language-css">       */</span></span><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column center-wrapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column left&quot;</span>&gt;</span>left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column right&quot;</span>&gt;</span>right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>flex</p><p> <code>flex-grow</code>:1 自适应填充剩余空间</p></li><li><p>grid</p><p> <code>grid-template-column/row</code>中给自适应元素写 auto 大小</p></li><li><p>table<br> table 下的<code>table-cell</code>会自动自适应没写 width 的元素</p> <div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<span class="hljs-attribute">display</span>: table;<span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;&#125;<span class="hljs-selector-class">.wrapper</span> <span class="hljs-selector-tag">div</span> &#123;<span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<span class="hljs-attribute">display</span>: table-cell;&#125;<span class="hljs-selector-class">.main</span> &#123;<span class="hljs-attribute">background</span>: pink;&#125;<span class="hljs-selector-class">.left</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<span class="hljs-attribute">background</span>: red;&#125;<span class="hljs-selector-class">.right</span> &#123;<span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<span class="hljs-attribute">background</span>: yellow;&#125;</code></pre></div></li></ol><h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><ul><li>  物理像素:物理成像点</li><li>  css 像素:开发逻辑单位</li><li>  设备独立像素:设备屏幕呈现的像素量</li><li>  dpi 设备像素比:物理像素/设备独立像素(用多少个物理像素渲染一个设备独立像素)</li></ul><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><ul><li>使用rem<code>postcss-pxtorem</code> / 大屏设备显示过大</li><li>使用vw/vh<code>postcss-px-to-viewport</code> / 大屏设备显示过大</li><li>百分比单位</li><li>px 为主，搭配 vw/vh、媒体查询与 flex 进行布局</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>diff算法</title>
    <link href="/2022/02/24/diff%E7%AE%97%E6%B3%95/"/>
    <url>/2022/02/24/diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ul><li>diff算法，包含渲染器如何对各种类型的vNode的属性，text，fragment进行patch更新，以及判断是patch vNode，还是新增还是删除</li><li>采用同级比较</li></ul><h3 id="基础的diff"><a href="#基础的diff" class="headerlink" title="基础的diff"></a>基础的diff</h3><ul><li>新节点没有子节点-&gt;删除全部旧的子节点</li><li>新节点只有一个子节点-&gt;删除旧的并添加新的</li></ul><h3 id="核心diff"><a href="#核心diff" class="headerlink" title="核心diff"></a>核心diff</h3><ul><li>新旧节点都有多个子节点时，新旧子节点间的diff<div class="hljs code-wrapper"><pre><code class="hljs javascript">oldChildrenNode :[a,x,c,f]newChildrenNode :[a,c,f,r]</code></pre></div><h3 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h3></li><li>vNode中的唯一标识符</li><li>用于保存新旧vNode的映射关系</li><li>找到可复用的vNode</li><li>用移动节点达到更新目的⭐️</li></ul><h2 id="Vue2的双端比较"><a href="#Vue2的双端比较" class="headerlink" title="Vue2的双端比较"></a>Vue2的双端比较</h2><blockquote><p>借鉴<code>snabbdom.js</code></p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript">(oStart)               [oEnd] oldA   oldB   oldC    oldD newB   newC   newD    newA(nStart)               [nEnd]<span class="hljs-comment">// oStart与nEnd匹配上了key，将oldA的DOM移动到新dom最后</span>      (oStart)        [oEnd] oldA   oldB   oldC    oldD ｜  ----------------------&gt;                        ｜ newB   newC   newD    newA(nStart)      [nEnd]</code></pre></div><ul><li>vue同时从新旧children的两端开始比较</li><li>四个指针，分别查找是否key相同</li><li>匹配到了相同的key，则将真实dom移动,同时四个指针对撞移动</li><li>如果第一轮四次匹配不上，则遍历旧node寻找<code>nStart</code></li><li>if 找到将其真实DOM移动到<code>oStart</code>之前，并在原vnode位置置空undefined，后序比较会跳过他</li><li>else 找不到则添加新增新元素<code>nStart</code>到<code>oStart</code>之前</li><li>匹配结束后<code>oEnd&lt;oStart</code>,新增<code>nStart到nEnd</code>新元素到<code>oStart</code>之前</li><li>匹配结束后<code>nStart&gt;nEnd</code>,删除<code>oStart到oEnd</code>之间元素<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isUndef</span> (v) &#123;  <span class="hljs-keyword">return</span> v === <span class="hljs-literal">undefined</span> || v === <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">isDef</span> (v) &#123;  <span class="hljs-keyword">return</span> v !== <span class="hljs-literal">undefined</span> &amp;&amp; v !== <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sameVnode</span> (a, b) &#123;  <span class="hljs-keyword">return</span> (    a.<span class="hljs-property">key</span> === b.<span class="hljs-property">key</span> &amp;&amp; (      (        a.<span class="hljs-property">tag</span> === b.<span class="hljs-property">tag</span> &amp;&amp;        a.<span class="hljs-property">isComment</span> === b.<span class="hljs-property">isComment</span> &amp;&amp;        <span class="hljs-title function_">isDef</span>(a.<span class="hljs-property">data</span>) === <span class="hljs-title function_">isDef</span>(b.<span class="hljs-property">data</span>) &amp;&amp;        !<span class="hljs-title function_">childrenIgnored</span>(a) &amp;&amp; !<span class="hljs-title function_">childrenIgnored</span>(b) &amp;&amp;        <span class="hljs-title function_">sameInputType</span>(a, b)      ) || (        <span class="hljs-title function_">isTrue</span>(a.<span class="hljs-property">isAsyncPlaceholder</span>) &amp;&amp;        a.<span class="hljs-property">asyncFactory</span> === b.<span class="hljs-property">asyncFactory</span> &amp;&amp;        <span class="hljs-title function_">isUndef</span>(b.<span class="hljs-property">asyncFactory</span>.<span class="hljs-property">error</span>)      )    )  )&#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChildren</span> (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;    <span class="hljs-keyword">let</span> oldStartIdx = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> newStartIdx = <span class="hljs-number">0</span>    <span class="hljs-keyword">let</span> oldEndIdx = oldCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> oldStartVnode = oldCh[<span class="hljs-number">0</span>]    <span class="hljs-keyword">let</span> oldEndVnode = oldCh[oldEndIdx]    <span class="hljs-keyword">let</span> newEndIdx = newCh.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> newStartVnode = newCh[<span class="hljs-number">0</span>]    <span class="hljs-keyword">let</span> newEndVnode = newCh[newEndIdx]    <span class="hljs-keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm    <span class="hljs-keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldStartVnode)) &#123;        oldStartVnode = oldCh[++oldStartIdx] <span class="hljs-comment">// Vnode has been moved left</span>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldEndVnode)) &#123;        oldEndVnode = oldCh[--oldEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newStartVnode)) &#123;        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)        oldStartVnode = oldCh[++oldStartIdx]        newStartVnode = newCh[++newStartIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newEndVnode)) &#123;        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)        oldEndVnode = oldCh[--oldEndIdx]        newEndVnode = newCh[--newEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldStartVnode, newEndVnode)) &#123; <span class="hljs-comment">// Vnode moved right</span>      <span class="hljs-comment">// 说明oldStartVnode节点更新后要移动去末尾位置</span>        <span class="hljs-title function_">patchVnode</span>(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)        canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldStartVnode.<span class="hljs-property">elm</span>, nodeOps.<span class="hljs-title function_">nextSibling</span>(oldEndVnode.<span class="hljs-property">elm</span>))        oldStartVnode = oldCh[++oldStartIdx]        newEndVnode = newCh[--newEndIdx]      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(oldEndVnode, newStartVnode)) &#123; <span class="hljs-comment">// Vnode moved left</span>      <span class="hljs-comment">// 说明oldEndVnode节点更新后要移动到最前方</span>        <span class="hljs-title function_">patchVnode</span>(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)        canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, oldEndVnode.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)        oldEndVnode = oldCh[--oldEndIdx]        newStartVnode = newCh[++newStartIdx]      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(oldKeyToIdx)) oldKeyToIdx = <span class="hljs-title function_">createKeyToOldIdx</span>(oldCh, oldStartIdx, oldEndIdx)        <span class="hljs-comment">// oldKeyToIndex是旧节点的key2index映射map</span>        idxInOld = <span class="hljs-title function_">isDef</span>(newStartVnode.<span class="hljs-property">key</span>)          ? oldKeyToIdx[newStartVnode.<span class="hljs-property">key</span>]          : <span class="hljs-title function_">findIdxInOld</span>(newStartVnode, oldCh, oldStartIdx, oldEndIdx)          <span class="hljs-comment">// 去旧节点中寻找newStartVnode</span>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isUndef</span>(idxInOld)) &#123; <span class="hljs-comment">// 找不到则新增newStartVnode元素到oldStart之前</span>          <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>, <span class="hljs-literal">false</span>, newCh, newStartIdx)        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 找得到则进行移动</span>          vnodeToMove = oldCh[idxInOld]          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">sameVnode</span>(vnodeToMove, newStartVnode)) &#123;            <span class="hljs-title function_">patchVnode</span>(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)            oldCh[idxInOld] = <span class="hljs-literal">undefined</span>            <span class="hljs-comment">// 将旧节点中匹配到的位置置空，以后的查找会跳过</span>            canMove &amp;&amp; nodeOps.<span class="hljs-title function_">insertBefore</span>(parentElm, vnodeToMove.<span class="hljs-property">elm</span>, oldStartVnode.<span class="hljs-property">elm</span>)            <span class="hljs-comment">// 匹配到的节点移动到oldStart之前</span>          &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// key相同但不是同一种元素</span>            <span class="hljs-title function_">createElm</span>(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.<span class="hljs-property">elm</span>, <span class="hljs-literal">false</span>, newCh, newStartIdx)          &#125;        &#125;        newStartVnode = newCh[++newStartIdx]      &#125;    &#125;    <span class="hljs-comment">// 跳出匹配后</span>    <span class="hljs-keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;      refElm = <span class="hljs-title function_">isUndef</span>(newCh[newEndIdx + <span class="hljs-number">1</span>]) ? <span class="hljs-literal">null</span> : newCh[newEndIdx + <span class="hljs-number">1</span>].<span class="hljs-property">elm</span>      <span class="hljs-title function_">addVnodes</span>(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;      <span class="hljs-title function_">removeVnodes</span>(parentElm, oldCh, oldStartIdx, oldEndIdx)    &#125;  &#125;</code></pre></div><h2 id="React的最大递增索引值"><a href="#React的最大递增索引值" class="headerlink" title="React的最大递增索引值"></a>React的最大递增索引值</h2></li><li>由于react使用链表存储oldFiber节点，故新旧节点比较时不能使用双指针</li><li>需要两次便利<ol><li>第一次遍历更新的节点</li><li>第二次处理不属于更新的节点</li></ol></li></ul><h3 id="1-第一轮"><a href="#1-第一轮" class="headerlink" title="1. 第一轮"></a>1. 第一轮</h3><p>从第一个新节点和链表头开始<code>i = 0;i++</code>，比较DOM是否可以复用</p><ul><li>如果 <code>key</code> 不同，会导致DOM不可复用，跳出第一轮遍历</li><li>如果 <code>type</code> 不同，会导致DOM不可服用，将oldFiber节点标记为删除</li><li>如果遍历完新旧或者任意一个，跳出第一轮遍历  <code>i === newChildren.length - 1）或者oldFiber.sibling === null</code><h3 id="2-第二轮"><a href="#2-第二轮" class="headerlink" title="2. 第二轮"></a>2. 第二轮</h3><h4 id="newChildren和oldFiber同时遍历完"><a href="#newChildren和oldFiber同时遍历完" class="headerlink" title="newChildren和oldFiber同时遍历完"></a>newChildren和oldFiber同时遍历完</h4>只需要在为第一遍遍历时标记<code>更新</code><h4 id="oldFiber遍历完了"><a href="#oldFiber遍历完了" class="headerlink" title="oldFiber遍历完了"></a>oldFiber遍历完了</h4>旧DOM都复用了，新children余下的都是需要新<code>插入</code>的DOM</li></ul><h4 id="newChildren遍历完了"><a href="#newChildren遍历完了" class="headerlink" title="newChildren遍历完了"></a>newChildren遍历完了</h4><p>oldFiber余下的节点都需要标记为<code>删除</code></p><h4 id="⭐️都没遍历完，节点发生了移动"><a href="#⭐️都没遍历完，节点发生了移动" class="headerlink" title="⭐️都没遍历完，节点发生了移动"></a>⭐️都没遍历完，节点发生了移动</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">oldFiber    = key1 -&gt; key2 -&gt; key3newChildren = [key2,key3,key1]</code></pre></div><blockquote><p>K为在旧 children 中所遇到的最大索引值，后续匹配的索引小于这个值意味着都需要移动</p></blockquote><p>设置<code>oldIndex</code>为当前节点在oldFiber中的位置，<code>K</code>为在diff过程中访问到的最大index。</p><ol><li><code>K = 0</code></li><li><code>key2</code>在oldFiber中的索引是<code>1</code>,<code>oldIndex&gt;K</code>,不用移动,<code>K=Math.max(oldIndex,K) = 1</code></li><li><code>key3</code>在oldFiber中的索引是<code>2</code>,<code>oldIndex&gt;K</code>,不用移动,<code>K=Math.max(oldIndex,K) = 2</code></li><li><code>key1</code>在oldFiber中的索引是<code>0</code>,<code>oldIndex&lt;K</code>,需要移动,<code>K=2</code></li><li>比较完了，将<code>key2,key3</code>移动到<code>key1</code>后(考虑性能，节点后移)<h3 id="Vue3-借鉴inferno和ivi的算法"><a href="#Vue3-借鉴inferno和ivi的算法" class="headerlink" title="Vue3 借鉴inferno和ivi的算法"></a>Vue3 借鉴<code>inferno</code>和<code>ivi</code>的算法</h3></li></ol><ul><li><p>排除相同的首位节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[j]             [preEnd] |                  | a   e   f  k   b   c |                  |--------------------- |                  | a   f   k  e   b   c |                  |   [j]             [nextEnd]    [j] [preEnd]     |      | a   e   f  k   b   c     |      |---------------------     |      | a   f   k  e   b   c     |      |       [j] [nextEnd]</code></pre></div><ul><li>分别从新旧节点的头和尾出发</li><li>依次遍历到key值不一样时停止 </li><li>这样匹配成功后剩下的部分就是需要新增/删除的vNode们</li></ul></li><li><p>使用剩余新children的长度建立source索引数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">  oldChildren = [e,f,k]  newChildren = [f,k,e]  source = [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>]- 为新vnode建立key，index索引表  <span class="hljs-string">``</span><span class="hljs-string">`javascript</span><span class="hljs-string">  keyIndex = &#123;f:0,k:1,e:2&#125;</span></code></pre></div></li><li><p>遍历旧children中key去keyIndex中查找<code>k = keyIndex[oldChildren[i]]</code>，有这个k则把<code>source</code>数组该位置的-1改为旧vNode的索引，并且patch该节点 ;<code>k=undefined</code>则说明该节点已经被删除，而source中依旧为-1的节点为新增节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">source = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]</code></pre></div></li><li><p>判断是否需要移动</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">source = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<span class="hljs-comment">//source中，最大索引为2，2之后有小于2的索引，说明需要移动</span><span class="hljs-comment">//根据source数组求出最长递增子序列</span><span class="hljs-variable constant_">LIS</span> = [<span class="hljs-number">1</span>，<span class="hljs-number">2</span>]<span class="hljs-comment">// LIS中存储的是source索引</span><span class="hljs-comment">// 表示新旧children中这几个节点位置保持递增关系</span></code></pre></div></li><li><p>根据LIS得出不进行移动的节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">newChildren[<span class="hljs-variable constant_">LIS</span>] = [f,k]</code></pre></div></li><li><p>从LIS和新children尾处建立两个指针处理余下节点</p></li><li><p>比较指针的索引是是否相同，不同则移动DOM位置到上个指针的真实DOM之前</p><blockquote><p>oldVnode.el = 真实DOM，同时source.key = -1的节点直接创建了新的真实DOM</p></blockquote></li></ul><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><ul><li>子序列：不要求连续</li><li>字串：要求连续</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 动态规划</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">longestChildSequence</span> = arr =&gt; &#123;  <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> dp = <span class="hljs-title class_">Array</span>(len).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// dp[i]代表原始数组该位置的最长子序列长度</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i++)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; i ; j++)&#123;      <span class="hljs-comment">// j遍历之前遍历过的所有元素</span>      <span class="hljs-comment">// 可能存在大小不一的递增序列，使用max取得最大值</span>      <span class="hljs-keyword">if</span>(arr[i] &gt; arr [j])&#123;        dp[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>)        <span class="hljs-comment">// [1,2,3,4,1,2,5]</span>        <span class="hljs-comment">// 如果只使用dp[j]+1 ，dp[6]会在[1,2,5]中得出结果3</span>        <span class="hljs-comment">// 使用max比较之前更长的序列[1，2，3，4，5]得到5</span>      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...dp)&#125;<span class="hljs-comment">// 贪心+二分</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">longestChildSequence</span> = arr =&gt; &#123;  <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>  <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">const</span> res = [arr[<span class="hljs-number">0</span>]]  <span class="hljs-comment">//将arr中后续元素arr[i]与res末尾元素比较</span>  <span class="hljs-comment">//大于则push进res</span>  <span class="hljs-comment">//小于则查找res中第一个比arr[i]大的元素并替换</span>  <span class="hljs-comment">//由于存在替换，子序列值不一定正确，但长度是正确的</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt; len ;i++)&#123;    <span class="hljs-keyword">if</span>(arr[i]&gt;res[res.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>])&#123;      res.<span class="hljs-title function_">push</span>(arr[i])    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// res中左右指针的index</span>      <span class="hljs-comment">// 二分查找</span>      <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>      <span class="hljs-keyword">let</span> right = res.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>      <span class="hljs-keyword">while</span>(left&lt;right)&#123;        <span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left+right)/<span class="hljs-number">2</span>)        <span class="hljs-comment">// let mid = ((left+right)/2) | 0</span>        <span class="hljs-comment">// 浮点小数向下求整</span>        <span class="hljs-keyword">if</span>(arr[i]&gt;res[mid])&#123;          left = mid + <span class="hljs-number">1</span>        &#125;<span class="hljs-keyword">else</span>&#123;          right = mid        &#125;      &#125;      res[left] = arr[i]    &#125;  &#125;  <span class="hljs-keyword">return</span> res.<span class="hljs-property">length</span> &#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现自适应div高度为宽度一半</title>
    <link href="/2022/02/24/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/"/>
    <url>/2022/02/24/div%E9%AB%98%E5%BA%A6%E4%B8%BA%E9%AB%98%E5%BA%A6%E4%B8%80%E5%8D%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h2><ul><li><code>static</code><ul><li>正常流，默认值</li><li>top, right, bottom, left 和 z-index 属性无效。</li></ul></li><li><code>relative</code><ul><li>相对正常流偏移</li><li>原位置有预留空间</li></ul></li><li><code>absolute</code><ul><li>移出正常文档流</li><li>相对于最近的 非static 定位祖先元素偏移</li><li>不为元素预留空间</li></ul></li><li><code>fixed</code><ul><li>移出正常文档流</li><li>相对于屏幕视口（viewport）的位置来指定元素位置</li><li>不为元素预留空间<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p></blockquote></li></ul></li><li><code>sticky</code><ul><li>相对定位和固定定位的混合</li><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li><li>跨越特定阈值前为相对定位，之后为固定定位</li></ul></li></ul><h2 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h2><h3 id="包含块的作用"><a href="#包含块的作用" class="headerlink" title="包含块的作用"></a>包含块的作用</h3><p>  元素的尺寸及位置，常常会受它的包含块所影响。对于一些属性，例如 width,height,padding,margin，绝对定位元素的偏移值（比如 position 被置为 absolute 或 fixed），当我们对其赋予百分比值时，其参考值是包含块的尺寸。</p><h3 id="确定包含块"><a href="#确定包含块" class="headerlink" title="确定包含块"></a>确定包含块</h3><blockquote><p>一个元素的包含块并不一定父元素的内容区</p></blockquote><p>元素的包含块由其<code>position</code>决定：</p><ul><li><code>static 、 relative 或 sticky </code>，包含块可能由它的最近的祖先块元素（比如说inline-block, block 或 list-item元素）的内容区的边缘组成（<code>content</code>）</li><li><code>absolute</code> ，包含块就是由它的最近的 <code>position 的值不是 static</code> （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成（<code>content+padding</code>）</li><li><code>fixed</code>，在连续媒体的情况下(continuous media)包含块是 viewport ,在分页媒体(paged media)下的情况下包含块是分页区域(page area)。<blockquote><p>当元素祖先的 transform, perspective 或 filter 属性非 none 时,包含块是这个元素的内边距区 content+padding</p></blockquote></li></ul><h3 id="根据包含块计算"><a href="#根据包含块计算" class="headerlink" title="根据包含块计算"></a>根据包含块计算</h3><ul><li>要计算 <code>height</code> <code>top</code> 及 <code>bottom</code> 中的百分值，是通过包含块的 <code>height</code> 的值</li><li>要计算 <code>width</code>, <code>left</code>, <code>right</code>, <strong><code>padding</code>!, <code>margin</code></strong> 这些属性由包含块的 <code>width</code> 属性的值来计算它的百分值。</li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol><li><p>实现一个div垂直水平居中高度为宽度的一半自适应</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 外层wrapper */</span><span class="hljs-selector-class">.outer-wrapper</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100vh</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">display</span>:flex;  <span class="hljs-comment">/* flex默认行排列，所以这里设置侧轴对齐 */</span>  <span class="hljs-attribute">align-items</span>:center&#125;<span class="hljs-comment">/* 内层wrapper */</span><span class="hljs-selector-class">.inner-wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* padding,margin值的百分比是相较于父元素width */</span>&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-comment">/* 两个position设置都是为了确定包含块 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;  <span class="hljs-comment">/* 这里的高度就=&gt;inner-wrapper[height+padding]=&gt;outer-wrapper[width]*50% */</span>&#125;</code></pre></div></li><li><p>实现div正方形大小自适应</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span>&#123;  <span class="hljs-attribute">position</span>:relative;  <span class="hljs-attribute">padding-top</span>:<span class="hljs-number">50%</span>;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* 同样相较于包含块的尺寸百分比 */</span>  <span class="hljs-comment">/* width和padding都等于wrapper包含块的宽度的一半 */</span>&#125;<span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">position</span>:absolute;  <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;  <span class="hljs-comment">/* 偏移到wrapper位置 */</span>  <span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">100%</span>;&#125;<span class="hljs-comment">/* 也可使用伪元素撑开高度 */</span><span class="hljs-selector-class">.div</span>&#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">50%</span>;  <span class="hljs-comment">/* 触发BFC避免塌陷 */</span>  <span class="hljs-attribute">display</span>:flow-root&#125;<span class="hljs-selector-class">.div</span><span class="hljs-selector-pseudo">::after</span>&#123;  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">margin-top</span>:<span class="hljs-number">100%</span>;  <span class="hljs-attribute">display</span>:block&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6~now新特性</title>
    <link href="/2022/02/24/es6%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/02/24/es6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Javascript = Web Api + ECMAScript</p></blockquote><blockquote><p>ES2015 后都使用年份做版本</p></blockquote><h2 id="【let-const】"><a href="#【let-const】" class="headerlink" title="【let / const】"></a>【let / const】</h2><ul><li>都用于声明变量</li><li>不存在变量提升，暂时性死区</li><li>不能重复声明</li><li>块级作用域 <code>[]</code></li></ul><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>可以重新赋值<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3></li><li>声明时需赋值</li><li>只读不可改变（对于复杂变量，可以修改变量内容，变量内存地址未改变）</li></ul><h2 id="【解构赋值】"><a href="#【解构赋值】" class="headerlink" title="【解构赋值】"></a>【解构赋值】</h2><p>只有可遍历（具备遍历器<code>[Symbol.Iterator]</code>）的数据结构才能解构赋值</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li><p>交换变量</p></li><li><p>提取对象中的数据</p></li><li><p>解构默认值</p></li><li><p>剩余运算符<code>...</code></p></li><li><p>数组结构 <code>const [a,b,c] = [1,2,3]</code></p></li><li><p>对象结构 </p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xxx&#x27;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">14</span>&#125;<span class="hljs-keyword">const</span> &#123;name,age&#125; = obj<span class="hljs-comment">// 别名</span><span class="hljs-keyword">const</span> &#123;<span class="hljs-attr">name</span>:trueName&#125; = obj<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(trueName)</code></pre></div></li></ul><h2 id="【字符串】"><a href="#【字符串】" class="headerlink" title="【字符串】"></a>【字符串】</h2><ul><li>方法<ul><li><code>includes()</code></li><li><code>startsWith()</code></li><li><code>endsWith()</code> </li><li><code>padStart(len,x)</code>// 补全后的最小长度，不足则用x在开头填充</li><li><code>padEnd()</code>// 在末尾填充</li><li><code>repeat()</code>// 重复</li></ul></li><li>模版字符串<ul><li>多行</li><li>插值<code>$&#123;x&#125;</code></li></ul></li></ul><h2 id="【数值】"><a href="#【数值】" class="headerlink" title="【数值】"></a>【数值】</h2><blockquote><p>普通number类型只能保留53个二进制位/16个10进制位的精度</p></blockquote><ul><li>最大最小安全整数<code>Number.MAX_SAFE_INTEGER</code>,<code>Number.MAX_SAFE_INTEGER</code></li><li>识别<ul><li><code>Number.isSafeInteger()</code></li><li><code>Number.isFinite()</code></li></ul></li><li>大数<code>BigInt</code>类型，后要加上字母n<code>123n</code>，没有位数限制 </li><li>指数运算<code>**</code></li></ul><h2 id="【数组】"><a href="#【数组】" class="headerlink" title="【数组】"></a>【数组】</h2><ul><li>方法<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>() <span class="hljs-comment">// 从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</span><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>() <span class="hljs-comment">// Array()只传一个参数就作为新建的数组长度</span><span class="hljs-title function_">includes</span>()<span class="hljs-title function_">copyWithin</span>()<span class="hljs-title function_">fill</span>()<span class="hljs-title function_">find</span>() / <span class="hljs-title function_">findIndex</span>()<span class="hljs-title function_">keys</span>(),<span class="hljs-title function_">values</span>(),<span class="hljs-title function_">entries</span>()<span class="hljs-title function_">flat</span>()</code></pre></div></li><li>扩展运算符<code>...</code></li></ul><h2 id="【对象】"><a href="#【对象】" class="headerlink" title="【对象】"></a>【对象】</h2><ul><li>方法<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(a,b)<span class="hljs-comment">// 比较两个值是否严格相等，与（===）基本类似</span><span class="hljs-comment">// Object.is与全等的区别</span><span class="hljs-comment">//  Object.is(+0,-0);  //false</span><span class="hljs-comment">//  +0 === -0  //true</span><span class="hljs-comment">//  Object.is(NaN,NaN); //true</span><span class="hljs-comment">//  NaN === NaN  //false</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>() <span class="hljs-comment">// 潜拷贝</span></code></pre></div></li><li>扩展运算符<code>...</code></li></ul><h2 id="【函数】"><a href="#【函数】" class="headerlink" title="【函数】"></a>【函数】</h2><ul><li>箭头函数<ul><li>箭头函数没有自己的this,静态绑定书写时的上下文</li><li>箭头函数没有<code>prototype</code> —&gt; <strong>不能作为构造函数，不能 new</strong></li><li>箭头函数没有<code>arguments</code>属性</li><li>不能用作<code>generator</code>函数</li></ul></li><li>函数参数默认值<code>function fn1(arg1=&#39;xxx&#39;)&#123;&#125;</code></li><li>函数剩余参数<code>function(a, b, ...theArgs)</code></li></ul><h2 id="【Symbol】"><a href="#【Symbol】" class="headerlink" title="【Symbol】"></a>【Symbol】</h2><p>独一无二的值,<code>Symbol()</code>声明不需要new</p><ul><li><p>作为不变的常量</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">FLAG1</span> = <span class="hljs-title class_">Symbol</span>()<span class="hljs-keyword">const</span> <span class="hljs-title class_">FLAG2</span> = <span class="hljs-title class_">Symbol</span>()</code></pre></div></li><li><p>私有变量</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj1 = (<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-keyword">let</span> var1 = <span class="hljs-title function_">symbol</span>(<span class="hljs-string">&#x27;var1&#x27;</span>)  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;      <span class="hljs-variable language_">this</span>[var1] = <span class="hljs-string">&#x27;abcde&#x27;</span>    &#125;    <span class="hljs-title function_">getVar</span>(<span class="hljs-params"></span>)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[var1]    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Inner</span>&#125;)()<span class="hljs-keyword">const</span> o1 = <span class="hljs-title function_">obj1</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o1)<span class="hljs-comment">// &#123;Symbol(var1):&#x27;abcde&#x27;&#125;</span><span class="hljs-comment">// 不能直接访问</span></code></pre></div><h2 id="【Set-WeakSet】"><a href="#【Set-WeakSet】" class="headerlink" title="【Set/WeakSet】"></a>【Set/WeakSet】</h2></li><li><p>Set类似于数组，但是成员的值都是唯一的，拥有迭代器</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">size<span class="hljs-title function_">add</span>()<span class="hljs-title function_">delete</span>()<span class="hljs-title function_">has</span>()<span class="hljs-title function_">clear</span>()</code></pre></div></li><li><p>WeakSet的成员只能是对象，【弱引用】，【不可遍历】</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">add</span>()<span class="hljs-title function_">delete</span>()<span class="hljs-title function_">has</span>()</code></pre></div></li></ul><h2 id="【Map-WeakMap】"><a href="#【Map-WeakMap】" class="headerlink" title="【Map/WeakMap】"></a>【Map/WeakMap】</h2><ul><li>Object的键传统上只能使用字符串，Map无此限制，拥有迭代器<div class="hljs code-wrapper"><pre><code class="hljs javascript">size<span class="hljs-title function_">set</span>(key,value) <span class="hljs-comment">// 返回整个 Map 结构</span><span class="hljs-title function_">get</span>() <span class="hljs-comment">// 找不到该 key 返回 undefined</span><span class="hljs-title function_">has</span>()<span class="hljs-title function_">delete</span>() <span class="hljs-comment">// 删除失败返回 false</span><span class="hljs-title function_">clear</span>() <span class="hljs-comment">// 无返回值</span></code></pre></div></li><li>WeakMap只接受对象作为键名（除了null），【键名弱引用】<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">set</span>()<span class="hljs-title function_">get</span>()<span class="hljs-title function_">has</span>()<span class="hljs-title function_">delete</span>()</code></pre></div></li><li>map和object的区别<ol><li>键的变量类型限制</li><li>map原生具有遍历器</li><li>map遍历时保持插入时的顺序(object遍历时会对整数键名排序)</li><li>map.size()返回长度</li></ol></li></ul><h2 id="【Proxy】"><a href="#【Proxy】" class="headerlink" title="【Proxy】"></a>【Proxy】</h2><p>拦截器/代理 <code>const _proxy1 = new Proxy(target,handler)</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 常用handlers</span><span class="hljs-title function_">getPrototypeOf</span>()<span class="hljs-comment">// Object.getPrototypeOf 方法的捕捉器。</span><span class="hljs-title function_">setPrototypeOf</span>()<span class="hljs-comment">// Object.setPrototypeOf 方法的捕捉器。</span><span class="hljs-title function_">getOwnPropertyDescriptor</span>()<span class="hljs-comment">// Object.getOwnPropertyDescriptor 方法的捕捉器。</span><span class="hljs-title function_">defineProperty</span>()<span class="hljs-comment">// Object.defineProperty 方法的捕捉器。</span><span class="hljs-title function_">has</span>()<span class="hljs-comment">// in 操作符的捕捉器。</span><span class="hljs-title function_">get</span>()<span class="hljs-comment">// 属性读取操作的捕捉器。</span><span class="hljs-title function_">set</span>()<span class="hljs-comment">// 属性设置操作的捕捉器。</span><span class="hljs-title function_">deleteProperty</span>()<span class="hljs-comment">// delete 操作符的捕捉器。</span><span class="hljs-title function_">ownKeys</span>()<span class="hljs-comment">// Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</span><span class="hljs-title function_">apply</span>()<span class="hljs-comment">// 函数调用操作的捕捉器。</span><span class="hljs-title function_">construct</span>()<span class="hljs-comment">// new 操作符的捕捉器。</span></code></pre></div><h2 id="【Reflect】"><a href="#【Reflect】" class="headerlink" title="【Reflect】"></a>【Reflect】</h2><p>操作对象的API</p><ul><li>对象操作能返回布尔值</li><li>将对象操作函数化<blockquote><p>某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p></blockquote></li><li>与Proxy中方法均对应<h2 id="【Promise】"><a href="#【Promise】" class="headerlink" title="【Promise】"></a>【Promise】</h2></li><li>处理异步操作，避免回调嵌套</li><li>状态不可逆</li><li>中途不可停止</li><li>需要捕获promise内错误</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>((resolve,reject))<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">then</span>(onFulfilled,onRejected)<span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">catch</span>()<span class="hljs-comment">// promise中的错误会一直冒泡到最后，没有捕获则报错</span><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">finally</span>()<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>() <span class="hljs-comment">// 全部fulfilled或者有谁rejected</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>() <span class="hljs-comment">// 全部得到不管什么状态</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>() <span class="hljs-comment">// 最先改变status</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>() <span class="hljs-comment">// 最先fulfilled或者全部rejected</span><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>()<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">try</span>()</code></pre></div><h2 id="【Iterator迭代器】"><a href="#【Iterator迭代器】" class="headerlink" title="【Iterator迭代器】"></a>【Iterator迭代器】</h2><h3 id="Symbol-Iterator"><a href="#Symbol-Iterator" class="headerlink" title="[Symbol.Iterator]"></a>[Symbol.Iterator]</h3><ul><li>统一的遍历集合数据的借口</li><li>只要拥有<code>[Symbol.Iterator]</code>的数据结构都可以用for…of遍历</li></ul><h3 id="原生具备-Iterator-接口的数据结构如下。"><a href="#原生具备-Iterator-接口的数据结构如下。" class="headerlink" title="原生具备 Iterator 接口的数据结构如下。"></a>原生具备 Iterator 接口的数据结构如下。</h3><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments</li><li>Dom Node</li></ul><h2 id="【Generator】"><a href="#【Generator】" class="headerlink" title="【Generator】"></a>【Generator】</h2><ul><li>调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 <code>迭代器</code> （ iterator ）对象。</li><li>当这个迭代器的 <code>next()</code> 方法被调用时返回一个对象，<code>&#123;value:当前的返回,done:是否迭代完&#125;</code>，其内的语句会执行到下一个<code>yield</code>的位置，<code>yield</code> 后紧跟迭代器要返回的值。  </li><li>或者如果用的是 <code>yield*</code>，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</li><li>当在生成器函数中显式 <code>return</code> 时，会导致生成器立即变为完成状态，如果 <code>return</code> 后面跟了一个值，那么这个值会作为当前调用 <code>next()</code> 方法返回值。</li><li>调用 <code>next()</code>方法时，如果传入了参数，那么这个参数会传给上一条执行的 <code>yield</code>语句左边的变量，例如下面例子中的 x ：<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">yield</span> <span class="hljs-number">10</span>;    x=<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;foo&#x27;</span>;    <span class="hljs-keyword">yield</span> x;&#125;<span class="hljs-keyword">var</span> gen_obj=<span class="hljs-title function_">gen</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// 执行 yield 10，返回 10</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// 执行 yield &#x27;foo&#x27;，返回 &#x27;foo&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>(<span class="hljs-number">100</span>));<span class="hljs-comment">// 将 100 赋给上一条 yield &#x27;foo&#x27; 的左值，即执行 x=100，返回 100</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gen_obj.<span class="hljs-title function_">next</span>());<span class="hljs-comment">// 执行完毕，value 为 undefined，done 为 true</span></code></pre></div></li></ul><h2 id="【async-await】"><a href="#【async-await】" class="headerlink" title="【async/await】"></a>【async/await】</h2><p>自执行的Generator函数语法糖。</p><h2 id="【Class】"><a href="#【Class】" class="headerlink" title="【Class】"></a>【Class】</h2><ol><li><p>类表达式和类声明</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> A = <span class="hljs-keyword">class</span> &#123;&#125;<span class="hljs-comment">// or</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;</code></pre></div><blockquote><p>类声明和类表达式的主体都执行在严格模式下</p></blockquote></li><li><p>继承</p><p>本质使用的是原型式继承</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name  &#125;  <span class="hljs-title function_">fun1</span>(<span class="hljs-params"></span>)&#123;&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> extend B&#123;  <span class="hljs-title function_">constructor</span> (name)&#123;    <span class="hljs-variable language_">super</span>(name) <span class="hljs-comment">// 调用父类构造函数 // </span>  &#125;  <span class="hljs-title function_">fun2</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">fun1</span>() <span class="hljs-comment">// 调用一个父类方法</span>  &#125;&#125;</code></pre></div></li><li><p>静态字段，私有字段，私有实例字段</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span>&#123;  <span class="hljs-comment">//静态字段</span>  <span class="hljs-keyword">static</span> attr1 = <span class="hljs-number">123</span>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;im func1&#x27;</span>&#125;  <span class="hljs-comment">//只在类声明中存在，实例不能访问</span>  <span class="hljs-comment">// 公有字段</span>  attr2 = <span class="hljs-number">666</span>  <span class="hljs-title function_">func2</span>(<span class="hljs-params"></span>)&#123;&#125;  <span class="hljs-comment">// 每个实例都复制一份</span>  <span class="hljs-comment">//私有实例字段</span>  <span class="hljs-comment">//不能直接访问，闭包访问</span>  #attr3  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-variable language_">this</span>.#attr3 = name  &#125;  <span class="hljs-title function_">getPrivate</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#attr3  &#125;  #func3 = <span class="hljs-function">() =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;im private&#x27;</span>);  &#125;  <span class="hljs-title function_">getPrivateFunc</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">func3</span>()  &#125;&#125;</code></pre></div></li><li><p>getter / setter</p><p> 当使用 get 关键字时，属性将被定义在实例的原型上，当使用Object.defineProperty()时，属性将被定义在实例自身上。</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;  <span class="hljs-keyword">get</span> <span class="hljs-title function_">hello</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;world&#x27;</span>;  &#125;&#125;<span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">hello</span>);<span class="hljs-comment">// &quot;world&quot;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(obj, <span class="hljs-string">&#x27;hello&#x27;</span>));<span class="hljs-comment">// undefined</span></code></pre></div><h2 id="【模块化-ES-module】"><a href="#【模块化-ES-module】" class="headerlink" title="【模块化 ES module】"></a>【模块化 ES module】</h2></li><li><p>语法</p></li></ol><p><code>export / export</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是 Node 中向外暴露成员的形式：</span><span class="hljs-comment">// module.exports = &#123;&#125;</span><span class="hljs-comment">// ES6中导入模块，使用 import 模块名称 from &#x27;模块标识符&#x27; import &#x27;表示路径&#x27;</span><span class="hljs-comment">// 在 ES6 中，使用 export default 和 export 向外暴露成员：</span><span class="hljs-keyword">var</span> info = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;zs&quot;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> info;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;深圳&quot;</span>&#125;;<span class="hljs-comment">// 注意： export default 向外暴露的成员，可以使用任意的变量来接收</span><span class="hljs-comment">// 注意： 在一个模块中，export default 只允许向外暴露1次</span><span class="hljs-comment">// 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> title = <span class="hljs-string">&quot;小星星&quot;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> content = <span class="hljs-string">&quot;哈哈哈&quot;</span>;<span class="hljs-comment">// 注意： 使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式，叫做 【按需导出】</span><span class="hljs-comment">// 注意： export 可以向外暴露多个成员， 同时，如果某些成员，我们在 import 的时候，不需要，则可以不在 &#123;&#125; 中定义</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，必须严格按照 导出时候的名称，来使用 &#123;&#125; 按需接收；</span><span class="hljs-comment">// 注意： 使用 export 导出的成员，如果 就想 换个 名称来接收，可以使用 as 来起别名；</span><span class="hljs-comment">// 在Node中 使用 var 名称 = require(&#x27;模块标识符&#x27;)</span><span class="hljs-comment">// module.exports 和 exports 来暴露成员</span></code></pre></div><ol start="2"><li><p>使用 babel 编译 ES6 语法</p><p>Babel 是一个工具链，主要用于在旧的浏览器或环境中将 ECMAScript 2015+ 代码转换为向后兼容版本的 JavaScript 代码</p></li><li><p>模块化工具 webpack,rollup</p></li></ol><h2 id="装饰器语法"><a href="#装饰器语法" class="headerlink" title="装饰器语法"></a>装饰器语法</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">@demo<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&#123;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">target</span>)&#123;  target.<span class="hljs-property">value</span> = <span class="hljs-number">666</span>&#125;<span class="hljs-comment">// 等价于</span><span class="hljs-title class_">MyClass</span> = <span class="hljs-title function_">demo</span>(<span class="hljs-title class_">MyClass</span>)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2022/02/24/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2022/02/24/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>ref:<a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">阮一峰的网络日志</a></p><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul><li><p><code>flex-direction</code> 主轴的方向 </p><ul><li><code>row(默认住) | row-reverse</code> 横向排列</li><li><code>column | column-reverse</code>纵向排列</li></ul></li><li><p><code>flex-wrap</code> 换行</p><ul><li><code>nowrap</code>不换行</li><li><code>wrap</code>换行</li><li><code>wrap-reverse</code>逆序换行</li></ul></li><li><p><code>flex-flow</code>(上述两种的简写)</p></li><li><p><code>justify-content</code> 主轴上的对齐方式</p><ul><li><code>flex-start</code>（默认值）：左对齐 </li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li></ul></li><li><p><code>align-items</code> 侧轴上如何对齐 </p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li><li><code>flex-end</code>：交叉轴的终点对齐</li><li><code>center</code>：交叉轴的中点对齐</li><li><code>baseline</code>: 项目的第一行文字的基线对齐</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li></ul></li><li><p><code>align-content</code> 多根轴线的对齐方式</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐</li><li><code>flex-end</code>：与交叉轴的终点对齐</li><li><code>center</code>：与交叉轴的中点对齐</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴</li></ul></li></ul><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><ul><li><p><code>order</code></p><p>项目的排列顺序。数值越小，排列越靠前，默认为0</p></li><li><p><code>flex-grow</code></p><p>如果存在剩余空间，1放大，0不放大</p></li><li><p><code>flex-shrink</code></p><p>如果空间不足，1缩小，0不缩小</p></li><li><p><code>flex-basis</code></p><p>  基础大小</p></li><li><p><code>flex</code>是上述三种的简写</p><p><code>[flex-grow] [flex-shrink] [flex-basis]</code></p></li><li><p><code>align-self</code></p><p>采用与其他兄弟项目不一样的对齐方式,参考<code>[align-item]</code></p><h2 id="布局实例"><a href="#布局实例" class="headerlink" title="布局实例"></a>布局实例</h2></li></ul><ol><li><p>圣杯布局</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:burlywood&quot;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 按照顺序渲染，如果需提前修改元素order属性，越小越优先 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:chocolate&quot;</span>&gt;</span>nav<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:blueviolet&quot;</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">aside</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:cadetblue&quot;</span>&gt;</span>aside<span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:darkslateblue&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-comment">/* 垂直方向 */</span>  <span class="hljs-attribute">flex-direction</span>: column;&#125;<span class="hljs-selector-tag">header</span>,<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-comment">/* 6em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6em</span>;&#125;<span class="hljs-selector-class">.body</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">nav</span>,<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">aside</span>&#123;  <span class="hljs-comment">/* 10em 为本身的固定宽度 */</span>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10em</span>;&#125;<span class="hljs-selector-class">.body</span> <span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>&#125;</code></pre></div></li><li><p>固定的底栏</p><div class="hljs code-wrapper"><pre><code class="hljs css">*&#123;  <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">body</span>&#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-comment">/* 改变flex朝向 */</span>  <span class="hljs-attribute">flex-direction</span>:column;  <span class="hljs-comment">/* 占满视口高度 */</span> &lt;----------------  <span class="hljs-attribute">min-height</span>:<span class="hljs-number">100vh</span>;&#125;<span class="hljs-selector-tag">header</span>&#123;  <span class="hljs-attribute">height</span>:<span class="hljs-number">30px</span>;  <span class="hljs-attribute">background</span>: blue;&#125;<span class="hljs-selector-tag">main</span>&#123;  <span class="hljs-comment">/* 主题内容填满剩余空间 */</span>  <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>&#125;<span class="hljs-selector-tag">footer</span>&#123;  <span class="hljs-attribute">background</span>:black;&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML面试题</title>
    <link href="/2022/02/24/html%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/02/24/html%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h1><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><ul><li><p>纯表现的元素/可以用css实现的元素：<code>basefont</code>，<code>big</code>，<code>center</code>，<code>font</code>, <code>s</code>，<code>strike</code></p></li><li><p>对可用性产生负面影响的元素：<code>frame</code>,<code>frameset</code></p></li><li><p>语意化更好的标签，比如<code>header,nav,section,article,footer,aside</code></p></li><li><p>增强了<code>input</code>类型:<code>color</code>,<code>date</code>,<code>datetime-local</code>,<code>range</code>,<code>tel</code>,<code>search</code>,<code>url</code></p></li><li><p>新的表单元素:<code>datalist,progress,meter,output,keygen</code></p></li><li><p>表单校验(数据格式，数据范围，占位符，必填等)</p></li><li><p><code>canvas</code> API和内联 <code>svg</code></p></li><li><p><code>audio/video</code> 音视频元素</p></li><li><p><code>manifest</code>web应用离线缓存</p></li><li><p>地理定位<code>geolocation</code> API</p></li><li><p><code>webworker</code>将JS计算交给后台线程</p></li><li><p><code>websocket</code>全双工的支持服务端推送的持久化连接协议</p></li><li><p>webStorage：<code>localStorage sessionStorage</code></p></li><li><p><code>history</code>API</p></li></ul><h3 id="HTML5-哪些标签可以做-SEO"><a href="#HTML5-哪些标签可以做-SEO" class="headerlink" title="HTML5 哪些标签可以做 SEO"></a>HTML5 哪些标签可以做 SEO</h3><p><code>title、meta、header、footer、nav、article、aside</code></p><h1 id="meta元数据标签"><a href="#meta元数据标签" class="headerlink" title="meta元数据标签"></a>meta元数据标签</h1><ul><li><code>charset</code> 字符编码</li><li><code>keywords</code>关键词和爬虫</li><li><code>viewport</code> scale页面缩放</li><li><code>CSP</code>内容安全策略</li></ul><h1 id="HTML5-的离线存储"><a href="#HTML5-的离线存储" class="headerlink" title="HTML5 的离线存储"></a>HTML5 的离线存储</h1><p>在用户没有联网时，可以正常访问站点或应用；在联网的情况下，更新用户机器上的缓存文件。</p><ol><li>页面头部加入一个 manifest 的属性</li><li>在 cache.manifest 文件的编写离线存储的资源</li><li>在离线状态下，操作 window.applicationCache 进行需求实现</li></ol><h4 id="浏览器是如何对-HTML5-的离线存储资源进行管理和加载的"><a href="#浏览器是如何对-HTML5-的离线存储资源进行管理和加载的" class="headerlink" title="浏览器是如何对 HTML5 的离线存储资源进行管理和加载的"></a>浏览器是如何对 HTML5 的离线存储资源进行管理和加载的</h4><ul><li><p>在线的情况下，浏览器发现 HTML 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，浏览器会根据 manifest 文件的内容下载相应的资源并且进行离线存储。</p></li><li><p>如果已经访问过 app，并且资源已经离线存储，浏览器会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件，如果文件没有发生改变，就不做任何操作，否则就会重新下载文件中的资源并进行离线存储。</p></li><li><p>离线的情况下，浏览器直接使用离线存储的资源。</p></li></ul><h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>HTML 文档中的每个元素都使用一个矩形盒子来描述其占用空间，这个模型称为盒模型。盒模型包含四个区域：<code>margin</code>（外边距），<code>border</code>（边框），<code>padding</code>（内边距），<code>content</code>（内容区域）</p><blockquote><p>outline和box-shadow都会从margin box区域开始计算</p></blockquote><h2 id="标准模型和-IE-模型"><a href="#标准模型和-IE-模型" class="headerlink" title="标准模型和 IE 模型"></a>标准模型和 IE 模型</h2><ul><li>标准模型<code>box-sizing:content-box</code>,对其设置宽高只作用于<code>content box</code>区域</li><li>ie 模型<code>box-sizing:border-box</code>,对其设置宽高会作用于<code>content box</code>,<code>padding box</code>和 <code>border box</code>区域</li></ul><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p><code>display block</code></p><ol><li><p>独占一行</p></li><li><p>可以设置 width，height，margin，padding，border 属性</p></li><li><p>默认宽度是容器的 100%</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">article; <span class="hljs-comment">// h5</span>div;header; <span class="hljs-comment">// h5</span>section; <span class="hljs-comment">// h5</span>address; <span class="hljs-comment">// h5</span>ol;ul;aside; <span class="hljs-comment">// h5</span>footer; <span class="hljs-comment">// h5</span>audio; <span class="hljs-comment">// h5</span>video; <span class="hljs-comment">// h5</span>canvas; <span class="hljs-comment">// h5</span>hgroup; <span class="hljs-comment">// h5</span>p;h1 - h6;table;form;</code></pre></div><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><p><code>display inline</code></p><ol><li>行内排列</li><li>不能设置 <code>width</code>、<code>height</code>,默认高度和宽度就是内容的高度和宽度</li><li>可以设置 <code>margin-left/right</code>，无法设置 <code>margin-top\bottom</code></li><li><code>border</code> 和 <code>padding</code> 可以设置，但是 <code>border-top</code> 和 <code>padding-top</code> 到页面顶部后就不再增加</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">img; <span class="hljs-comment">//可以设置宽高</span>span;label;strong;a;input; <span class="hljs-comment">//可以设置宽高</span>select; <span class="hljs-comment">//可以设置宽高</span>textarea; <span class="hljs-comment">//可以设置宽高</span></code></pre></div><h2 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h2><p><code>display line-block</code></p><p>在行内排列的块级元素</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 兼容</span>div &#123;    display： inline-block；    zoom： <span class="hljs-number">1</span>；   <span class="hljs-comment">//在IE下触发hasLayout</span>    display：inline；<span class="hljs-comment">//一旦触发了hasLayout设置display：inline和display：block效果相似。</span>&#125;</code></pre></div><h1 id="DOM元素的尺寸和位置"><a href="#DOM元素的尺寸和位置" class="headerlink" title="DOM元素的尺寸和位置"></a>DOM元素的尺寸和位置</h1><ol><li><p><code>HTMLElement.style</code>【只能获取内联样式】</p></li><li><p><code>window.getComputedStyle(HTMLElement)</code>【获取包含所有样式属性的对象</p></li><li><p><code>HTMLElement.getBoundingClientRect()</code>【描绘元素为相对窗口的矩形盒子】</p></li><li><p><code>HTMLElement.offsetWidth/offsetHeight </code> 【content+padding+border+scrollbar】</p></li><li><p><code>HTMLElement.clientWidth/clientHeight</code> 【content+padding】</p></li><li><p><code>HTMLElement.scrollWidth/scrollHeight </code>// 【包含滚出可是区域部分的clientWidth/clientHeight】</p></li><li><p><code>HTMLElement.scrollTop</code>// 【从元素的左上角开始，滚动出元素的上半部分的 width/height】</p></li></ol><p>！滚动到底</p><blockquote><p>ele.scrollHeight - ele.scrollTop === ele.clientHeight</p></blockquote><p>！元素进入可视范围(懒加载)</p><blockquote><p>要加载元素的.offsetTop - 容器.scrollTop &lt;= document.documentElement.clientHeight</p></blockquote><blockquote><p>要加载元素getBoundingClientRect()后的top &lt;= document.documentElement.clientHeight<br>！js获取这些属性会触发重排</p></blockquote><h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><p>（Block Formatting Context） 块级格式化上下文,是一个对块级盒子的布局及浮动相互影响有特殊规则的区域</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><blockquote><p>一句话就是BFC内外不会互相影响。。。</p></blockquote><ul><li><p>BFC内盒子之间会发生外边距合并</p></li><li><p>BFC内浮动元素参与高度计算（高度塌陷）</p></li><li><p>BFC内盒子不会超出BFC边界（浮动覆盖）</p><h3 id="下列方式会创建BFC："><a href="#下列方式会创建BFC：" class="headerlink" title="下列方式会创建BFC："></a>下列方式会创建BFC：</h3><ul><li>根元素<code>HTML</code></li><li>浮动元素：<code>float</code> 不为 <code>none</code></li><li>绝对定位元素：<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code></li><li><code>overflow</code> 不为 <code>visible</code></li><li><code>display</code> 为 <code>flow-root</code></li><li>行内块元素<code>display</code> 为 <code>inline-block</code></li><li>弹性元素<code>display</code> 为 <code>flex</code> 或 <code>inline-flex</code> 元素的直接子元素</li><li>网格元素<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素</li><li>表格元素<code>display</code> 为 <code>table``table-cell</code>或<code>table-xxx</code>等匿名表格元素</li></ul></li></ul><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ul><li>用父元素伪类清除浮动</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-comment">/* 通用 */</span><span class="hljs-selector-class">.clearfather</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-attribute">clear</span>: both;  <span class="hljs-attribute">display</span>: block;  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">overflow</span>: hidden;&#125;<span class="hljs-selector-class">.clearfather</span> &#123;  *zoom: <span class="hljs-number">1</span>; <span class="hljs-comment">/* ie6/7 */</span>&#125;</code></pre></div><ul><li>空 div 清除浮动</li></ul><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-class">.clearfloat</span> &#123;  <span class="hljs-attribute">clear</span>: both;&#125;</code></pre></div><ul><li>父元素 BFC</li></ul><p>设置能触发 BFC 的属性均可</p><h1 id="超链接伪类顺序"><a href="#超链接伪类顺序" class="headerlink" title="超链接伪类顺序"></a>超链接伪类顺序</h1><p>被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性排列顺序: <code>L-V-H-A</code></p><div class="hljs code-wrapper"><pre><code class="hljs CSS"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;&#125;</code></pre></div><h1 id="优雅降级和渐进增强"><a href="#优雅降级和渐进增强" class="headerlink" title="优雅降级和渐进增强"></a>优雅降级和渐进增强</h1><p>_优雅降级_：Web 站点在所有新式浏览器中都能正常工作，如果用户使用的是旧式浏览器，则代码会针对旧版本的 IE 进行降级处理，使之在旧式浏览器上以某种形式降级体验而不至于完全不能使用。</p><p>_渐进增强_：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能，向页面增加不影响基础浏览器的额外样式和功能。当浏览器支持时，它们会自定地呈现出来并发挥作用。</p><h1 id="常见空-VOID-元素"><a href="#常见空-VOID-元素" class="headerlink" title="常见空 VOID 元素"></a>常见空 VOID 元素</h1><p><code>br、hr、img、input、link、meta</code></p><h1 id="window-load-和-DOMContentLoaded-的区别"><a href="#window-load-和-DOMContentLoaded-的区别" class="headerlink" title="window.load 和 DOMContentLoaded 的区别"></a><code>window.load</code> 和 <code>DOMContentLoaded</code> 的区别</h1><ul><li><code>window.load</code>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件。</li><li><code>DOMContentLoaded</code>仅当HTML和内联外联js脚本加载并同步代码都执行完。</li></ul><h1 id="visibilityState"><a href="#visibilityState" class="headerlink" title="visibilityState"></a><code>visibilityState</code></h1><p>通过<code>visibilityState</code>的值检测页面当前是否可见，以及打开页面的时间等<br>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</p><h1 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h1><ol><li>同层相邻块级元素之间外边距重叠</li><li>子元素与父元素的外边距重叠</li><li>空元素(margin-top直接贴到margin-bottom时)</li></ol><h1 id="link-和-import-有什么区别"><a href="#link-和-import-有什么区别" class="headerlink" title="link 和@import 有什么区别"></a>link 和@import 有什么区别</h1><ul><li><p><code>link</code>  是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS ，rel和图标等；<code>@import</code> 只能加载 CSS。</p></li><li><p><code>link</code> 支持并行下载；<code>@import</code> 串行下载且需放在样式表顶层。</p></li><li><p><code>@import</code> 是在 CSS2.1 提出的，低版本的浏览器（IE5 以下）不支持。</p></li><li><p><code>link</code> 支持使用 Javascript 控制 DOM 去改变样式；而<code>@import</code> 不支持。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型的判断与转换</title>
    <link href="/2022/02/24/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/02/24/js%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ECAMScript-中不能自定义数据类型，只能为下列-7-种"><a href="#ECAMScript-中不能自定义数据类型，只能为下列-7-种" class="headerlink" title="ECAMScript 中不能自定义数据类型，只能为下列 7 种"></a>ECAMScript 中不能自定义数据类型，只能为下列 7 种</h1><h2 id="简单数据类型（原始类型）"><a href="#简单数据类型（原始类型）" class="headerlink" title="简单数据类型（原始类型）"></a>简单数据类型（原始类型）</h2><ul><li><p><code>String</code></p></li><li><p><code>Number</code></p><ul><li><code>NaN</code><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span> === <span class="hljs-string">&#x27;number&#x27;</span>唯一一个自相反的值<span class="hljs-title class_">NaN</span> !== <span class="hljs-title class_">NaN</span></code></pre></div></li></ul></li><li><p><code>Boolean</code></p><ul><li>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 true，包括所有对象。</li><li>布尔值与其他类型比较都会转为数字</li></ul></li><li><p><code>null</code></p><ul><li><code>typeof null = object</code>,<em>null 表示一个空对象指针</em></li><li>null 必须手动设置，常用于作为参数传入，说明该参数不是对象</li><li>设置为 null 的变量或者对象会被内存收集器回收</li><li><code>null</code> 转为数字类型值为 <code>0</code></li></ul></li></ul><ul><li><p><code>undefined</code></p><ul><li>调用一个值而它本身没有赋值</li><li><code>undefined == null</code> </li><li><code>undefined</code> 转为数字类型为 <code>NaN</code></li></ul></li><li><p><code>Symbol</code>[ES6 新增]</p><ul><li>表示独一无二的值</li></ul></li></ul><h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><p><code>Object</code></p><ul><li>引用类型的值是指向保存在堆中的对象的指针</li><li>使用时要先从栈中读取内存地址，再沿着指针找到堆中的对象</li><li>Object</li><li>Array<ul><li>数组的每一项可以用来保存任何类型的数据</li></ul></li><li>Function<ul><li>每个函数都是 Function 的实例</li></ul></li></ul><h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><h2 id="typeOf"><a href="#typeOf" class="headerlink" title="typeOf"></a><code>typeOf</code></h2><ul><li>对未声明的变量，只有对它调用<code>typeof</code>不报错，return <code>undefined</code></li><li>特殊的几个</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &#x27;undefined&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// &#x27;symbol&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &#x27;object&#x27;</span><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// number</span></code></pre></div><h2 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN"></a><code>isNaN</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>));    <span class="hljs-comment">//true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">10</span>));     <span class="hljs-comment">//false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;10&quot;</span>));   <span class="hljs-comment">//false</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;blue&quot;</span>)); <span class="hljs-comment">//true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">true</span>));   <span class="hljs-comment">//false</span></code></pre></div><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h2><p><code>instanceof</code> 运算符用来测试一个<em>对象</em>在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性，但它不能检测<code>null</code> 和 <code>undefined</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">[] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> <span class="hljs-comment">// true</span>&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span> <span class="hljs-comment">// true</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>() <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">RegExp</span> <span class="hljs-comment">// true</span><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// error</span><span class="hljs-literal">undefined</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-literal">undefined</span> <span class="hljs-comment">// error</span></code></pre></div><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// [Function: Array]</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">constructor</span>); <span class="hljs-comment">// [Function: Object]</span></code></pre></div><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a><code>Object.prototype.toString.call()</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// [object String]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// [object Number]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [object Boolean]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// [object Undefined]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// [object Null]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>()); <span class="hljs-comment">// [object Function]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()); <span class="hljs-comment">// [object Date]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>()); <span class="hljs-comment">// [object RegExp]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>([]); <span class="hljs-comment">// [object Array]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(&#123;&#125;); <span class="hljs-comment">// [object Object]</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()); <span class="hljs-comment">// [object Error]</span></code></pre></div><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="转为数值"><a href="#转为数值" class="headerlink" title="转为数值"></a>转为数值</h2><h3 id="Number-适用于任何类型"><a href="#Number-适用于任何类型" class="headerlink" title="Number() 适用于任何类型"></a>Number() 适用于任何类型</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&quot;000011&quot;</span>); <span class="hljs-comment">// 11</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 1</span></code></pre></div><h3 id="parseInt-string-radix-主要用于字符串"><a href="#parseInt-string-radix-主要用于字符串" class="headerlink" title="parseInt(string, radix) 主要用于字符串"></a>parseInt(string, radix) 主要用于字符串</h3><ul><li>如果第一个字符不是数值字符、加号或减号，立即返回NaN<br>,这意味着空字符串也会返回 NaN<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 10</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-number">22.5</span>); <span class="hljs-comment">//22</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;abc&quot;</span>); <span class="hljs-comment">// NaN</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123abc&quot;</span>) <span class="hljs-comment">// 123</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>].<span class="hljs-title function_">map</span>(<span class="hljs-built_in">parseInt</span>)<span class="hljs-comment">// [1, NaN, NaN]</span><span class="hljs-comment">// map调用的回调会默认传入三个参数【当前元素，当前索引，当前数组】</span><span class="hljs-comment">// parseInt(1,0) =&gt; 1</span><span class="hljs-comment">// parseInt(2,1) =&gt; radix&gt;=2,NaN</span><span class="hljs-comment">// parseInt(3,2) =&gt; 木有二进制表示的3,NaN</span></code></pre></div><h3 id="parseFloat-string-主要用于字符串"><a href="#parseFloat-string-主要用于字符串" class="headerlink" title="parseFloat(string) 主要用于字符串"></a>parseFloat(string) 主要用于字符串</h3></li><li>只解析十进制</li><li>忽略2次出现的小数点<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> num1 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;1234blue&quot;</span>); <span class="hljs-comment">// 1234</span><span class="hljs-keyword">let</span> num2 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0xA&quot;</span>); <span class="hljs-comment">// 0</span><span class="hljs-keyword">let</span> num3 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.5&quot;</span>); <span class="hljs-comment">// 22.5</span><span class="hljs-keyword">let</span> num4 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;22.34.5&quot;</span>); <span class="hljs-comment">// 22.34</span><span class="hljs-keyword">let</span> num5 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;0908.5&quot;</span>);  <span class="hljs-comment">//908.5</span><span class="hljs-keyword">let</span> num6 = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;3.125e7&quot;</span>); <span class="hljs-comment">// 31250000</span></code></pre></div></li></ul><h2 id="转为字符串"><a href="#转为字符串" class="headerlink" title="转为字符串"></a>转为字符串</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>  null和undefined没有toString()方法</p><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><ul><li><em>优先调用toString()</em></li><li>null 转换为 ‘null’</li><li>undefined 转换为 ‘undefined’</li></ul><h2 id="转为布尔值"><a href="#转为布尔值" class="headerlink" title="转为布尔值"></a>转为布尔值</h2><ul><li>Boolean()<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//除了以下六个转为 false 其他全部都为 true</span><span class="hljs-literal">undefined</span><span class="hljs-literal">null</span><span class="hljs-number">0</span>-<span class="hljs-number">0</span><span class="hljs-title class_">NaN</span><span class="hljs-string">&#x27;&#x27;</span></code></pre></div></li></ul><h1 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h1><p>在 js 中，当运算符在运算时，如果两边数据不统一，CPU 就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算.这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换</p><h2 id="隐式转换规则"><a href="#隐式转换规则" class="headerlink" title="隐式转换规则"></a>隐式转换规则</h2><ul><li>转成 string 类型： <code>+</code>（字符串连接符）</li><li>转成 number 类型：<code>++/--</code>(自增自减运算符) <code>+ - * / %</code>(算术运算符) <code>&gt; &lt; &gt;= &lt;= == != === !===</code> (关系运算符)</li><li>转成 boolean 类型：<code>!</code>（逻辑非运算符）</li></ul><h2 id="字符串连接符与算术运算符"><a href="#字符串连接符与算术运算符" class="headerlink" title="字符串连接符与算术运算符"></a>字符串连接符与算术运算符</h2><p><code>+</code>左右有字符串则转为字符串拼接，否则转为数字计算</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//+是字符串连接符： String(1) + &#x27;true&#x27; = &#x27;1true&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>); <span class="hljs-comment">//1true</span><span class="hljs-comment">//+是算术运算符 ： 1 + Number(true) = 1 + 1 = 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">//2</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(undefined) = 1 + NaN = NaN</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//   NaN</span><span class="hljs-comment">// +是算术运算符 ： 1 + Number(null) = 1 + 0 = 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>); <span class="hljs-comment">//1</span><span class="hljs-comment">//</span></code></pre></div><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>会把其他数据类型转换成 number 之后再比较关系</p><p><em>此时并不是按照 Number()的形式转成数字，而是按照字符串对应的 unicode 编码来转成数字</em></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span> &gt; <span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//true     &#x27;2&#x27;.charCodeAt() &gt; &#x27;10&#x27;.charCodeAt() = 50 &gt; 49 = true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>.<span class="hljs-title function_">charCodeAt</span>()); <span class="hljs-comment">//数字50</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;10&quot;</span>.<span class="hljs-title function_">charCodeAt</span>()); <span class="hljs-comment">//数字49（默认返回第一个字符的编码，如果想要查询第二个字符可以传参下标）</span><span class="hljs-comment">//多个字符从左往右依次比较</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">//false     先比较&#x27;a&#x27; 和 &#x27;b&#x27;， &#x27;a&#x27; 与 &#x27;b&#x27;不等，则直接得出结果</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;abc&quot;</span> &gt; <span class="hljs-string">&quot;aad&quot;</span>); <span class="hljs-comment">//true     先比较&#x27;a&#x27;和&#x27;a&#x27;，两者相等，继续比较第二个字符 &#x27;b&#x27; 与 &#x27;a&#x27; ,得出结果</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a&quot;</span>.<span class="hljs-title function_">charCodeAt</span>()); <span class="hljs-comment">//数字97</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b&quot;</span>.<span class="hljs-title function_">charCodeAt</span>()); <span class="hljs-comment">//数字98</span><span class="hljs-comment">//2.3 特殊情况(无视规则)：如果数据类型是undefined与null，，得出固定的结果</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>); <span class="hljs-comment">//true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">null</span> == <span class="hljs-literal">null</span>); <span class="hljs-comment">//true</span><span class="hljs-comment">//2.4 特殊情况（无视规则）：NaN与任何数据比较都是NaN</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>); <span class="hljs-comment">//false</span></code></pre></div><h2 id="复杂数据类型的隐式转换"><a href="#复杂数据类型的隐式转换" class="headerlink" title="复杂数据类型的隐式转换"></a>复杂数据类型的隐式转换</h2><ol><li>先使用<code>valueOf()</code>方法获取其原始值，如果原始值不是<code>number</code>类型，则使用 <code>toString()</code>方法转成<code>string</code></li><li>再将 <code>string</code> 转成 <code>number</code> 运算</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == <span class="hljs-string">&quot;1,2&quot;</span>; <span class="hljs-comment">//true     先将左边数组转成string，然后右边也是string则转成unicode编码运算</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">valueOf</span>(); <span class="hljs-comment">// [1,2]</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;1,2&#x27;</span><span class="hljs-keyword">var</span> a = &#123;&#125;;a == <span class="hljs-string">&quot;[object Object]&quot;</span>; <span class="hljs-comment">//true</span>a.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//[object Object]</span></code></pre></div><h2 id="逻辑非隐式转换与关系运算符"><a href="#逻辑非隐式转换与关系运算符" class="headerlink" title="逻辑非隐式转换与关系运算符"></a>逻辑非隐式转换与关系运算符</h2><blockquote><p>如果两个引用类型比较,会比较内存地址,注意要是其中有逻辑非运算符,非运算优先级会大于比较操作</p></blockquote><ul><li>空数组的 toString()方法会得到空字符串<code>&#39;&#39;</code></li><li>空对象的 toString()方法会得到字符串<code>[object Object]</code> </li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>([])); <span class="hljs-comment">// true</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Boolean</span>(![])); <span class="hljs-comment">// false</span><span class="hljs-comment">// Boolean除了0,-0,null,undefined,false,&#x27;&#x27;都转为true</span><span class="hljs-comment">//大坑</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true []转数字为0</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(![] == <span class="hljs-number">0</span>); <span class="hljs-comment">//true  </span><span class="hljs-comment">// 这里有逻辑非运算符,会先转Boolean,![]转布尔false，转数字为0</span><span class="hljs-comment">//神坑</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] == ![]); <span class="hljs-comment">//true</span><span class="hljs-comment">// ![]转布尔false=&gt;0,0和[]比较,[]转数字为0</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] == []); <span class="hljs-comment">//false // 内存地址不同</span><span class="hljs-comment">//史诗级坑</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == !&#123;&#125;); <span class="hljs-comment">//false</span><span class="hljs-comment">// &#123;&#125;最终转number为NaN,右边转数字为0</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; == &#123;&#125;); <span class="hljs-comment">//false // 内存地址不同</span></code></pre></div><h2 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h2><h3 id="es6-新增Object-is-判断"><a href="#es6-新增Object-is-判断" class="headerlink" title="es6 新增Object.is()判断"></a>es6 新增<code>Object.is()</code>判断</h3><p>修复了转布尔值的bug</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// true</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-number">0</span>, +<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(-<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>); <span class="hljs-comment">// true</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// false</span><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-number">0</span> / <span class="hljs-number">0</span>); <span class="hljs-comment">// true</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> _Object.<span class="hljs-title function_">is</span>(<span class="hljs-params">x,y</span>)&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span>)&#123;    <span class="hljs-keyword">if</span>(x===y)&#123;      <span class="hljs-keyword">return</span> x!==<span class="hljs-number">0</span> || <span class="hljs-number">1</span>/x === <span class="hljs-number">1</span>/y    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> x!==x &amp;&amp; y!== y    &#125;  &#125;&#125;</code></pre></div><h1 id="hack技巧"><a href="#hack技巧" class="headerlink" title="hack技巧"></a>hack技巧</h1><ul><li>转string<br><code>123+&#39;&#39;</code>  // ‘123’</li><li>转number<br><code>+123</code> // 123</li><li>位运算<ul><li>向下取整<div class="hljs code-wrapper"><pre><code class="hljs javascript">~~<span class="hljs-number">1.9</span> = <span class="hljs-number">1</span><span class="hljs-number">1.9</span> &gt;&gt; <span class="hljs-number">0</span> = <span class="hljs-number">1</span></code></pre></div></li><li>Math.floor(N/2)<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">124.9</span> &gt;&gt; <span class="hljs-number">1</span> = <span class="hljs-number">62</span></code></pre></div></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js运行机制</title>
    <link href="/2022/02/24/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/02/24/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/10714ad38f9a">ref:javascript 运行机制 EventLoop</a></p><h2 id="JS-的单线程"><a href="#JS-的单线程" class="headerlink" title="JS 的单线程"></a>JS 的单线程</h2><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程,保证执行任务的有序并避开复杂的同步问题。</p><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><ul><li>js 是单线程运行的</li><li>浏览器是多线程的</li></ul><p>在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。如果遇到了异步任务，js 引擎并不会一直等待其返回结果，而是会将这个事件的回调放入任务队列，继续执行执行栈中的其他任务。当执行栈清空后，再去任务队列读取异步函数的回调加入执行栈中执行。</p><ul><li><p>事件循环</p><ol><li>js同一时间只能执行一个任务，在这期间可能推入多个执行上下文</li><li>执行同步函数</li><li>将异步函数将其回调分别加入<em>宏任务队列</em>和<em>微任务队列</em></li><li>执行栈为空后（同步函数执行完），读取微任务队列执行</li><li>执行栈为空后，读取宏任务队列执行</li><li>执行栈为空后，如果该宏任务继续产生微任务则需要执行完新的微任务<ol><li>执行完本轮任务</li></ol></li></ol></li></ul><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>异步任务通过任务队列来管理，任务被分为两类：微任务（<code>micro task</code>）和宏任务（<code>macro task</code>）</p><ul><li><p>微任务（js引擎自己发起的任务）包括 <code>process.nextTick</code> ，<code>promise.then</code> ，<code>catch</code>,<code>finally</code> ，<code>MutationObserver</code></p><ul><li>  NOTE:<code>nextTick</code>会提升到微任务队列的栈顶</li><li>  NOTE:遇到 <code>await</code>时,对<code>await</code>右侧进行计算,接着先去去执行<code>async</code>外部的同步函数,后再回到<code>async</code>函数中</li></ul></li><li><p>  宏任务（宿主环境[浏览器，node]下发的任务）包括 <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code>操作 ，<code>UI</code>渲染</p></li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li><p>```javascript<br> // 1<br> console.log(“script start”); // 1</p><p> setTimeout(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;setTimeout&quot;); // 4</code></pre></div><p> }, 0);</p><p> Promise.resolve()</p><div class="hljs code-wrapper"><pre><code class="hljs"> .then(function () &#123;     console.log(&quot;promise1&quot;); //2 &#125;) .then(function () &#123;     console.log(&quot;promise2&quot;); //3 &#125;);</code></pre></div> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="language-javascript">javascript</span><span class="language-javascript">    <span class="hljs-comment">// 2</span></span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// 5</span></span><span class="language-javascript">    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//7</span></span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4&quot;</span>); <span class="hljs-comment">//6</span></span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">//8</span></span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span></span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span></span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span></span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span></span><span class="language-javascript">    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span></span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span></span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;12&quot;</span>);</span><span class="language-javascript">    &#125;); <span class="hljs-comment">//12</span></span><span class="language-javascript">    &#125;);</span></code></pre></div></li><li><p>```javascript<br> // 3<br> async function async1() {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(1); //1 new Promise(() =&gt; &#123;     console.log(2); //2 &#125;); Promise.resolve().then(() =&gt; &#123;     console.log(&quot;异步3&quot;); //6 &#125;); console.log(&quot;同步3&quot;); //3</code></pre></div><p> }</p><p> Promise.resolve().then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(4); //5</code></pre></div><p> });</p><p> setTimeout(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(5); //7</code></pre></div><p> });</p><p> async1();</p><p> console.log(6); //4</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="language-javascript">javascript</span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;定时器开始啦&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;马上执行for循环啦&quot;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;</span><span class="language-javascript">    i == <span class="hljs-number">99</span> &amp;&amp; <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;执行then函数啦&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;代码执行结束&quot;</span>);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 马上执行for循环啦</span></span><span class="language-javascript">    <span class="hljs-comment">// 代码执行结束</span></span><span class="language-javascript">    <span class="hljs-comment">// 执行then函数啦</span></span><span class="language-javascript">    <span class="hljs-comment">// 定时器开始啦</span></span></code></pre></div></li><li><p>```javascript<br> setTimeout(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;setTimeout&quot;);</code></pre></div><p> });</p><p> new Promise(function (resolve) {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise&quot;); resolve();</code></pre></div><p> }).then(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;then&quot;);</code></pre></div><p> });</p><p> console.log(“console”);</p><p> // promise<br> // console<br> // then<br> // setTimeout</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="language-javascript">javascript</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// console.log(&#x27;2&#x27;);</span></span><span class="language-javascript">    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// console.log(&#x27;4&#x27;);</span></span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;5&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;6&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;7&quot;</span>);</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;8&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;10&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;12&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    &#125;);</span></code></pre></div></li><li><p>```javascript<br> setTimeout(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(1);</code></pre></div><p> }, 0);<br> Promise.resolve().then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(2);</code></pre></div><p> });<br> console.log(3);</p><p> // 3 2<br> // 1</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="language-javascript">javascript</span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);</span><span class="language-javascript">    &#125;, <span class="hljs-number">0</span>);</span><span class="language-javascript">    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 2 5 3 4</span></span><span class="language-javascript">    <span class="hljs-comment">// 1</span></span></code></pre></div></li><li><p>```javascript<br> let a = new Promise((resolve) =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(2); resolve();</code></pre></div><p> }).then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(5);</code></pre></div><p> });<br> a.then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(3);</code></pre></div><p> });<br> a.then(() =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(4);</code></pre></div><p> });</p><p> // 2 5 3 4</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="language-javascript">javascript</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then11&quot;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise2&quot;</span>);</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then21&quot;</span>);</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then23&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then12&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// promise1,then11,promise2,then21,then12,then23</span></span></code></pre></div></li><li><p>```javascript<br> new Promise((resolve, reject) =&gt; {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise1&quot;); resolve();</code></pre></div><p> })</p><div class="hljs code-wrapper"><pre><code class="hljs"> .then(() =&gt; &#123;     console.log(&quot;then11&quot;);     return new Promise((resolve, reject) =&gt; &#123;         console.log(&quot;promise2&quot;);         resolve();     &#125;)         .then(() =&gt; &#123;             console.log(&quot;then21&quot;);         &#125;)         .then(() =&gt; &#123;             console.log(&quot;then23&quot;);         &#125;); &#125;) .then(() =&gt; &#123;     console.log(&quot;then12&quot;); &#125;);</code></pre></div><p> // promise1 then11  promise2 then21 then12  then23</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="language-javascript">javascript</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then11&quot;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise2&quot;</span>);</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then21&quot;</span>);</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then23&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then12&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise3&quot;</span>);</span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then31&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//promise1 promise3 then11 promise2 then31 then21 then12 then23</span></span></code></pre></div></li><li><p>```javascript<br> async function async1() {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);</code></pre></div><p> }</p><p> async function async2() {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;async2&quot;);</code></pre></div><p> }</p><p> console.log(“script start”);</p><p> setTimeout(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;settimeout&quot;);</code></pre></div><p> }, 0);</p><p> async1();</p><p> new Promise(function (resolve) {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise1&quot;); resolve();</code></pre></div><p> }).then(function () {</p><div class="hljs code-wrapper"><pre><code class="hljs"> console.log(&quot;promise2&quot;);</code></pre></div><p> });<br> console.log(“script end”);</p><p> // script start,async1 start,async2,promise1,script end,async1 end,promise2<br> // settimeout</p> <div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-number">1.</span>  ```<span class="language-javascript">javascript</span><span class="language-javascript">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>); <span class="hljs-comment">// 2</span></span><span class="language-javascript">    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>); <span class="hljs-comment">//  7</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;async2&quot;</span>); <span class="hljs-comment">// 3</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script start&quot;</span>); <span class="hljs-comment">// 1</span></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;settimeout&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title function_">async1</span>();</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>); <span class="hljs-comment">//4</span></span><span class="language-javascript">    <span class="hljs-title function_">resolve</span>();</span><span class="language-javascript">    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise2&quot;</span>); <span class="hljs-comment">// 8</span></span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setImmediate&quot;</span>);</span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;process&quot;</span>); <span class="hljs-comment">// 6</span></span><span class="language-javascript">    &#125;);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script end&quot;</span>); <span class="hljs-comment">// 5</span></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//script start,async1 start,async2,promise1,script end,process,async1 end,promise2</span></span><span class="language-javascript">    <span class="hljs-comment">//sttimeout,setImmediate</span></span></code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js模块化</title>
    <link href="/2022/02/24/js%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <url>/2022/02/24/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>模块化的演进过程</p></blockquote><ol><li>文件划分</li><li>命名空间 (将每个模块暴露在全局对象</li><li>IIFE 立即执行函数 </li></ol><h2 id="模块化开发的思想"><a href="#模块化开发的思想" class="headerlink" title="模块化开发的思想"></a>模块化开发的思想</h2><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p><h3 id="CommonJS-Node-js"><a href="#CommonJS-Node-js" class="headerlink" title="CommonJS (Node.js)"></a>CommonJS (Node.js)</h3><ul><li><p>运行在服务端</p></li><li><p>代码同步加载</p></li><li><p>代码可以多次加载，但是运行结果会被缓存</p></li><li><p><code>require(&#39;xxx&#39;)</code>加载模块</p></li><li><p><code>module.exports=&#123;&#125;</code>(全局变量或方法)或<code>exports</code>定义对外的接口</p></li></ul><h3 id="AMD-require-js"><a href="#AMD-require-js" class="headerlink" title="AMD (require.js)"></a>AMD (require.js)</h3><ul><li><code>Async Module Definition</code></li><li>依赖前置，定义模块时就要声明依赖</li><li>代码异步加载，且谁先加载完执行谁  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// AMD</span><span class="hljs-title function_">define</span>(<span class="hljs-string">&quot;fooModule&quot;</span>,[<span class="hljs-string">&quot;./a&quot;</span>, <span class="hljs-string">&quot;./b&quot;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) &#123;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;        a.<span class="hljs-title function_">doSomething</span>();        b.<span class="hljs-title function_">doSomething</span>();    <span class="hljs-comment">// ...可能b比a先执行了</span>    &#125;    <span class="hljs-keyword">return</span>&#123;        foo    &#125;    <span class="hljs-built_in">exports</span>.<span class="hljs-property">xxx</span> = ...    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = ...&#125;);<span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;fooModule&quot;</span>,<span class="hljs-string">&#x27;./fooModule.js&#x27;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>,file</span>) &#123;&#125;)</code></pre></div></li></ul><h3 id="CMD-sea-js"><a href="#CMD-sea-js" class="headerlink" title="CMD (sea.js)"></a>CMD (sea.js)</h3><ul><li><code>Common Module Definition</code></li><li> 定义和加载与AMD相同</li><li> 依赖可以就近书写</li><li>依赖全部加载完才按顺序执行  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CMD</span><span class="hljs-title function_">define</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-variable language_">module</span></span>) &#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./a&quot;</span>);    a.<span class="hljs-title function_">doSomething</span>();    <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./b&quot;</span>);     b.<span class="hljs-title function_">doSomething</span>();    <span class="hljs-built_in">exports</span>.<span class="hljs-property">xxx</span> = ...    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = ...&#125;);</code></pre></div></li></ul><h3 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h3><ul><li> <code>Universal Module Definition</code></li><li> 写法是一个自运行函数</li><li> 兼容CMD/AMD/命名空间</li></ul><h3 id="ES6-MODULE"><a href="#ES6-MODULE" class="headerlink" title="ES6 MODULE"></a>ES6 MODULE</h3><ul><li><p>！ES6模块不是对象，<code>import</code>指向的是模块的的只读引用（<strong>动态引用</strong>），<code>export</code>只是显式指定输出的代码</p></li><li><p>编译时加载,用到才执行</p></li><li><p><code>export</code>导出模块,提供<code>export default</code>制定默认输出</p></li><li><p><code>import</code>引入</p></li><li><p><code>import</code>和<code>export</code>命令只能写在代码顶层</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;    <span class="hljs-keyword">return</span> x * y;&#125;<span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> add;<span class="hljs-comment">// app.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;</code></pre></div></li></ul><h3 id="ES6-MODULE和CommonJS的区别"><a href="#ES6-MODULE和CommonJS的区别" class="headerlink" title="ES6 MODULE和CommonJS的区别"></a>ES6 MODULE和CommonJS的区别</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// CommonJS模块</span><span class="hljs-comment">// 运行时加载</span><span class="hljs-keyword">let</span> &#123; stat, exists, readFile &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">let</span> stat = _fs.<span class="hljs-property">stat</span>;<span class="hljs-keyword">let</span> exists = _fs.<span class="hljs-property">exists</span>;<span class="hljs-keyword">let</span> readfile = _fs.<span class="hljs-property">readfile</span>;<span class="hljs-comment">//上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”</span>modules.<span class="hljs-property">exports</span> xxx<span class="hljs-comment">//CommonJS 模块输出的是值的拷贝，输出后模块内部的变化就影响不到这个值</span><span class="hljs-comment">// ES6</span><span class="hljs-comment">// 编译时加载</span><span class="hljs-keyword">import</span> &#123; stat, exists, readFile &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<span class="hljs-comment">//编译时就完成模块加载，（确定了指针</span><span class="hljs-comment">//当然，这也导致了没法引用 ES6 模块本身，因为它不是对象</span><span class="hljs-built_in">exports</span> <span class="hljs-keyword">default</span> xxx<span class="hljs-comment">// ES6 MODULES输出的是值的引用，运行时才到指定模块中取值</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2022/02/24/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/02/24/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>ref:<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md">https://github.com/CyC2018</a></p><h2 id="面向对象的设计思想"><a href="#面向对象的设计思想" class="headerlink" title="面向对象的设计思想"></a>面向对象的设计思想</h2><p>面向对象的设计思想是从自然界中来的，因为在自然界中就存在类（Class）和实例（Instance）的概念。</p><ul><li><p>  Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，</p></li><li><p>  而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。</p></li><li><p>  面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现。</p></li><li><p>  面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p></li></ul><h2 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><ul><li>  减少耦合：可以独立地开发和测试</li><li>  减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析确定哪些模块影响了系统的性能<br>  提高软件的可重用性</li><li>  降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</span><span class="hljs-comment">// 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    private <span class="hljs-title class_">String</span> name;    private int gender;    private int age;    <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-title class_">String</span> <span class="hljs-title function_">getGender</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> gender == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;man&quot;</span> : <span class="hljs-string">&quot;woman&quot;</span>;    &#125;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-number">18</span> &lt;= age &amp;&amp; age &lt;= <span class="hljs-number">50</span>) &#123;            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name + <span class="hljs-string">&quot; is working very hard!&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(name + <span class="hljs-string">&quot; can&#x27;t work any more!&quot;</span>);        &#125;    &#125;&#125;</code></pre></div><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>  子类可以访问父类非 private 属性</p></li><li><p>  里氏替换原则，子类对象必须能够替换掉父类对象。</p></li><li><p>  提高代码的复用性，继承是多态的前提。</p></li></ul><h4 id="ES5中的继承方式"><a href="#ES5中的继承方式" class="headerlink" title="ES5中的继承方式"></a>ES5中的继承方式</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Human</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name&#125;<span class="hljs-title class_">Human</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">introduce</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>&#125;</code></pre></div><ol><li><p>构造函数继承</p><ul><li>只能继承构造函数中的属性<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Asian</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-title class_">Human</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name)&#125;</code></pre></div></li></ul></li><li><p>原型链继承</p><ul><li>不能向父类构造函数传参</li><li>共享引用类型的属性<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Asian</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name&#125;<span class="hljs-title class_">Asian</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>()</code></pre></div></li></ul></li><li><p>1+2组合继承</p><ul><li>父类构造函数被调用太多次</li><li>共享引用类型属性<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Asian</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-title class_">Human</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name)&#125;<span class="hljs-title class_">Asian</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Human</span>()</code></pre></div></li></ul></li><li><p>原型式继承</p><ul><li>适用于不想使用构造函数又想共享数据的情况</li><li>与原型链模式一样共享引用类型的属性<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 其实就是Object.create的实现</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Asian</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Human</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()&#125;</code></pre></div></li></ul></li><li><p>寄生继承</p><ul><li>工厂函数模式</li><li>难以复用<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAsian</span>(<span class="hljs-params">source</span>)&#123;    <span class="hljs-keyword">const</span> o = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(source)    o.<span class="hljs-property">xxx</span> = xxx <span class="hljs-comment">//添加自己的属性</span>    <span class="hljs-keyword">return</span> o&#125;<span class="hljs-keyword">const</span> s1 = <span class="hljs-title function_">createAsian</span>(<span class="hljs-title class_">Human</span>)</code></pre></div></li></ul></li><li><p>寄生组合继承</p><ul><li>只调用一次父构造函数</li><li>保持原原型链<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Asian</span>(<span class="hljs-params">name</span>)&#123;    <span class="hljs-title class_">Human</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name)&#125;<span class="hljs-title class_">Asian</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Human</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-title class_">Asian</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Asian</span></code></pre></div><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3></li></ul></li></ol><ul><li><p>  父类或接口定义的引用变量可以指向子类或实例对象，即多种不同状态</p></li><li><p>  提高了程序的扩展性</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 的方法。</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Instrument</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Instument is playing...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Instrument</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Wind is playing...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Instrument</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span>(<span class="hljs-params"></span>) &#123;        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Percussion is playing...&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Music</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;        <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Instrument</span>&gt; instruments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        instruments.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wind</span>());        instruments.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Percussion</span>());        <span class="hljs-keyword">for</span>(<span class="hljs-title class_">Instrument</span> instrument : instruments) &#123;            instrument.<span class="hljs-title function_">play</span>();        &#125;    &#125;&#125;</code></pre></div><h2 id="六大基本原则："><a href="#六大基本原则：" class="headerlink" title="六大基本原则："></a>六大基本原则：</h2><ul><li><p><code>Single Responsibility Principle：单一职责原则</code></p><p>  一个类应该只有一个发生变化的原因，只负责一项职责</p></li><li><p><code>Open Closed Principle：开闭原则</code></p><p>  对修改封闭，对拓展开放</p></li><li><p><code>Liskov Substitution Principle：里氏替换原则</code></p><p>  子类能完全替代父类</p></li><li><p><code>Law of Demeter：迪米特法则</code></p><p>  功能模块之间尽量减少相互作用，保持相互独立</p></li><li><p><code>Interface Segregation Principle：接口隔离原则</code></p><p>  用多个借口将功能解耦</p></li><li><p><code>Dependence Inversion Principle：依赖倒置原则</code></p><p>  高层模块不应该依赖低层模块，二者都应该依赖其抽象，对抽象接口进行编程</p></li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><code>JavaScript</code> 是一种基于原型的语言 (prototype-based language)</p><p>区别于其他面向对象的语言实例中复制父类的全部属性，js 则使用原型去访问父类的公开属性。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li>JS中万物都为对象，但只有函数拥有原型；</li><li>构造函数生成的实例对象都包含一个指向其原型对象的内部指针<code>O.__proto__/O.constructor.prototype</code>;</li><li>如果这个原型又是另一个构造函数生成的实例，则这个原型对象也可以访问自己的原型对象，这样层层递进链式访问的关系就叫做<code>原型链</code>；</li><li>js 中查找属性时，先查找实例自身，后查找原型对象，再沿着原型链不断上溯，直到原型链的尽头null；</li></ul><h3 id="特殊的Object和Function"><a href="#特殊的Object和Function" class="headerlink" title="特殊的Object和Function"></a>特殊的<code>Object</code>和<code>Function</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-string">&quot;function&quot;</span><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span><span class="hljs-comment">//f()&#123;[native code]&#125;</span><span class="hljs-comment">// 所有引用类型都继承自Object</span><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> <span class="hljs-comment">// true</span></code></pre></div><h3 id="只有函数才有prototype"><a href="#只有函数才有prototype" class="headerlink" title="只有函数才有prototype"></a>只有函数才有<code>prototype</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>) &#123;&#125;f1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// f1直接由Function构造而来</span><span class="hljs-keyword">const</span> obj1 = &#123;&#125;;obj1.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// undefined</span></code></pre></div><h3 id="原形链的终点"><a href="#原形链的终点" class="headerlink" title="原形链的终点"></a>原形链的终点</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === <span class="hljs-string">&#x27;object&#x27;</span><span class="hljs-comment">// 意味着Object的原型是也是一个对象</span><span class="hljs-comment">// 而对象的构造器也是Object，则会出现死循环</span>！【<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>】！<span class="hljs-comment">// 为了让原型链有终点。Javascript规定，</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span></code></pre></div><p><img src="../images/proto.png" alt="proto"></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>)&#123;&#125;f1.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123; [native code] &#125;f1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<span class="hljs-attr">constructor</span>: ƒ, <span class="hljs-attr">__defineGetter__</span>: ƒ, <span class="hljs-attr">__defineSetter__</span>: ƒ, <span class="hljs-attr">hasOwnProperty</span>: ƒ, <span class="hljs-attr">__lookupGetter__</span>: ƒ, …&#125;f1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> = <span class="hljs-literal">null</span><span class="hljs-keyword">const</span> obj = &#123;&#125;obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>obj.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> = <span class="hljs-literal">null</span></code></pre></div><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><ul><li><p><code>Object.getPrototype()</code>/<code>__proto__</code></p><p>  返回指定对象的原型（隐式原型）</p><p>  <code>__proto__</code>虽然在绝大数浏览器都能正常工作，但官方不推荐且已标为废弃，使用<code>Object.getPrototypeOf()</code>替代</p></li><li><p><code>Object.prototype.isPrototypeOf()</code></p><p>  判断对象是否在另一个对象原型链上</p></li></ul><h2 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h2><ol><li>函数的 <code>this</code> 指向函数运行时的执行上下文</li><li>当函数执行时候没有制定<code>this</code>，则<code>this</code>指向<code>Global</code>对象</li><li>当函数被当作对象的方法调用时,<code>this</code> 指向调用对象</li><li><code>new</code>操作符生成的对象 <code>this</code> 指向自己</li><li>箭头函数的<code>this</code>取决于书写时外部函数体的<code>this</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js面试题集</title>
    <link href="/2022/02/24/js%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
    <url>/2022/02/24/js%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<ul><li>  执行顺序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promishe&quot;</span>);&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then&quot;</span>);&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;console&quot;</span>);<span class="hljs-comment">//执行结果</span><span class="hljs-comment">//promise</span><span class="hljs-comment">//console</span><span class="hljs-comment">//then</span><span class="hljs-comment">//setTimeout</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-title function_">resolve</span>();&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-comment">//2</span><span class="hljs-comment">//4</span><span class="hljs-comment">//3</span><span class="hljs-comment">//1</span><span class="hljs-comment">//then是Promise的微任务,new Promise</span></code></pre></div><ul><li><p>浅拷贝</p><ol><li><code>Object.assign()</code></li><li>展开运算符</li></ol></li><li><p>深拷贝</p><ol><li><p><code>JSON.parse(JSON.stringify(source))</code></p><ul><li><p>先 JSON.stringify 转成字符串，再 JSON.parse 把字符串转换成新的对象</p></li><li><p><strong>遇到 Symbol 和函数则报错</strong></p></li></ul></li><li><p>手动实现 deepClone</p></li></ol>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObject</span> = (<span class="hljs-params">obj</span>) =&gt; obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source, cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>()</span>) &#123;<span class="hljs-comment">// WeakSet只能保存对象引用！！且弱引用</span><span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(source) || cache.<span class="hljs-title function_">has</span>(source)) <span class="hljs-keyword">return</span> source;<span class="hljs-keyword">const</span> constructor = source.<span class="hljs-property">constructor</span>;<span class="hljs-keyword">const</span> res = constructor === <span class="hljs-title class_">Object</span> ? &#123;&#125; : <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params">source</span>);<span class="hljs-comment">// 用constructor判断处理其他复杂类型的对象</span><span class="hljs-comment">// eg:Date对象如果使用typeof 返回object</span><span class="hljs-comment">// 加入缓存中</span><span class="hljs-comment">// 处理循环引用</span>cache.<span class="hljs-title function_">add</span>(source);<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(source).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">k</span>) =&gt;</span> &#123;res[k] = <span class="hljs-title function_">deepClone</span>(source[k], cache);&#125;);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></li><li><p>for…in /for…of</p><ul><li><p>for…in 语句以任意顺序遍历一个对象的除 Symbol 以外的<em>可枚举</em>属性,除了遍历对象中的元素之外，还回去遍历自定义的属性，甚至原型链上的属性<br>  <code>javascript const o = &#123;a:1,b:2&#125; Object.defineProperty(o,&#39;c&#39;,&#123;enumerable:false, value:30&#125;) for(let i in o)&#123; console.log(i) &#125; // a // b </code></p></li><li><p>  for…of 则只调用可迭代对象的[Symbol.Iterator]接口遍历对象</p></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">extraFn</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;extraFn&quot;</span>;&#125;;<span class="hljs-keyword">var</span> myArray = [<span class="hljs-string">&quot;1&quot;</span>, &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;mmm&quot;</span> &#125;, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];myArray.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;啦啦啦&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> myArray) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);&#125;<span class="hljs-comment">//1 &#123;name: &quot;mmm&quot;&#125; 3 4 5 6 7</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> myArray) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myArray[index]);&#125;<span class="hljs-comment">// 1</span><span class="hljs-comment">// &#123; name: &#x27;mmm&#x27; &#125;</span><span class="hljs-comment">// 4</span><span class="hljs-comment">// 5</span><span class="hljs-comment">// 6</span><span class="hljs-comment">// 7</span><span class="hljs-comment">// 啦啦啦</span><span class="hljs-comment">// [Function]</span></code></pre></div></li><li><p>  阻止冒泡和默认事件</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">stopBubble</span>(<span class="hljs-params">e</span>) &#123;<span class="hljs-keyword">if</span> (e &amp;&amp; e.<span class="hljs-property">stopPropagation</span>) &#123;e.<span class="hljs-title function_">stopPropagation</span>();&#125; <span class="hljs-keyword">else</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">stopDefault</span>(<span class="hljs-params">e</span>) &#123;<span class="hljs-keyword">if</span> (e &amp;&amp; e.<span class="hljs-property">preventDefault</span>) e.<span class="hljs-title function_">preventDefault</span>();<span class="hljs-keyword">else</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div><ul><li><p>for 循环实现遍历方法</p><ul><li><p>for 循环实现 forEach</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_forEach</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, context</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;context = context || <span class="hljs-variable language_">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(i)) &#123;callback.<span class="hljs-title function_">call</span>(context, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>);&#125;&#125;&#125;;</code></pre></div></li><li><p>for 循环实现 map</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-keyword">const</span> result = [];thisArg = thisArg || <span class="hljs-variable language_">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(i)) &#123;result[i] = callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>);&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 filter</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter_</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-keyword">const</span> result = [];thisArg = thisArg || <span class="hljs-variable language_">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(i)) &#123;<span class="hljs-keyword">if</span> (callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>)) &#123;result.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]);&#125;&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;;</code></pre></div></li><li><p>for 循环实现 some</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_some</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;thisArg = thisArg || <span class="hljs-variable language_">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(i)) &#123;<span class="hljs-keyword">if</span> (callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 every</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_every</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;thisArg = thisArg || <span class="hljs-variable language_">this</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(i)) &#123;<span class="hljs-keyword">if</span> (!callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-variable language_">this</span>[i], i, <span class="hljs-variable language_">this</span>)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;</code></pre></div></li><li><p>for 循环实现 reduce</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_reduce</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, initialValue</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-keyword">let</span> res;<span class="hljs-keyword">let</span> initialIndex = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!initialValue) &#123;<span class="hljs-keyword">for</span> (; initialIndex &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; initialIndex++) &#123;<span class="hljs-comment">// 未指定初始值则自行查找第一个非空下标</span><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasOwnProperty</span>(initialIndex)) &#123;res = <span class="hljs-variable language_">this</span>[i];<span class="hljs-keyword">break</span>;&#125;&#125;&#125; <span class="hljs-keyword">else</span> &#123;res = initialValue;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = initialIndex + <span class="hljs-number">1</span>; j &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; j++) &#123;res = callback.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, res, <span class="hljs-variable language_">this</span>[j], j, <span class="hljs-variable language_">this</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div></li></ul></li><li><p>reduce 实现遍历方法</p><ul><li>  reduce 实现 forEach</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_forEach</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-comment">/*无返回*/</span><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, acc, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> [...pre, callback.<span class="hljs-title function_">call</span>(thisArg, acc, index, <span class="hljs-variable language_">this</span>)];&#125;, []);&#125;;</code></pre></div><ul><li>  reduce 实现 map</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"> <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) &#123; <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>); &#125; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>); &#125;<span class="hljs-comment">/*有返回*/</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,acc,index</span>)=&gt;</span>&#123;<span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">concat</span>(callback.<span class="hljs-title function_">call</span>(thisArg, acc, index, <span class="hljs-variable language_">this</span>))&#125;,[]) &#125;;</code></pre></div><ul><li>  reduce 实现 filter</li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, thisArg</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> == <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;this is null or undefined&quot;</span>);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(callback + <span class="hljs-string">&quot;must be a function&quot;</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, acc</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> callback.<span class="hljs-title function_">call</span>(thisArg, acc, index, <span class="hljs-variable language_">this</span>) ? [...pre, cur] : [...pre];&#125;, []);&#125;;</code></pre></div></li><li><p>数组的所有排列组合</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exchange</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-comment">//[[1,2,3],[4,5,6],[7,8,9]]</span><span class="hljs-comment">// 每个数组中取一个值组成新的数字</span><span class="hljs-comment">// 列出所有的排列可能性</span><span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">if</span> (len &gt;= <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">let</span> len1 = arr[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<span class="hljs-keyword">let</span> len2 = arr[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<span class="hljs-keyword">let</span> lenBoth = len1 * len2;<span class="hljs-keyword">let</span> items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(lenBoth);<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; len2; j++) &#123;items[index] = [].<span class="hljs-title function_">concat</span>(arr[<span class="hljs-number">0</span>][i]).<span class="hljs-title function_">concat</span>(arr[<span class="hljs-number">1</span>][j]);index++;&#125;&#125;<span class="hljs-comment">// 求出前两个数组的组合</span><span class="hljs-comment">// 接下来调整数组，递归调用</span><span class="hljs-comment">// 拼接剩余参数数组</span><span class="hljs-keyword">return</span> <span class="hljs-title function_">exchange</span>(items, ...arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>));&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];&#125;&#125;</code></pre></div></li><li><p>  属性名表达式</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> b = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">10</span> &#125;;<span class="hljs-keyword">let</span> obj = &#123;  <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,&#125;;obj[b] = <span class="hljs-number">20</span>;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[a]); <span class="hljs-comment">// 20</span><span class="hljs-comment">//obj.b和obj[b]的不同</span>obj[需要是已经声明的变量名]obj.则不受限制obj.<span class="hljs-property">c</span> = <span class="hljs-number">20</span> ===&gt; <span class="hljs-attr">obj</span>:&#123;<span class="hljs-attr">c</span>:<span class="hljs-number">20</span>,<span class="hljs-attr">a</span>:<span class="hljs-number">10</span>&#125;obj[c] <span class="hljs-comment">//报错</span><span class="hljs-comment">//原题中obj[b]后打印得到</span>obj = &#123;  <span class="hljs-attr">a</span>:<span class="hljs-number">10</span>,  <span class="hljs-string">&#x27;[object:object]&#x27;</span> : <span class="hljs-number">20</span>  <span class="hljs-comment">//b = &#123; b: 10 &#125; ===&gt; &#x27;[object:object]&#x27;</span>&#125;后再访问obj[a]时也就是访问obj[<span class="hljs-string">&#x27;[object:object]&#x27;</span>] = <span class="hljs-number">20</span></code></pre></div><ul><li>  this 的指向</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">20</span>,<span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;,&#125;;obj.<span class="hljs-title function_">say</span>();<span class="hljs-comment">// 打印出10的方法</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">20</span>,<span class="hljs-attr">say</span>: <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;,&#125;;obj.<span class="hljs-title function_">say</span>();<span class="hljs-comment">// 2</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">20</span>,<span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;,&#125;;<span class="hljs-keyword">let</span> say = obj.<span class="hljs-property">say</span>;<span class="hljs-title function_">say</span>();<span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">20</span>,<span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);&#125;,&#125;;obj.<span class="hljs-property">say</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);</code></pre></div><ul><li>  js 执行顺序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// js执行顺序</span><span class="hljs-comment">// 1</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;script start&quot;</span>); <span class="hljs-comment">// 1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>); <span class="hljs-comment">// 4</span>&#125;, <span class="hljs-number">0</span>);<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>); <span class="hljs-comment">//2</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise2&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-comment">// 2</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>); <span class="hljs-comment">//1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// 5</span>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//7</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4&quot;</span>); <span class="hljs-comment">//6</span><span class="hljs-title function_">resolve</span>();&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;5&quot;</span>); <span class="hljs-comment">//8</span>&#125;);&#125;);process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;6&quot;</span>); <span class="hljs-comment">//3</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;7&quot;</span>); <span class="hljs-comment">//2</span><span class="hljs-title function_">resolve</span>();&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;8&quot;</span>); <span class="hljs-comment">//4</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;9&quot;</span>); <span class="hljs-comment">//9</span>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;10&quot;</span>); <span class="hljs-comment">//11</span>&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;11&quot;</span>); <span class="hljs-comment">//10</span><span class="hljs-title function_">resolve</span>();&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;12&quot;</span>);&#125;); <span class="hljs-comment">//12</span>&#125;);<span class="hljs-comment">// 3</span><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//1</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//2</span>&#125;);<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3-1&quot;</span>); <span class="hljs-comment">//6</span>&#125;);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3-2&quot;</span>); <span class="hljs-comment">//3</span>&#125;<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">//5</span>&#125;);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">//7</span>&#125;);<span class="hljs-title function_">async1</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">//4</span></code></pre></div><ul><li>  js 执行优先级</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);&#125;;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;&#125;<span class="hljs-title class_">Foo</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);&#125;;<span class="hljs-title class_">Foo</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);&#125;;<span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);&#125;<span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>();<span class="hljs-title function_">getName</span>();<span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();<span class="hljs-comment">// function changeThis()&#123;</span><span class="hljs-comment">//   return this</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// changeThis().fn666 = ()=&gt;&#123;</span><span class="hljs-comment">//   console.log(666);</span><span class="hljs-comment">// &#125;</span><span class="hljs-comment">// global.fn666()</span><span class="hljs-title function_">getName</span>();<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>.<span class="hljs-title function_">getName</span>();<span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();<span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>().<span class="hljs-title function_">getName</span>();</code></pre></div><ul><li>  实现一个 setTimeout</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_setTimeout</span>(<span class="hljs-params">cb, timeout, ...args</span>) &#123;<span class="hljs-keyword">const</span> start = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop);<span class="hljs-keyword">const</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<span class="hljs-keyword">if</span> (now - start &gt;= timeout) &#123;cb.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">cancelAnimationFrame</span>(timer);&#125;&#125;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop);&#125;</code></pre></div><ul><li>  使用 setTimeout 模拟 setInterval</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// setInterval 的问题</span><span class="hljs-comment">// 定时往事件队列中添加回调函数，如果主线程运行时间过长到大量回调超时，则有可能同时执行大量异步回调，违背使用意图</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">_setInterval</span>(<span class="hljs-params">fn,timeout,...args</span>)&#123;  <span class="hljs-keyword">const</span> controller = &#123;    stop = <span class="hljs-literal">false</span>    <span class="hljs-comment">// 控制器</span>  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_interval</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">if</span>(!controller.<span class="hljs-property">stop</span>)&#123;      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>,args)      <span class="hljs-built_in">setTimeout</span>(_interval,timeout)    &#125;  &#125;  <span class="hljs-built_in">setTimeout</span>(_interval,timeout)  <span class="hljs-keyword">return</span> controller&#125;</code></pre></div><ul><li>  模版字符串</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/\&#123;\&#123;(w+)\&#125;\&#125;/g</span>;<span class="hljs-keyword">const</span> template = <span class="hljs-string">&quot;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&quot;</span>;<span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;森下上士&quot;</span>,<span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">template, data</span>) &#123;<span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(template)) &#123;<span class="hljs-keyword">const</span> tem = template.<span class="hljs-title function_">match</span>(reg);tem.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> p = key.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>, -<span class="hljs-number">2</span>);<span class="hljs-comment">// &#123;&#123;xxx&#125;&#125; ==&gt; xxx</span>template = template.<span class="hljs-title function_">replace</span>(key, data[p]);&#125;);&#125;<span class="hljs-keyword">return</span> template;&#125;</code></pre></div><ul><li>  js 获取文件扩展名</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExt</span>(<span class="hljs-params">filename</span>) &#123;<span class="hljs-keyword">return</span> filename.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>).<span class="hljs-title function_">pop</span>();&#125;<span class="hljs-comment">// 按.分割字符串为数组</span><span class="hljs-comment">// pop删除最后一项并返回</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getExt</span>(<span class="hljs-params">filename</span>) &#123;<span class="hljs-keyword">return</span> filename.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/.+\./</span>, <span class="hljs-string">&quot;&quot;</span>);&#125;</code></pre></div><ul><li>  匿名函数自执行</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接在匿名函数之后加（）无效</span><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>])&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<span class="hljs-comment">//加号</span>+<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//减号</span>-<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//感叹号</span>!<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<span class="hljs-comment">//括号</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);&#125;)(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]+<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);&#125;(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>));</code></pre></div><ul><li>  数组的全排列</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">permute</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-comment">// 回溯算法</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursion</span>(<span class="hljs-params">path, set</span>) &#123;<span class="hljs-keyword">if</span> (path.<span class="hljs-property">length</span> === arr.<span class="hljs-property">length</span>) &#123;<span class="hljs-keyword">return</span> res.<span class="hljs-title function_">push</span>([...path]); <span class="hljs-comment">// 潜拷贝一次</span>&#125;<span class="hljs-comment">// 使用path记录回溯的路径</span><span class="hljs-comment">// [1,2,3,4]</span><span class="hljs-comment">// path[1,2]，set[1,2]</span><span class="hljs-comment">// 1,2,已经用过</span><span class="hljs-comment">// 分别遍历3，4</span><span class="hljs-comment">// 添加[1,2,3,4],[1,2,4,3]进结果</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> arr) &#123;<span class="hljs-keyword">if</span> (set.<span class="hljs-title function_">has</span>(num)) <span class="hljs-keyword">continue</span>;path.<span class="hljs-title function_">push</span>(num);set.<span class="hljs-title function_">add</span>(num);<span class="hljs-title function_">recursion</span>(path, set);path.<span class="hljs-title function_">pop</span>();set.<span class="hljs-title function_">delete</span>(num);&#125;&#125;<span class="hljs-title function_">recursion</span>([], <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>());<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>二分查找元素<blockquote><p>试用于顺序数组</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">binaryFind</span>(<span class="hljs-params">arr, target, s = <span class="hljs-number">0</span>, e = arr.length - <span class="hljs-number">1</span></span>) &#123;<span class="hljs-keyword">const</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((s + e) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (arr[i] === target) &#123;<span class="hljs-keyword">return</span> i;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; target) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">binaryFind</span>(arr, target, s, i - <span class="hljs-number">1</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &lt; target) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">binaryFind</span>(arr, target, i + <span class="hljs-number">1</span>, e);&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">binaryFind2</span>(<span class="hljs-params">arr, target</span>) &#123;<span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span>,e = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>,mid;<span class="hljs-keyword">while</span> (s &lt;= e) &#123;mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((s + e) / <span class="hljs-number">2</span>);<span class="hljs-keyword">if</span> (arr[mid] === target) &#123;<span class="hljs-keyword">return</span> mid;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; target) &#123;e = mid - <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &lt; target) &#123;s = mid + <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;</code></pre></div><ul><li>  对象扁平化（展开数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, &#123; <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span> &#125;], <span class="hljs-attr">d</span>: &#123; <span class="hljs-attr">e</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">f</span>: <span class="hljs-number">3</span> &#125;, <span class="hljs-attr">g</span>: <span class="hljs-literal">null</span> &#125;;<span class="hljs-comment">// &#123; &quot;a&quot;: 1, &quot;b[0]&quot;: 1, &quot;b[1]&quot;: 2, &quot;b[2].c&quot;: true, &quot;d.e&quot;: 2, ... &#125;</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">isObject</span> = (<span class="hljs-params">obj</span>) =&gt; obj !== <span class="hljs-literal">null</span> &amp;&amp; obj.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Object</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFlat</span>(<span class="hljs-params">obj</span>) &#123;<span class="hljs-keyword">const</span> res = &#123;&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">obj, path</span>) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isObject</span>(obj)) &#123;res[path] = obj;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, val]</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(val)) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; val.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-title function_">flat</span>(val[i], path ? path + <span class="hljs-string">&quot;.&quot;</span> + key + <span class="hljs-string">&quot;[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span> : key + <span class="hljs-string">&quot;[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isObject</span>(val)) &#123;<span class="hljs-title function_">flat</span>(val, path ? path + <span class="hljs-string">&quot;.&quot;</span> + key : key);&#125; <span class="hljs-keyword">else</span> &#123;res[path ? path + <span class="hljs-string">&quot;.&quot;</span> + key : key] = val;&#125;&#125;);&#125;<span class="hljs-title function_">flat</span>(obj, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li><p>变量连续赋值</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">a = b = <span class="hljs-number">3</span>;<span class="hljs-comment">// 一般来说执行顺序是</span>b = <span class="hljs-number">3</span>;a = b;<span class="hljs-comment">// 当遇到`.`操作符,操作优先级会高于赋值</span><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">666</span> &#125;;b = a;<span class="hljs-comment">// b : &#123;name:666&#125;</span>a.<span class="hljs-property">x</span> = a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-number">222</span> &#125;;<span class="hljs-comment">// 先执行a.x = &#123;name:222&#125;</span><span class="hljs-comment">// b : &#123;name:666,x:&#123;name:222&#125;&#125;</span><span class="hljs-comment">// 后改变a指针 a = &#123;name:222&#125;</span>a.<span class="hljs-property">x</span>; <span class="hljs-comment">// undefined</span>b.<span class="hljs-property">x</span>; <span class="hljs-comment">// &#123;name:222&#125;</span></code></pre></div></li><li><p>  0.1+0.2==0.3?</p></li></ul><p>js 中一般数字精度有上限（双精度浮点），所以不能用<code>==</code>或者<code>===</code>来比较<code>Number</code>类型.<br>正确的比较方法：<code>Math.abs(0.1+0.2-0.3)&lt;=Number.EPSILON</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC/MVP/MVVM</title>
    <link href="/2022/02/24/mvcmvpmvvm/"/>
    <url>/2022/02/24/mvcmvpmvvm/</url>
    
    <content type="html"><![CDATA[<h3 id="MVCModel-View-Controller"><a href="#MVCModel-View-Controller" class="headerlink" title="MVCModel-View-Controller"></a>MVC<code>Model-View-Controller</code></h3><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-title class_">View</span>-&gt;<span class="hljs-title class_">Controller</span>-&gt;<span class="hljs-title class_">Model</span>^                     ||                     v&lt;---------------------&lt;</code></pre></div><ul><li><code>View</code>可以访问<code>Model</code>,不可避免的会包含一些业务逻辑，导致特定<code>View</code>依赖特定<code>Model</code></li><li>视图的更新逻辑由<code>View</code>自己完成</li><li><code>View</code>监听<code>Model</code>改变的的广播</li><li>用户可以操作<code>View</code>或者直接操作<code>Controller</code></li></ul><h3 id="MVPModel-View-Presenter"><a href="#MVPModel-View-Presenter" class="headerlink" title="MVPModel-View-Presenter"></a>MVP<code>Model-View-Presenter</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">View</span> &lt;--&gt; <span class="hljs-title class_">Presenter</span> &lt;==&gt; <span class="hljs-title class_">Model</span></code></pre></div><ul><li><p><code>View</code> 与 <code>Model</code> 之间通过 <code>Presenter</code>解偶</p></li><li><p>主要的程序逻都在<code>Presenter</code>中，接受<code>Model</code>层的数据，并且处理之后传递给<code>View</code>层，还需要处理<code>View</code>层的用户交互等操作。</p></li><li><p><code>View</code>不部署任何业务逻辑,被动视图，只提供接口</p></li><li><p><code>Model</code>改变的的广播由<code>Presenter</code>监听</p></li></ul><h3 id="MVVMModel-View-ViewModel"><a href="#MVVMModel-View-ViewModel" class="headerlink" title="MVVMModel-View-ViewModel"></a>MVVM<code>Model-View-ViewModel</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">View</span> &lt;==&gt; <span class="hljs-title class_">ViewModel</span> &lt;==&gt; <span class="hljs-title class_">Model</span></code></pre></div><ul><li><code>ViewModel</code>可以理解为是MVP中<code>View</code>的数据模型和<code>Presenter</code>的合体</li><li>以前全部由<code>Presenter</code>负责的<code>View</code>和<code>Model</code>之间数据同步操作交由框架实现双向绑定</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react-beginner</title>
    <link href="/2022/02/24/react_rookie/"/>
    <url>/2022/02/24/react_rookie/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><blockquote><p>构建用户页面的 javascript 库，并不是完整的 MVC 框架</p></blockquote><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h3 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a><code>React.createElement</code></h3><p>JSX 元素只是调用 <code>React.createElement(component, props, ...children)</code> 的语法糖</p><h3 id="ReactDOM-render-element-container-callback"><a href="#ReactDOM-render-element-container-callback" class="headerlink" title="ReactDOM.render(element, container[, callback)"></a><code>ReactDOM.render(element, container[, callback)</code></h3><p>在提供的 <code>container</code> 里渲染一个 React 元素，并返回对该组件的引用（或者针对无状态组件返回 null）。</p><p>如果 React 元素之前已经在 <code>container</code> 里渲染过，这将会对其执行更新操作，并仅会在必要时改变 DOM 以映射最新的 React 元素。</p><p>如果提供了可选的回调函数，该回调将在组件被渲染或更新之后被执行。</p><h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><ul><li>  语法糖，更能体现 react 的声明式特点，逻辑和页面标签写在一起</li><li>  jsx 不是标准的 ECMAScript 语法，babel 编译</li></ul><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> title = (<span class="hljs-comment">// 推荐使用小括号包裹</span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是个title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>);</code></pre></div><ul><li>  jsx 中的属性名驼峰命名</li><li>  <code>&#123;..中可以写js表达式，区别vue的双括号..&#125;</code></li></ul><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// if else</span><span class="hljs-keyword">if</span>()&#123;  <span class="hljs-keyword">return</span> xxx&#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-keyword">return</span> xxx&#125;<span class="hljs-comment">// 三元表达式</span><span class="hljs-keyword">return</span> flag ? (.&lt;dv&gt;..) : (..&lt;dv&gt;.)<span class="hljs-comment">// 逻辑与运算符</span><span class="hljs-keyword">return</span> flag &amp;&amp; (..&lt;dv&gt;.)</code></pre></div><h3 id="循环渲染"><a href="#循环渲染" class="headerlink" title="循环渲染"></a>循环渲染</h3><blockquote><p>key 的作用和 vue 一样用于 diff 时复用节点</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> data = [&#123;&#125;...&#123;&#125;...&#123;&#125;]<span class="hljs-keyword">const</span> list = (  &#123;data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  &#125;)&#125;)</code></pre></div><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li><p>行内样式,双括号</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> title = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &quot;<span class="hljs-attr">red</span>&quot; &#125;&#125;&gt;</span>我是个title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;</code></pre></div></li><li><p>className</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> title = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>我是个title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;</code></pre></div><blockquote><p>组件是 react 一等公民</p></blockquote></li></ul><blockquote><p>组件：复用，独立，组合</p></blockquote><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="函数组件（使用函数创建）"><a href="#函数组件（使用函数创建）" class="headerlink" title="函数组件（使用函数创建）"></a>函数组件（使用函数创建）</h2><ul><li>  大写首字母</li><li>  必须 return</li><li>  包括箭头函数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Com1</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是Com1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Com1</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>));</code></pre></div><blockquote><p>babel 转译后,function 运行在严格模式下,严格模式的 this 指向 null</p></blockquote><h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">-大写首字母 - <span class="hljs-keyword">extends</span>自<span class="hljs-string">`React.Component`</span> - 必须<span class="hljs-keyword">return</span>;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCom2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是Com2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;&#125;</code></pre></div><h2 id="「state」"><a href="#「state」" class="headerlink" title="「state」"></a>「state」</h2><ul><li>  一般写法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Com3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<span class="hljs-attr">xxx</span>:xxx&#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">func1</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">func1</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)  &#125;  <span class="hljs-title function_">func1</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-attr">xxx</span>:xxx)    <span class="hljs-comment">// 需要手动派发 `setState()`</span>  &#125;  <span class="hljs-title function_">render</span>() =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">xxx</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.func1&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xxx</span>&gt;</span></span>&#125;</code></pre></div><ul><li>  使用赋值语句简写</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Com3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;  state = &#123;<span class="hljs-attr">xxx</span>:xxx&#125;  func1 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-attr">xxx</span>:xxx)  &#125;  <span class="hljs-title function_">render</span>() =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">xxx</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.func1&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xxx</span>&gt;</span></span>&#125;</code></pre></div><h2 id="「props」"><a href="#「props」" class="headerlink" title="「props」"></a>「props」</h2><p>组件内部不用声明<code>props</code>,组件实例持有有一个<code>props</code>数组</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Com1</span> <span class="hljs-attr">prop1</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">prop2</span>=<span class="hljs-string">&#123;666&#125;/</span>&gt;</span></span>  )&#125;</code></pre></div><ul><li>  标签属性可以用展开运算符</li><li>  props 校验<a href="https://react.docschina.org/docs/typechecking-with-proptypes.html">https://react.docschina.org/docs/typechecking-with-proptypes.html</a></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Com1</span>.<span class="hljs-property">propTypes</span> = &#123;  <span class="hljs-attr">prop1</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,<span class="hljs-comment">// isRequired</span>  <span class="hljs-attr">prop2</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>  prop3;<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span> <span class="hljs-comment">// function</span>&#125;<span class="hljs-title class_">Com1</span>.<span class="hljs-property">defaultProps</span> = &#123;  <span class="hljs-attr">prop1</span>:<span class="hljs-string">&#x27;xxx&#x27;</span>,  <span class="hljs-attr">prop2</span>:<span class="hljs-number">123</span>&#125;</code></pre></div><ul><li>  同样也可以写在 class 内</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Com3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>&#123;  state = &#123;<span class="hljs-attr">xxx</span>:xxx&#125;  func1 = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-attr">xxx</span>:xxx)  &#125;  <span class="hljs-keyword">static</span> propTypes = &#123;    <span class="hljs-attr">prop1</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,<span class="hljs-comment">// isRequired</span>    <span class="hljs-attr">prop2</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>    <span class="hljs-attr">prop3</span>:<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span> <span class="hljs-comment">// function</span>  &#125;  <span class="hljs-keyword">static</span> defaultProps = &#123;    <span class="hljs-attr">prop1</span>:<span class="hljs-string">&#x27;xxx&#x27;</span>,    <span class="hljs-attr">prop2</span>:<span class="hljs-number">123</span>  &#125;&#125;</code></pre></div><ul><li>  <code>constructor</code>中要使用<code>this.props</code>就必须接收并<code>super</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)&#123;  <span class="hljs-variable language_">super</span>(props)  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>);&#125;</code></pre></div><h3 id="「refs」"><a href="#「refs」" class="headerlink" title="「refs」"></a>「refs」</h3><h4 id="1-字符串形式-过时-API"><a href="#1-字符串形式-过时-API" class="headerlink" title="1.字符串形式( 过时 API )"></a>1.字符串形式( <em>过时 API</em> )</h4><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;xxx ref=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</code></pre></div><h4 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;xxx ref=&#123;<span class="hljs-function"><span class="hljs-params">c</span>=&gt;</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span>=c&#125;&gt;<span class="hljs-comment">// 就能挂载在 实例.input1 上</span></code></pre></div><blockquote><p>组件渲染时先会把 ref 清空(为 null),再赋值</p></blockquote><blockquote><p>使用 class 内绑定函数接收 node 可以避免上述</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript">saveNode = <span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">input1</span> = c<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.saveNode&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span>  )&#125;</code></pre></div><h4 id="3-createRef"><a href="#3-createRef" class="headerlink" title="3.createRef"></a>3.createRef</h4><p>单一 ref 专用</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">input1 = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.input1&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span>  )&#125;<span class="hljs-comment">// this.input1.current</span></code></pre></div><h1 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h1><h2 id="🚮-旧生命周期-lt-16"><a href="#🚮-旧生命周期-lt-16" class="headerlink" title="🚮 旧生命周期(&lt;=16)"></a>🚮 旧生命周期(&lt;=16)</h2><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li>  <code>constructor</code></li><li>  <code>componentWillMount</code></li><li>  <code>render</code></li><li>  <code>componentDidMount</code></li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li>  <code>componentWillReceiveProps</code></li><li>  <code>shouldComponentUpdate</code>&lt;– setState()</li><li>  <code>componentWillUpdate</code>&lt;—- forceUpdate()</li><li>  <code>render</code></li><li>  <code>componentDidUpdate</code></li></ul><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><ul><li>  <code>componentWillUnmount</code></li></ul><h2 id="💡-新生命周期-gt-16"><a href="#💡-新生命周期-gt-16" class="headerlink" title="💡 新生命周期(&gt;16)"></a>💡 新生命周期(&gt;16)</h2><p><img src="../images/react_new.png" alt="生命周期"><br>示意图:<a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p><h3 id="过时钩子"><a href="#过时钩子" class="headerlink" title="过时钩子"></a>过时钩子</h3><ul><li><p><code>UNSAFE_componentWillMount</code></p><blockquote><p>在此方法中同步调用 setState() 不会触发额外渲染</p></blockquote></li><li><p><code>UNSAFE_componentWillReceiveProps</code></p><blockquote><p>在组件接受新的 props 之前调用</p></blockquote></li><li><p>  <code>UNSAFE_componentWillUpdate</code></p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.</span><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>)<span class="hljs-comment">// 2.不常用,仅适用于props派生state的情况,但会在每次render之前调用</span><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(prop,state)<span class="hljs-comment">// 3.纯函数</span>render<span class="hljs-comment">// 4.组件挂载到DOM后</span>componentDidMount</code></pre></div><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//1. 不常用</span><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(prop,state)<span class="hljs-comment">//2.判断是否更新组件，</span><span class="hljs-comment">//  默认行为是true</span><span class="hljs-comment">//  当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用</span><span class="hljs-comment">// 使用forceUpdate可以跳过该方法</span>shouldComponentUpdate = ():boolean<span class="hljs-comment">//3.</span>render<span class="hljs-comment">//4.获取最近一次DOM更新前的DOM信息</span>getSnapshotBeforeUpdate = (prevProps,prevState):snapshot<span class="hljs-comment">//5.</span><span class="hljs-title function_">componentDidUpdate</span>(prevProps,preState,snapshot)</code></pre></div><h3 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h3><ul><li>  <code>componentWillUnmount</code></li></ul><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// /src/setupProxy.js</span><span class="hljs-comment">// CommonJS语法</span><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http-proxy-middleware&quot;</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">app</span>) &#123;app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-string">&quot;/api1&quot;</span>, &#123;<span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://xxxxxx&quot;</span>,<span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Host字段</span><span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&quot;/api1&quot;</span>: <span class="hljs-string">&quot;&quot;</span> &#125;,&#125;));&#125;;</code></pre></div><h1 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h1><ol><li><p><code>Props</code></p></li><li><p><code>PubSubJS</code>发布订阅模式<br><a href="https://github.com/mroderick/PubSubJS">https://github.com/mroderick/PubSubJS</a></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// create a function to subscribe to topics</span><span class="hljs-keyword">var</span> mySubscriber = <span class="hljs-keyword">function</span> (<span class="hljs-params">msg, data</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg, data);&#125;;   <span class="hljs-comment">// add the function to the list of subscribers for a particular topic</span><span class="hljs-comment">// we&#x27;re keeping the returned token, in order to be able to unsubscribe</span><span class="hljs-comment">// from the topic later on</span><span class="hljs-keyword">var</span> token = <span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-string">&quot;MY TOPIC&quot;</span>, mySubscriber);   <span class="hljs-comment">// publish a topic asynchronously</span><span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">publish</span>(<span class="hljs-string">&quot;MY TOPIC&quot;</span>, <span class="hljs-string">&quot;hello world!&quot;</span>);   <span class="hljs-comment">// publish a topic synchronously, which is faster in some environments,</span><span class="hljs-comment">// but will get confusing when one topic triggers new topics in the</span><span class="hljs-comment">// same execution chain</span><span class="hljs-comment">// USE WITH CAUTION, HERE BE DRAGONS!!!</span><span class="hljs-title class_">PubSub</span>.<span class="hljs-title function_">publishSync</span>(<span class="hljs-string">&quot;MY TOPIC&quot;</span>, <span class="hljs-string">&quot;hello world!&quot;</span>);</code></pre></div></li><li><p><code>Context</code></p><blockquote><p>类似 vue 的 provide 和 inject</p></blockquote> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//祖先组件中</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext1</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue);<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext2</span>  = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(defaultValue);<span class="hljs-comment">// defaultValue在不传value时生效</span><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> (    <span class="hljs-comment">// value应使用state属性避免意外的consumer更新</span>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Mycontext1.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#125;</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyContext2.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#125;</span>&gt;</span></span><span class="language-xml">        ...<span class="hljs-tag">&lt;<span class="hljs-name">children</span> /&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">MyContext2.Provider</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Mycontext1.Provider</span>&gt;</span></span>  )&#125;</code></pre></div> <div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 子组件中</span><span class="hljs-comment">// class</span><span class="hljs-keyword">static</span> contextType = <span class="hljs-title class_">MyContext1</span><span class="hljs-comment">//只适用于消费一个context的情况</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span><span class="hljs-comment">//取值</span><span class="hljs-comment">// class&amp;hooks</span>&lt;<span class="hljs-title class_">MyContext2</span>.<span class="hljs-property">Consumer</span>&gt;  &#123;    <span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>(      <span class="hljs-comment">// render...</span>    )  &#125;&lt;/<span class="hljs-title class_">MyContext2</span>.<span class="hljs-property">Consumer</span>&gt;</code></pre></div></li><li><p><code>Redux</code></p></li></ol><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="根路由标签"><a href="#根路由标签" class="headerlink" title="根路由标签"></a>根路由标签</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BrowserRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HashRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">BrowserRouter</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">BrowserRouter</span>&gt;</span></span><span class="language-xml">/* <span class="hljs-tag">&lt;<span class="hljs-name">HashRouter</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">HashRouter</span>&gt;</span> */</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span>,<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>));</code></pre></div><h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/xxx&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;ComXXX1&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;ComXXX2&#125;&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- ComXXX1 ComXXX2都渲染 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span>&lt;/Route&gt;</code></pre></div><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Switch</span>&gt;</span>/* Switch标签内只会渲染第一个匹配成功的组件 */<span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;Home&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;About&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/:user&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;User&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;NoMatch&#125;&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Switch</span>&gt;</span></code></pre></div><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&quot;&#123;ComXXX1&#125;&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 严格匹配 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></code></pre></div><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><ul><li><code>match</code><ul><li>  ⭐️<code>params</code> - (object) key／value 与动态路径的 URL 对应解析</li></ul></li><li><code>location</code><ul><li>  <code>pathname</code> - (string 类型) URL 路径</li><li>  ⭐️<code>search</code>- (string 类型) URL 中的查询字符串</li><li>  <code>hash</code> - (string 类型) URL 的哈希片段</li><li>  ⭐️<code>state </code>- (object 类型) 提供给例如使用 push(path, state) 操将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用。</li></ul></li><li>  <code>history</code></li></ul><h3 id="URL-传-params"><a href="#URL-传-params" class="headerlink" title="URL 传 params"></a>URL 传 params</h3><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=`/<span class="hljs-attr">xxx</span>/$&#123;<span class="hljs-attr">xxx.param1</span>&#125;`&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx/param1:param1&quot;</span>&gt;</span> // props.match.params // &#123;param1:xxx&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></code></pre></div><h3 id="URL-传-search"><a href="#URL-传-search" class="headerlink" title="URL 传 search"></a>URL 传 search</h3><p>使用<code>querrystring</code>处理 urlencode</p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=`/<span class="hljs-attr">xxx</span>?<span class="hljs-attr">param1</span>=<span class="hljs-string">$&#123;xxx.param1&#125;&amp;param2</span>=<span class="hljs-string">$&#123;xxx.param2&#125;</span>`&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span>&gt;</span>// props.location.search // &quot;?param1=xxx&amp;param1=xxx&quot; // qs.parse(props.location.search.slice(1)) =&gt; &#123;...&#125;&lt;/Route&gt;</code></pre></div><h3 id="传-state"><a href="#传-state" class="headerlink" title="传 state"></a>传 state</h3><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&#123;&#123;pathname:</span>&#x27;/<span class="hljs-attr">xxx</span>&#x27;,<span class="hljs-attr">state:</span>&#123;<span class="hljs-attr">param1:xxx.param1</span>&#125;&#125;&#125;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span>&gt;</span> // props.location.state<span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span></code></pre></div><h2 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h2><p><code>this.props.history</code></p><ul><li><code>history</code><ul><li>  <code>go</code>(n) - (function 类型) 将 history 堆栈中的指针调整 n</li><li>  <code>goBack</code>() - (function 类型) 等同于 go(-1)</li><li>  <code>goForward</code>() - (function 类型) 等同于 go(1)</li><li>  <code>push</code>(path, [state]) - (function 类型) 在 history 堆栈添加个新目</li><li>  <code>replace</code>(path, [state]) - (function 类型) 替换在 history 堆中的</li></ul></li></ul><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h2><p>可以通过 <code>withRouter</code> 高阶组件访问 <code>history</code> 对象的属性和最近的 <code>&lt;Route&gt;</code> 的 <code>match</code> 。 当路由渲染时， <code>withRouter</code> 会将已经更新的 <code>match</code> ， <code>location</code> 和 <code>history</code> 属性传递给被包裹的组件。</p><h1 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h1><ul><li><code>antd</code>的样式按需引入<br>  (<a href="https://3x.ant.design/docs/react/use-with-create-react-app-cn)[https://3x.ant.design/docs/react/use-with-create-react-app-cn]">https://3x.ant.design/docs/react/use-with-create-react-app-cn)[https://3x.ant.design/docs/react/use-with-create-react-app-cn]</a></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// ./config-overrides.js</span><span class="hljs-keyword">const</span> &#123; override, fixBabelImports, addLessLoader &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">`customize-cra`</span>);<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">override</span>(<span class="hljs-title function_">fixBabelImports</span>(<span class="hljs-string">&quot;import&quot;</span>, &#123;<span class="hljs-attr">libraryName</span>: <span class="hljs-string">&quot;antd&quot;</span>,<span class="hljs-attr">libraryDirectory</span>: <span class="hljs-string">&quot;es&quot;</span>,<span class="hljs-attr">style</span>: <span class="hljs-literal">true</span>,&#125;));</code></pre></div><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><ul><li><code>action</code><ul><li>  同步<code>action&lt;object&gt;</code></li><li>异步<code>action&lt;function&gt;</code><br>  原生只能处理同步 action,action 中的 switch 机制</li></ul></li><li>  <code>reducer</code></li><li><code>store</code><ul><li>  <code>dispatch</code></li><li>  <code>subscribe</code></li></ul></li></ul><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><ul><li><p><code>reducer</code><br>  reducer 是一个纯函数:接收 <code>Action</code> 和 <code>State</code> 并作为参数，通过计算得到新的<code>Store</code></p><blockquote><p>纯函数:</p><ol><li>不修改参数</li><li>不产生副作用</li><li>不调用不纯的方法<code>Math.random()``new Date()</code></li></ol></blockquote>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> initState = <span class="hljs-number">0</span>;interface <span class="hljs-title class_">Action</span> &#123;<span class="hljs-attr">type</span>: string;<span class="hljs-attr">data</span>: number;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">countReducer</span>(<span class="hljs-params">preState = initState, action: Action</span>) &#123;<span class="hljs-keyword">const</span> &#123; type, data &#125; = action;<span class="hljs-keyword">switch</span> (type) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;increment&quot;</span>:<span class="hljs-keyword">return</span> preState + data;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:<span class="hljs-keyword">return</span> preState - data;<span class="hljs-attr">default</span>:<span class="hljs-keyword">return</span> preState;&#125;&#125;</code></pre></div></li><li><p><code>connect API</code></p><p>  使用哟 container 包裹 ui 组件,container 负责与 store 的交互,操作和数据通过 props 传给 ui 组件.</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// container.ts</span><span class="hljs-keyword">import</span> &#123; connect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-redux&quot;</span>;<span class="hljs-keyword">import</span> xx组件 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../XXX&quot;</span>;<span class="hljs-keyword">import</span> &#123;action1,action2&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../redux/ACTIONS&quot;</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">mapStateToProps</span>(<span class="hljs-params">state,ownProps</span>) &#123;  <span class="hljs-comment">// 将store中的state映射为props</span>  <span class="hljs-comment">// ⭐️该函数必须是同步的</span>  <span class="hljs-keyword">return</span> &#123;    ...    <span class="hljs-attr">prop1</span>:state.<span class="hljs-property">someState</span>  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">mapDispatchToProps</span>(<span class="hljs-params">dispatch</span>)&#123;  <span class="hljs-comment">// 映射dispatch为props</span>  <span class="hljs-keyword">return</span>&#123;    ...    <span class="hljs-attr">func1</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;someType&#x27;</span>&#125;)  &#125;&#125;<span class="hljs-keyword">const</span> <span class="hljs-title class_">CountContainer</span> = <span class="hljs-title function_">connect</span>(mapStateToProps,mapDispatchToProps)(xx组件);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CountContainer</span>;</code></pre></div></li><li><p><code>多个reducer</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// store.ts</span><span class="hljs-keyword">import</span> &#123; createStore, applyMiddleware, combineReducers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;redux&quot;</span>;<span class="hljs-keyword">import</span> countReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reducers/count&quot;</span>;<span class="hljs-keyword">import</span> peopleReducer <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./reducers/peolple&quot;</span>;<span class="hljs-keyword">const</span> allReducer = <span class="hljs-title function_">combineReducers</span>(&#123;<span class="hljs-attr">count</span>: countReducer,<span class="hljs-attr">people</span>: peopleReducer,&#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(allReducer);</code></pre></div></li></ul><h2 id="异步-Action"><a href="#异步-Action" class="headerlink" title="异步 Action"></a>异步 Action</h2><p>通过 Redux 的中间件(middleware)实现异步<code>Action</code>;</p><ul><li>  <code>redux-thunk</code>等中间件可以让你提供一个拦截器在 <code>Reducer</code> 处理 <code>Action</code> 之前被调用;</li><li>  在这个拦截器中，你可以自由处理获得的 Action;</li><li>  如果 Action 是个函数，<code>redux-thunk</code>将会尝试先执行函数而不是传给<code>Reducer</code>，并<code>dispatch</code>传给这个函数。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"></code></pre></div><h2 id="redux-devtools"><a href="#redux-devtools" class="headerlink" title="redux-devtools"></a>redux-devtools</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">yarn add redux-devtools-extension<span class="hljs-comment">// store.ts</span><span class="hljs-keyword">import</span> &#123; composeWithDevtools&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-devtools-extension&#x27;</span>...<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">createStore</span>(  allReducer, <span class="hljs-title function_">composeWithDevtools</span>(<span class="hljs-title function_">applyMiddleware</span>(thunk)))</code></pre></div><h2 id="减少样板代码"><a href="#减少样板代码" class="headerlink" title="减少样板代码"></a>减少样板代码</h2><ul><li><p>redux-actions<br>  <a href="https://github.com/redux-utilities/redux-actions">https://github.com/redux-utilities/redux-actions</a><br>  协助生成 action creator</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createAction &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-actions&#x27;</span>...<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">createAction</span>(<span class="hljs-string">&#x27;INCREMENT&#x27;</span>)<span class="hljs-keyword">import</span> &#123; handleActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-action&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">handleActions</span>(&#123;  <span class="hljs-attr">INCREMENT</span>:<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state + <span class="hljs-number">1</span>&#125;,<span class="hljs-number">0</span>)</code></pre></div></li><li><p>  cli(yeoman)</p></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><ul><li><p>对象式</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">setState</span>(<span class="hljs-string">`stateChange(状态改变对象)`</span>, [callBack]);</code></pre></div></li><li><p>函数式</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">setState</span>(<span class="hljs-string">`updater(返回stateChange对象的函数)`</span>,[callback])<span class="hljs-keyword">function</span> <span class="hljs-title function_">updater</span>(<span class="hljs-params">state,props</span>)&#123;  ... 接收state和props参数&#125;</code></pre></div></li><li><p>  <code>callback</code>在<code>render()</code>后调用</p></li></ul><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p><code>React.lazy</code>使用 dynamic import 标准,返回一个 promise,在 pending 状态期间渲染 loading 组件</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;lazy,<span class="hljs-title class_">Suspense</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">Com1</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./Com1/index&#x27;</span>)&#125;)<span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/com1&quot;</span>&gt;</span>Com1<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span></span>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Loading</span> /&gt;</span>&#125;&gt;</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/com1&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Com1&#125;</span> /&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>  )&#125;</code></pre></div><h2 id="JSX-Fragment"><a href="#JSX-Fragment" class="headerlink" title="JSX Fragment"></a>JSX Fragment</h2><blockquote><p>代替根 div</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs html">import &#123; Fragment &#125;&gt; from &#x27;react`<span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span><span class="hljs-comment">&lt;!-- 可以拥有key --&gt;</span><span class="hljs-comment">&lt;!-- 短语法 --&gt;</span><span class="hljs-tag">&lt;&gt;</span>...<span class="hljs-tag">&lt;/&gt;</span></code></pre></div><h2 id="子组件更新"><a href="#子组件更新" class="headerlink" title="子组件更新"></a>子组件更新</h2><blockquote><p>一般子组件即使 props 没改变或者没接受 props 也会随父组件 rerender</p></blockquote><p><code>PureComponent</code>**_<strong>浅层</strong>_**比较<code>props</code>和<code>state</code>,同时<code>shouldComponentUpdate</code> 将跳过所有子组件树的 <code>prop</code> 更新</p><h2 id="组件-composition"><a href="#组件-composition" class="headerlink" title="组件 composition"></a>组件 composition</h2><blockquote><p>组件可以接受任意 props，包括基本数据类型</p></blockquote><blockquote><p>将 jsx 元素以及函数通过 props 传递实现类似 vue slot 效果</p></blockquote><blockquote><p>向组件内部动态传入内容</p></blockquote><ol><li><code>.children</code>获得组件标签内内容</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyBorder</span>(<span class="hljs-params">props</span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">FancyBorder</span> <span class="hljs-attr">FancyBorder-</span>&quot; + <span class="hljs-attr">props.color</span>&#125;&gt;</span>&#123;props.children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">WelcomeDialog</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-title&quot;</span>&gt;</span>Welcome<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Dialog-message&quot;</span>&gt;</span>Thank you for visiting our spacecraft!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span>);&#125;</code></pre></div><ol start="2"><li>或者使用约定名称</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SplitPane</span>(<span class="hljs-params">props</span>) &#123;<span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane-left&quot;</span>&gt;</span>&#123;props.left&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;SplitPane-right&quot;</span>&gt;</span>&#123;props.right&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SplitPane</span> <span class="hljs-attr">left</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Contacts</span> /&gt;</span>&#125; right=&#123;<span class="hljs-tag">&lt;<span class="hljs-name">Chat</span> /&gt;</span>&#125; /&gt;</span>;&#125;</code></pre></div><ol start="3"><li>通过 props 传递携带另一个 props 的函数</li></ol><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">A</span> <span class="hljs-attr">customizeFn</span>=<span class="hljs-string">&#123;(p1)</span>=&gt;</span>&#123;<span class="hljs-tag">&lt;<span class="hljs-name">B</span> <span class="hljs-attr">p1</span>=<span class="hljs-string">&#123;p1&#125;/</span>&gt;</span>&#125;&#125;/&gt;</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">const</span> [state,changeState] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">123</span>)  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是A组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    &#123;props.<span class="hljs-title function_">customizeFn</span>(state)&#125;  )&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params">props</span>)&#123;  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是B我收到了&#123;props.p1&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  )&#125;</code></pre></div><h2 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h2><p>错误边界是一种 React 组件，这种组件可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI，而并不会渲染那些发生崩溃的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) &#123;  <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;&#125;<span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) &#123;  <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>  <span class="hljs-title function_">logErrorToMyService</span>(error, errorInfo);&#125;</code></pre></div><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="React的性能优化"><a href="#React的性能优化" class="headerlink" title="React的性能优化"></a>React的性能优化</h3><ol><li><code>useCallback</code>管理函数的再执行</li><li><code>useMemo</code>管理值的计算</li><li><code>PureComponent</code>浅层比较<code>state</code>和<code>prop</code>不重复渲染</li><li><code>React.memo</code>浅层比较<code>prop</code></li><li><code>lazy</code>+<code>Suspense</code> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;lazy,<span class="hljs-title class_">Suspense</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">lazyComponent</span> = (<span class="hljs-params"></span>) =&gt; &#123;  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Com</span> = <span class="hljs-title function_">lazy</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title function_">import</span>(<span class="hljs-comment">/* webpackChunkName:&quot; 自定义chunk名&quot; */</span><span class="hljs-string">&#x27;./xxx.js&#x27;</span>))  <span class="hljs-keyword">return</span> (    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;&gt;</span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Com</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span><span class="language-xml">  )</span><span class="language-xml">&#125;</span></code></pre></div></li><li>使用<code>Fragment</code>标签<code>&lt;&gt;&lt;/&gt;</code></li><li>不要使用内联函数 <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;input onClick=&#123;<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>)&#125;&#125;&gt;&lt;/input&gt;</code></pre></div></li><li>注意<code>Context provide</code>触发的渲染无法避免</li><li>类组件中不使用箭头函数绑定<code>this</code></li><li>避免使用内联样式<code>style = &#123;&#125;</code></li><li>设定错误边界</li><li>避免数据突变</li><li><code>Redux connect</code>中给组件传的<code>state</code>都会触发渲染</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量导入</title>
    <link href="/2022/02/24/require.context%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/02/24/require.context%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>自动化注册组件</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// global.js</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> upperFirst <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/upperFirst&#x27;</span><span class="hljs-keyword">import</span> camelCase <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/camelCase&#x27;</span><span class="hljs-keyword">const</span> requireComponent = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(  <span class="hljs-comment">// 其组件目录的相对路径</span>  <span class="hljs-comment">// 全局注册的目录</span>  .,  <span class="hljs-comment">// 是否查询其子目录</span>  <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 匹配基础组件文件名的正则表达式</span>  <span class="hljs-comment">// /Base[A-Z]\w+\.(vue|js)$/</span>  <span class="hljs-regexp">/\.vue$/</span>)requireComponent.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fileName</span> =&gt;</span> &#123;  <span class="hljs-comment">// 获取组件配置</span>  <span class="hljs-keyword">const</span> componentConfig = requireComponent(fileName)  <span class="hljs-comment">// 获取组件的 PascalCase 命名</span>  <span class="hljs-keyword">const</span> componentName = <span class="hljs-title function_">upperFirst</span>(    <span class="hljs-title function_">camelCase</span>(      <span class="hljs-comment">// 获取和目录深度无关的文件名</span>      fileName        <span class="hljs-comment">// .split(&#x27;/&#x27;)</span>        <span class="hljs-comment">// .pop()</span>        .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\.\//</span>,<span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// ‘./ComA.vue’ =&gt; &#x27;ComA.vue&#x27;</span>        .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\.\w+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)        <span class="hljs-comment">// =&gt; &#x27;ComA&#x27;</span>    )  )  <span class="hljs-comment">// 全局注册组件</span>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(    componentName,    <span class="hljs-comment">// 如果这个组件选项是通过 `export default` 导出的，</span>    <span class="hljs-comment">// 那么就会优先使用 `.default`，</span>    <span class="hljs-comment">// 否则回退到使用模块的根。</span>    componentConfig.<span class="hljs-property">default</span> || componentConfig  )&#125;)</code></pre></div></li><li><p>自动化注册路由</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// router.js</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<span class="hljs-keyword">const</span> routerList = []<span class="hljs-keyword">const</span> <span class="hljs-title function_">importAllRouter</span> = r =&gt; &#123;  r.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span>=&gt;</span>&#123;    routerList.<span class="hljs-title function_">push</span>(r[key].<span class="hljs-property">default</span>  <span class="hljs-comment">/*export default*/</span>)  &#125;)&#125;<span class="hljs-title function_">importAllRouter</span>(<span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(.<span class="hljs-comment">/* 查询目录*/</span>,<span class="hljs-literal">true</span><span class="hljs-comment">/*是否包含子目录*/</span>,<span class="hljs-regexp">/\.router\.js/</span><span class="hljs-regexp">/*匹配正则*/</span>))<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;  ...routerList&#125;)</code></pre></div></li><li><p>管理 graph 文件（同理）</p><p>  <img src="https://s2.loli.net/2022/01/04/YoxB7hS6sZDEapr.png"></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> context = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.gql$|\.graphql$/</span>);<span class="hljs-keyword">const</span> map = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> context.<span class="hljs-title function_">keys</span>()) &#123;  <span class="hljs-keyword">const</span> keyArr = key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;/&quot;</span>);  keyArr.<span class="hljs-title function_">shift</span>();  <span class="hljs-keyword">const</span> _key = keyArr[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 删掉文件夹名</span>  map[_key.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\.gql$|\.graphql$/g</span>, <span class="hljs-string">&quot;&quot;</span>)] = <span class="hljs-title function_">context</span>(key);&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> map;</code></pre></div></li></ul><ul><li><p>vite中的批量导入</p><p><a href="https://github.com/mrmlnc/fast-glob">fast-glob</a></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 异步</span><span class="hljs-keyword">const</span> path = <span class="hljs-string">&#x27;./*.js&#x27;</span><span class="hljs-keyword">import</span> modules = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(path)<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(modules).<span class="hljs-title function_">forEach</span>([k,v]=&gt;&#123;  <span class="hljs-title function_">v</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span>=&gt;</span>m.<span class="hljs-property">default</span>)&#125;)</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//同步</span><span class="hljs-keyword">import</span> modules = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">globEager</span>(path)<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(modules).<span class="hljs-title function_">forEach</span>([k,v]=&gt;&#123;  <span class="hljs-title function_">v</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">m</span>=&gt;</span>m.<span class="hljs-property">default</span>)  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k,v.<span class="hljs-property">default</span>)&#125;)</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>svg图标封装组件</title>
    <link href="/2022/02/24/svg%E5%9B%BE%E6%A0%87%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/02/24/svg%E5%9B%BE%E6%A0%87%E5%B0%81%E8%A3%85%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>VUE项目中将svg图标封装为组件,后续拷贝进svg文件直接使用</p></blockquote><h3 id="icon组件"><a href="#icon组件" class="headerlink" title="icon组件"></a>icon组件</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;svgClass&quot;</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span> </span></span><span class="hljs-tag"><span class="language-xml"></span></span><span class="hljs-tag"><span class="language-xml">  // /* <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">&quot;true&quot;</span>将元素从可访问树上移除 */</span></span><span class="hljs-tag"><span class="language-xml"></span></span><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">:xlink:href</span>=<span class="hljs-string">&quot;iconName&quot;</span> /&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span>&lt;/template&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;SvgIcon&#x27;</span>,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">iconClass</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">className</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">iconName</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-string">`#icon-<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.iconClass&#125;</span>`</span></span></span><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">svgClass</span>(<span class="hljs-params"></span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">className</span>) &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;svg-icon &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">className</span></span></span><span class="language-javascript"><span class="language-xml">      &#125; <span class="hljs-keyword">else</span> &#123;</span></span><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;svg-icon&#x27;</span></span></span><span class="language-javascript"><span class="language-xml">      &#125;</span></span><span class="language-javascript"><span class="language-xml">    &#125;</span></span><span class="language-javascript"><span class="language-xml">  &#125;</span></span><span class="language-javascript"><span class="language-xml">&#125;</span></span><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.svg-icon</span> &#123;</span></span><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">width</span>: <span class="hljs-number">1em</span>;</span></span><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">height</span>: <span class="hljs-number">1em</span>;</span></span><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">vertical-align</span>: -<span class="hljs-number">0.15em</span>;</span></span><span class="language-css"><span class="language-xml">  fill: currentColor;</span></span><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">overflow</span>: hidden;</span></span><span class="language-css"><span class="language-xml">&#125;</span></span><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span></code></pre></div><h3 id="配置自动引入svg文件"><a href="#配置自动引入svg文件" class="headerlink" title="配置自动引入svg文件"></a>配置自动引入svg文件</h3><p>使用<code>webpack</code>的<code>require.context</code>API，两种方法</p><blockquote><p><code>assets/icon</code>是存放<code>svg</code>图标文件的路径</p></blockquote><ol><li>在<code>assets/icon</code>新建<code>index.js</code></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">SvgIcon</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/SvgIcon&#x27;</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;svg-icon&#x27;</span>, <span class="hljs-title class_">SvgIcon</span>)<span class="hljs-keyword">const</span> <span class="hljs-title function_">importAll</span> = r =&gt; r.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(r)<span class="hljs-keyword">const</span> svgContext = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&#x27;@/assets/icon&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>);<span class="hljs-comment">// 获取该目录下所有.svg的context</span><span class="hljs-title function_">importAll</span>(svgContext)<span class="hljs-comment">//在main.js中导入</span><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/assets/icon/index&#x27;</span></code></pre></div><ol start="2"><li>或者直接在<code>main.js</code>中</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">SvgIcon</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/SvgIcon&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">importAll</span> = r =&gt; r.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(r)<span class="hljs-keyword">const</span> svgContext = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&#x27;@/assets/icon&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.svg$/</span>);<span class="hljs-comment">// 获取该目录下所有.svg的context</span><span class="hljs-title function_">importAll</span>(svgContext)<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;svg-icon&#x27;</span>,<span class="hljs-title class_">SvgIcon</span>) <span class="hljs-comment">// 全局注册</span></code></pre></div><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><ul><li><code>svg-baker-runtime</code></li><li><code>svg-sprite-loader</code></li><li>配置<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// vue.config.js</span><span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> svgRule = config.<span class="hljs-property">module</span>.<span class="hljs-title function_">rule</span>(<span class="hljs-string">&quot;svg&quot;</span>);  svgRule.<span class="hljs-property">uses</span>.<span class="hljs-title function_">clear</span>();  svgRule    .<span class="hljs-title function_">rule</span>(<span class="hljs-string">&quot;icons&quot;</span>)    .<span class="hljs-title function_">test</span>(<span class="hljs-regexp">/\.svg$/</span>)    .<span class="hljs-property">include</span>.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;src/assets/icon&quot;</span>))    .<span class="hljs-title function_">end</span>()    .<span class="hljs-title function_">use</span>(<span class="hljs-string">&quot;svg-sprite-loader&quot;</span>)    .<span class="hljs-title function_">loader</span>(<span class="hljs-string">&quot;svg-sprite-loader&quot;</span>)    .<span class="hljs-title function_">options</span>(&#123;      <span class="hljs-attr">symbolId</span>: <span class="hljs-string">&quot;[name]&quot;</span>,    &#125;);&#125;,</code></pre></div></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>尺寸可以自己覆盖样式</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;svg-icon  :icon-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;cardData.platform&quot;</span>  style=<span class="hljs-string">&quot;width: 2em; height: 2em;vertical-align:middle&quot;</span>&gt;&lt;/svg-icon&gt;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>topK问题</title>
    <link href="/2022/02/24/topK/"/>
    <url>/2022/02/24/topK/</url>
    
    <content type="html"><![CDATA[<h2 id="最大-小的-K-个数，第-K-个最大-最小值"><a href="#最大-小的-K-个数，第-K-个最大-最小值" class="headerlink" title="最大/小的 K 个数，第 K 个最大/最小值"></a>最大/小的 K 个数，第 K 个最大/最小值</h2><ul><li><p>局部冒泡<br>！！输出结果无序</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr, k</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;    <span class="hljs-comment">// 冒泡执行k次</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt; i; j--) &#123;      <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;        [arr[j], arr[j - <span class="hljs-number">1</span>]] = [arr[j - <span class="hljs-number">1</span>], arr[j]];      &#125;    &#125;  &#125;&#125;<span class="hljs-comment">// K相当于冒泡次数</span><span class="hljs-comment">//前k个小值</span>data.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, k);<span class="hljs-comment">//第k小的值</span>data[k - <span class="hljs-number">1</span>];</code></pre></div></li><li><p>堆排序</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// topk</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapObj</span>(<span class="hljs-params">items,k</span>)&#123;  <span class="hljs-keyword">const</span> heap = [,...items.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,k)]  <span class="hljs-keyword">const</span> heapSize = k  <span class="hljs-title function_">buildHeap</span>(heap,heapSize)  <span class="hljs-comment">// 求大值，建立最小堆</span>  <span class="hljs-comment">// 后续与最小堆堆顶比较</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt; items.<span class="hljs-property">length</span> ; j++)&#123;    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; items[j])&#123;      <span class="hljs-comment">// 如果大于最小</span>      <span class="hljs-comment">// 作为堆顶的新值，调整堆</span>      heap[<span class="hljs-number">1</span>] = items[j]      <span class="hljs-title function_">heapify</span>(heap,heapSize,<span class="hljs-number">1</span>)    &#125;  &#125;  <span class="hljs-keyword">return</span> heap.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 前k个大值</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)&#123;  <span class="hljs-keyword">if</span>(heapSize === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(heapSize/<span class="hljs-number">2</span>) ; i &gt; <span class="hljs-number">0</span> ; i --)&#123;    <span class="hljs-title function_">heapify</span>(items,heapSize,i)  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i] &lt; items[i]) minIndex = <span class="hljs-number">2</span>*i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; items[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span>(minIndex===i) <span class="hljs-keyword">break</span>    [items[i],items[minIndex]] = [items[minIndex],items[i]]    i = minIndex  &#125;&#125;</code></pre></div><ul><li>快速选择<blockquote><p>快排的改装</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 第k大的元素</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr,k</span>)&#123;  <span class="hljs-keyword">return</span> <span class="hljs-title function_">quick</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>,k)  <span class="hljs-keyword">function</span> <span class="hljs-title function_">quick</span>(<span class="hljs-params">arr,l,r,k</span>)&#123;    <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">partition</span>(arr,l,r)    <span class="hljs-comment">// 这里开始和一般快排不同</span>    <span class="hljs-comment">// 第k大的值，索引为k-1</span>    <span class="hljs-comment">// partition选出的位置与这个k比较</span>    <span class="hljs-comment">// 根据pivot与k-1的相对位置，每次只用继续partition一半</span>    <span class="hljs-keyword">if</span>(index === k-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> arr[index]    &#125;    <span class="hljs-keyword">if</span>(index &gt; k-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">quick</span>(arr,l,index-<span class="hljs-number">1</span>,k)    &#125;    <span class="hljs-keyword">if</span>(index &lt; k-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">quick</span>(arr,index+<span class="hljs-number">1</span>,r,k)    &#125;  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">arr,l,r</span>)&#123;  <span class="hljs-keyword">const</span> pivot = arr[r]  <span class="hljs-keyword">let</span> i = l  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = l;j&lt;r;j++)&#123;    <span class="hljs-keyword">if</span>(arr[j]&lt;pivot)&#123;      [arr[j],arr[i]] = [arr[i],arr[j]]      i++    &#125;  &#125;  [arr[i],arr[r]] = [arr[r],arr[i]]  <span class="hljs-keyword">return</span> i &#125;</code></pre></div></li></ul><h2 id="出现最多-最少的-K-个元素"><a href="#出现最多-最少的-K-个元素" class="headerlink" title="出现最多/最少的 K 个元素"></a>出现最多/最少的 K 个元素</h2><ul><li>傻瓜 map 映射一个 arr 进行排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showMost</span>(<span class="hljs-params">arr, k</span>) &#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();  <span class="hljs-keyword">const</span> ret = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];  arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(num)) &#123;      map.<span class="hljs-title function_">set</span>(num, map.<span class="hljs-title function_">get</span>(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.<span class="hljs-title function_">set</span>(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  ret.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> map.<span class="hljs-title function_">get</span>(b) - map.<span class="hljs-title function_">get</span>(a));  <span class="hljs-keyword">return</span> ret.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, k);&#125;</code></pre></div><ul><li>map 映射堆排序</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showMost</span>(<span class="hljs-params">arr, k</span>) &#123;  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();  <span class="hljs-keyword">const</span> heap = [,];  arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(num)) &#123;      map.<span class="hljs-title function_">set</span>(num, map.<span class="hljs-title function_">get</span>(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.<span class="hljs-title function_">set</span>(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span> (map.<span class="hljs-property">size</span> &lt;= k) <span class="hljs-keyword">return</span> [...map.<span class="hljs-title function_">keys</span>()];  <span class="hljs-comment">//k大于元素数，直接输出</span>  <span class="hljs-keyword">let</span> times = <span class="hljs-number">1</span>;  <span class="hljs-comment">//记数器</span>  <span class="hljs-comment">//小于k的部分直接建立堆，大于的部分开始与堆top比较</span>  map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (times &lt;= k) &#123;      heap.<span class="hljs-title function_">push</span>(key);      <span class="hljs-keyword">if</span> (times === k) &#123;        <span class="hljs-comment">//堆化</span>        <span class="hljs-title function_">buildHeap</span>(heap, map, k);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">get</span>(heap[<span class="hljs-number">1</span>]) &lt; value) &#123;      <span class="hljs-comment">// 与小顶堆顶交换</span>      heap[<span class="hljs-number">1</span>] = key;      <span class="hljs-title function_">heapify</span>(heap, map, k, <span class="hljs-number">1</span>);    &#125;    times++;  &#125;);  <span class="hljs-keyword">function</span> <span class="hljs-title function_">buildHeap</span>(<span class="hljs-params">heap, map, heapSize</span>) &#123;    <span class="hljs-keyword">if</span> (k === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(heapSize / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">1</span>; i--) &#123;      <span class="hljs-title function_">heapify</span>(heap, map, heapSize, i);    &#125;  &#125;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">heap, map, heapSize, i</span>) &#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">let</span> minIndex = i;      <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i &lt;= heapSize &amp;&amp; map.<span class="hljs-title function_">get</span>(heap[<span class="hljs-number">2</span> * i]) &lt; map.<span class="hljs-title function_">get</span>(heap[minIndex]))        minIndex = <span class="hljs-number">2</span> * i;      <span class="hljs-keyword">if</span> (        <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;= heapSize &amp;&amp;        map.<span class="hljs-title function_">get</span>(heap[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>]) &lt; map.<span class="hljs-title function_">get</span>(heap[minIndex])      )        minIndex = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      <span class="hljs-title function_">swap</span>(heap, minIndex, i);      i = minIndex;    &#125;  &#125;  heap.<span class="hljs-title function_">shift</span>();  <span class="hljs-keyword">return</span> heap;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">swap</span>(<span class="hljs-params">data, l, r</span>) &#123;  <span class="hljs-keyword">let</span> temp = data[l];  data[l] = data[r];  data[r] = temp;&#125;</code></pre></div><ul><li>桶排序</li></ul><p>出现次数最多的前k个数</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showMost</span>(<span class="hljs-params">arr,k</span>)&#123;  <span class="hljs-comment">// 记录各数字出现次数</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()  arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(num)) &#123;      map.<span class="hljs-title function_">set</span>(num, map.<span class="hljs-title function_">get</span>(num) + <span class="hljs-number">1</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      map.<span class="hljs-title function_">set</span>(num, <span class="hljs-number">1</span>);    &#125;  &#125;);  <span class="hljs-keyword">if</span>(map.<span class="hljs-property">size</span>&lt;=k) <span class="hljs-keyword">return</span> [...map.<span class="hljs-title function_">keys</span>()]  <span class="hljs-keyword">return</span> <span class="hljs-title function_">buckerSort</span>(map,k)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">buckerSort</span>(<span class="hljs-params">map,k</span>)&#123;  <span class="hljs-comment">// 按照出现次数作为arr数组下标划分桶</span>  <span class="hljs-comment">// 将数字放入桶中</span>  <span class="hljs-keyword">let</span> arr = []  <span class="hljs-keyword">let</span> res = []  map.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,key</span>)=&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!arr[value])&#123;      arr[value] = [key]    &#125;<span class="hljs-keyword">else</span>&#123;      arr[value].<span class="hljs-title function_">push</span>(key)    &#125;    <span class="hljs-comment">// 出现了value次的数字有...</span>  &#125;)  <span class="hljs-comment">// 逆向遍历桶数组</span>  <span class="hljs-comment">// </span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ; i&gt;=<span class="hljs-number">0</span> &amp;&amp; res.<span class="hljs-property">length</span> &lt; k ; i--)&#123;    <span class="hljs-comment">// 从出现最多的数字开始收集直到收集到k个</span>    <span class="hljs-keyword">if</span>(arr[i])&#123;      res.<span class="hljs-title function_">push</span>(...arr[i])    &#125;  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue@2.x实现分析</title>
    <link href="/2022/02/24/vue2/"/>
    <url>/2022/02/24/vue2/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_init</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">options?: <span class="hljs-built_in">Object</span></span>)&#123;  <span class="hljs-comment">// 设置uid</span>  vm.<span class="hljs-property">_uid</span> = uid++  <span class="hljs-comment">// 不为根组件设置响应式</span>  vm.<span class="hljs-property">_isVue</span> = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 合并配置</span>  <span class="hljs-comment">// 合并实例的option对象，里面会包含像生命周期钩子回调用，指令，过滤器，vue内置对象等，与用户自定义的全局xx合并</span>  <span class="hljs-comment">// 实例内部执行会比外部new Vue快很多</span>  <span class="hljs-keyword">if</span> (options &amp;&amp; options.<span class="hljs-property">_isComponent</span>) &#123;    <span class="hljs-comment">// 实例内部执行new Vue</span>    <span class="hljs-title function_">initInternalComponent</span>(vm, options)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 从外部执行new Vue时</span>    vm.<span class="hljs-property">$options</span> = <span class="hljs-title function_">mergeOptions</span>(      √s || &#123;&#125;,      vm    )  &#125;  <span class="hljs-comment">// 初始化生命周期</span>  <span class="hljs-title function_">initLifecycle</span>(<span class="hljs-params">vm</span>)&#123;    <span class="hljs-comment">//关联`$parent`,并将自己添加进父组件的`$children`数组,生成自己的`$children`数组和`$refs`对象,并指定`$root`</span>    <span class="hljs-keyword">var</span> parent = options.<span class="hljs-property">parent</span>;    parent.<span class="hljs-property">$children</span>.<span class="hljs-title function_">push</span>(vm);    vm.<span class="hljs-property">$parent</span> = parent;    vm.<span class="hljs-property">$root</span> = parent ? parent.<span class="hljs-property">$root</span> : vm;    vm.<span class="hljs-property">$children</span> = [];    vm.<span class="hljs-property">$refs</span> = &#123;&#125;;    vm.<span class="hljs-property">_watcher</span> = <span class="hljs-literal">null</span>;    vm.<span class="hljs-property">_isMounted</span> = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 判断是否mount的flag</span>  &#125;  <span class="hljs-title function_">initEvents</span>(<span class="hljs-params">vm</span>)&#123;<span class="hljs-comment">// 初始化事件中心</span>    vm.<span class="hljs-property">_events</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);    <span class="hljs-keyword">var</span> listeners = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">_parentListeners</span>;    <span class="hljs-keyword">if</span> (listeners) &#123;      <span class="hljs-title function_">updateComponentListeners</span>(vm, listeners); <span class="hljs-comment">// 组件上的事件</span>    &#125;  &#125;  <span class="hljs-title function_">initRender</span>(<span class="hljs-params">vm</span>)&#123;      vm.<span class="hljs-property">$slots</span> = <span class="hljs-title function_">resolveSlots</span>(options.<span class="hljs-property">_renderChildren</span>, renderContext);<span class="hljs-comment">// 初始化插槽，得到vm.$slots对象</span>      <span class="hljs-comment">// key是插槽名 value是vnode</span>      vm.<span class="hljs-property">_c</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(vm, a, b, c, d, <span class="hljs-literal">false</span>); &#125;;      <span class="hljs-comment">// 模版编译的createElement函数</span>      vm.<span class="hljs-property">$createElement</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(vm, a, b, c, d, <span class="hljs-literal">true</span>); &#125;;      <span class="hljs-comment">// 初始化用户自己写的createElement函数</span>      <span class="hljs-title function_">defineReactive$$1</span>(vm, <span class="hljs-string">&#x27;$attrs&#x27;</span>, parentData &amp;&amp; parentData.<span class="hljs-property">attrs</span> || emptyObject, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        !isUpdatingChildComponent &amp;&amp; <span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;$attrs is readonly.&quot;</span>, vm);      &#125;, <span class="hljs-literal">true</span>);      <span class="hljs-title function_">defineReactive$$1</span>(vm, <span class="hljs-string">&#x27;$listeners&#x27;</span>, options.<span class="hljs-property">_parentListeners</span> || emptyObject, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        !isUpdatingChildComponent &amp;&amp; <span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;$listeners is readonly.&quot;</span>, vm);      &#125;, <span class="hljs-literal">true</span>);  &#125;  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeCreate&#x27;</span>);  <span class="hljs-title function_">initInjections</span>(vm); <span class="hljs-comment">// resolve injections before data/props</span>  initState (vm) &#123;    <span class="hljs-title function_">initProps</span>(vm, opts.<span class="hljs-property">props</span>);    <span class="hljs-comment">// 子组件标签上的prop将会编译为attrs对象</span>    <span class="hljs-comment">// render函数在校验这些props后会会生成propData传入VNode构造器</span>    <span class="hljs-comment">// 实例化子组件的同时也为prop绑定了响应式</span>    <span class="hljs-title function_">initMethods</span>(vm, opts.<span class="hljs-property">methods</span>);    <span class="hljs-comment">// 确保方法命名规范并添加到实例上</span>    <span class="hljs-title function_">initData</span>(vm);    <span class="hljs-comment">// 确保data中命名规范并绑定响应式</span>    <span class="hljs-title function_">initComputed</span>(vm, opts.<span class="hljs-property">computed</span>);    <span class="hljs-title function_">initWatch</span>(vm, opts.<span class="hljs-property">watch</span>);  &#125;  <span class="hljs-title function_">initProvide</span>(vm); <span class="hljs-comment">// resolve provide after data/props</span>  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;created&#x27;</span>);&#125;</code></pre></div><h2 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">mountComponent () &#123;  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;⭐️beforeMount&#x27;</span>);  <span class="hljs-keyword">let</span> updateComponent;  updateComponent = <span class="hljs-function">() =&gt;</span> &#123;    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>(), hydrating);    <span class="hljs-comment">// update函数</span>    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">vnode, hydrating</span>) &#123;      <span class="hljs-keyword">if</span> (!prevVnode) &#123;        <span class="hljs-comment">// initial render</span>        vm.<span class="hljs-property">$el</span> = vm.<span class="hljs-title function_">__patch__</span>(vm.<span class="hljs-property">$el</span>, vnode, hydrating, <span class="hljs-literal">false</span> <span class="hljs-comment">/* removeOnly */</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// updates</span>        vm.<span class="hljs-property">$el</span> = vm.<span class="hljs-title function_">__patch__</span>(prevVnode, vnode);    &#125;;  &#125;;  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent, noop, &#123;        <span class="hljs-attr">before</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">before</span> () &#123;        <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_isMounted</span>) &#123;          <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>);        &#125;      &#125;    subs[i].<span class="hljs-property">notify</span>  ---&gt; <span class="hljs-title class_">Watcher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">update</span>()    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;⭐️beforeDestroy&#x27;</span>);  &#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher init阶段生成的是渲染watcher*/</span>);    vm.<span class="hljs-property">_isMounted</span> = <span class="hljs-literal">true</span>;    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;mounted&#x27;</span>);&#125;</code></pre></div><h2 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$destroy</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;⭐️beforeDestroy&#x27;</span>);  <span class="hljs-comment">// 销毁实例，子实例，从父组件children中删除，销毁所有事件和指令</span>  <span class="hljs-title function_">remove</span>(parent.<span class="hljs-property">$children</span>, vm);  vm.<span class="hljs-property">_watcher</span>.<span class="hljs-title function_">teardown</span>();  vm.<span class="hljs-title function_">__patch__</span>(vm.<span class="hljs-property">_vnode</span>, <span class="hljs-literal">null</span>);  <span class="hljs-comment">// fire destroyed hook</span>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;⭐️destroyed&#x27;</span>);  vm.<span class="hljs-property">$el</span>.<span class="hljs-property">__vue__</span> = <span class="hljs-literal">null</span>;  vm.<span class="hljs-property">$vnode</span>.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span>;  &#125;;&#125;</code></pre></div><h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;⭐️activated&#x27;</span>);<span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;⭐️deactivated&#x27;</span>);</code></pre></div><h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a><code>defineReactive</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">defineReactive (  ...) &#123;  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()  ...  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// render函数接触data触发getter</span>    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveGetter</span> () &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;        <span class="hljs-comment">// 此时Dep.target已经是渲染watcher</span>        <span class="hljs-comment">// 执行depend</span>⭐️        dep.<span class="hljs-title function_">depend</span>()        <span class="hljs-keyword">if</span> (childOb) &#123;          ...        &#125;      &#125;      <span class="hljs-keyword">return</span> value    &#125;,    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveSetter</span> (newVal) &#123;      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        <span class="hljs-keyword">return</span>      &#125;      val = newVal🔥    dep.<span class="hljs-title function_">notify</span>()    &#125;  &#125;)&#125;</code></pre></div><h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent "></a><code>mountComponent </code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">mountComponent (...): <span class="hljs-title class_">Component</span> &#123;  <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeMount&#x27;</span>)  <span class="hljs-keyword">let</span> updateComponent;⭐️ <span class="hljs-comment">// render函数生成虚拟DOM，期间会访问数据</span>  updateComponent = <span class="hljs-function">() =&gt;</span> &#123;    vm.<span class="hljs-title function_">_update</span>(vm.<span class="hljs-title function_">_render</span>(), hydrating);  &#125;;⭐️ <span class="hljs-comment">//组件`mount`过程中会实例化一个渲染`watcher`，传入updateComponent函数</span>  vm.<span class="hljs-property">_watcher</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, updateComponent, noop, &#123;    before () &#123;      <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">_isMounted</span>) &#123;        <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;beforeUpdate&#x27;</span>)      &#125;    &#125;  &#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>)  <span class="hljs-keyword">if</span> (vm.<span class="hljs-property">$vnode</span> == <span class="hljs-literal">null</span>) &#123;    vm.<span class="hljs-property">_isMounted</span> = <span class="hljs-literal">true</span>    <span class="hljs-title function_">callHook</span>(vm, <span class="hljs-string">&#x27;mounted&#x27;</span>)  &#125;&#125;</code></pre></div><h3 id="Watcher对象"><a href="#Watcher对象" class="headerlink" title="Watcher对象"></a><code>Watcher</code>对象</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;  <span class="hljs-title function_">constructor</span> (    vm,    expOrFn,    cb,    options  ) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;    vm.<span class="hljs-property">_watchers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>);    <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span> = [];    <span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">_Set</span>();    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">_Set</span>();    <span class="hljs-comment">// parse expression for getter</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> expOrFn === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;⭐️ <span class="hljs-comment">// getter此时为传入的updateComponent函数</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = expOrFn;    &#125;  &#125;  get () &#123;⭐️  <span class="hljs-comment">//首先触发watcher中的get（）</span>    <span class="hljs-comment">// pushTarget方法</span>    <span class="hljs-title function_">pushTarget</span>(<span class="hljs-variable language_">this</span>)    <span class="hljs-keyword">let</span> value⭐️  <span class="hljs-comment">// 调用getter</span>    value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">deep</span>) &#123;      <span class="hljs-title function_">traverse</span>(value)    &#125;⭐️ <span class="hljs-comment">// 当前组件收集完成后清理</span>    <span class="hljs-title function_">popTarget</span>()    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cleanupDeps</span>()    <span class="hljs-keyword">return</span> value  &#125;  addDep (<span class="hljs-attr">dep</span>: <span class="hljs-title class_">Dep</span>) &#123;    <span class="hljs-keyword">const</span> id = dep.<span class="hljs-property">id</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">has</span>(id)) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">add</span>(id)      <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>.<span class="hljs-title function_">push</span>(dep)      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>.<span class="hljs-title function_">has</span>(id)) &#123;      ⭐️ <span class="hljs-comment">// 添加订阅</span>        dep.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">this</span>)      &#125;    &#125;  &#125;⭐️<span class="hljs-comment">// 对比新旧订阅列表，清空依赖</span>  cleanupDeps () &#123;    <span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>    <span class="hljs-keyword">while</span> (i--) &#123;      <span class="hljs-keyword">const</span> dep = <span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>[i]      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">has</span>(dep.<span class="hljs-property">id</span>)) &#123;        <span class="hljs-comment">//清空依赖</span>        dep.<span class="hljs-title function_">removeSub</span>(<span class="hljs-variable language_">this</span>)      &#125;    &#125;    <span class="hljs-comment">// 每次更新页面，render依赖收集的时候</span>    <span class="hljs-comment">// 将不展示于页面上的数据的依赖移除</span>    <span class="hljs-comment">// 考虑v-if</span>    [<span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>]=[<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">depIds</span>]    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDepIds</span>.<span class="hljs-title function_">clear</span>()    [<span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>] = [<span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">deps</span>]    <span class="hljs-variable language_">this</span>.<span class="hljs-property">newDeps</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>  &#125;🔥  update () &#123;    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">lazy</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirty</span> = <span class="hljs-literal">true</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">sync</span>) &#123;      <span class="hljs-comment">// 同步立即run</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">run</span>();    &#125; <span class="hljs-keyword">else</span> &#123;🔥    <span class="hljs-title function_">queueWatcher</span>(<span class="hljs-variable language_">this</span>);    &#125;  &#125;  <span class="hljs-comment">// 通过一个队列queue管理需要更新的watcher，重复的将会只执行最后一个</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">queueWatcher</span> (watcher) &#123;    <span class="hljs-keyword">var</span> id = watcher.<span class="hljs-property">id</span>;    <span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) &#123;      has[id] = <span class="hljs-literal">true</span>;      <span class="hljs-keyword">if</span> (!flushing) &#123;        queue.<span class="hljs-title function_">push</span>(watcher);      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// if already flushing, splice the watcher based on its id</span>        <span class="hljs-comment">// if already past its id, it will be run next immediately.</span>        <span class="hljs-keyword">var</span> i = queue.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="hljs-property">id</span> &gt; watcher.<span class="hljs-property">id</span>) &#123;          i--;        &#125;        queue.<span class="hljs-title function_">splice</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher);      &#125;      <span class="hljs-comment">// queue the flush</span>      <span class="hljs-keyword">if</span> (!waiting) &#123;        waiting = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span> (!config.<span class="hljs-property">async</span>) &#123;          <span class="hljs-title function_">flushSchedulerQueue</span>();          <span class="hljs-keyword">return</span>        &#125;        <span class="hljs-comment">// 在下一个tick执行这个队列</span>        <span class="hljs-title function_">nextTick</span>(flushSchedulerQueue);      &#125;    &#125;  &#125;&#125;</code></pre></div><h3 id="Dep对象"><a href="#Dep对象" class="headerlink" title="Dep对象"></a><code>Dep</code>对象</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;  <span class="hljs-keyword">static</span> <span class="hljs-attr">target</span>: ?<span class="hljs-title class_">Watcher</span>;  <span class="hljs-attr">id</span>: number;  <span class="hljs-attr">subs</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Watcher</span>&gt;;  <span class="hljs-title function_">constructor</span> () &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = uid++    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = []  &#125; <span class="hljs-comment">// 将watcher加入subs</span>  addSub (<span class="hljs-attr">sub</span>: <span class="hljs-title class_">Watcher</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub)  &#125;  removeSub (<span class="hljs-attr">sub</span>: <span class="hljs-title class_">Watcher</span>) &#123;    <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>, sub)  &#125;  depend () &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) &#123;     <span class="hljs-comment">// 执行当前watcher中的addDep函数</span>      <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>.<span class="hljs-title function_">addDep</span>(<span class="hljs-variable language_">this</span>)    &#125;  &#125;🔥  notify () &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;      subs[i].<span class="hljs-title function_">update</span>()    &#125;  &#125;&#125;⭐️ <span class="hljs-comment">// target置空</span><span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">null</span><span class="hljs-keyword">const</span> targetStack = []<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTarget</span> (<span class="hljs-attr">_target</span>: ?<span class="hljs-title class_">Watcher</span>) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) targetStack.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>)  ⭐️ <span class="hljs-comment">// 将Dep.target 指向当前watcher</span>  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = _target&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">popTarget</span> () &#123;  <span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span> = targetStack.<span class="hljs-title function_">pop</span>()&#125;</code></pre></div><h2 id="⭐️-收集依赖-⭐️"><a href="#⭐️-收集依赖-⭐️" class="headerlink" title="⭐️ 收集依赖 ⭐️"></a>⭐️ 收集依赖 ⭐️</h2><ol><li><p>实例初始化阶段为每个标记为响应式的数据（拥有不可枚举属性<code>__ob__</code>）进行响应式绑定，生成各自的<code>Dep</code>实例；</p></li><li><p>组件渲染函数执行过程中实例化一个渲染<code>Watcher</code>，并指定为此时的<code>Dep.target</code>（Dep 的 Target 指向不是固定的，在渲染函数的执行过程中会一直变化来为各类数据 <code>data</code> <code>prop</code> <code>computed</code> <code>watch</code>）创建维护 subs 数组；</p></li><li><p>当渲染函数访问到绑定了响应式的数据时，触发数据的 getter，将当前组件渲染<code>Watcher</code>添加到该数据持有的<code>Dep.subs</code>数组中；</p></li><li><p>同时渲染<code>Watcher</code>自己也有一个<code>deps</code>数组保存，用来记录自己订阅了谁，这样做的意义是在下次<code>Watcher.update</code>时将不再显示页面上的数据绑定移除(对比新旧<code>deps</code>数组)</p><blockquote><p>可以理解成 data 数据的 subs 数组中每个 watcher 即代表一个受该数据响应式影响的组件实例</p></blockquote></li></ol><h2 id="🔥-派发更新-🔥"><a href="#🔥-派发更新-🔥" class="headerlink" title="🔥 派发更新 🔥"></a>🔥 派发更新 🔥</h2><ol><li>修改数据触发 setter，执行该数据持有的<code>Dep.notify</code>方法</li><li>遍历当前数据<code>Dep.subs</code>中的每一个<code>Watcher</code>，执行其<code>Watcher.update()</code></li><li>vue 不会每次数据更新就立刻去更新视图，而是用队列管理这些回调任务<code>queueWatcher</code></li><li>队列会判断 watcher 是否重复，并且进行排序【先父后子】【自定义 watcher&gt; 渲染 watcher】</li><li>在下一个 <code>tick</code> 执行这个队列的回调<code>updateComponent</code>函数，<code>patch</code>实例（diff 并更换新 DOM）</li></ol><h1 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a><code>nextTick</code></h1><ul><li>js事件循环，主线程的一轮循环就是一个<code>tick</code>，只有在执行完所有同步函数和<code>macrotask</code>，<code>microtask</code>后才能进入下一个<code>tick</code></li><li>派发更新时<code>queueWatcher</code>调用<code>nextTick()</code>来执行需要更新的Watcher队列</li><li>手动调用<code>nextTick</code>的回调也会加入callback数组，在下一个<code>tick</code>执行<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> callbacks = []<span class="hljs-keyword">let</span> pending = <span class="hljs-literal">false</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushCallbacks</span> () &#123;  pending = <span class="hljs-literal">false</span>  <span class="hljs-keyword">const</span> copies = callbacks.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>)  callbacks.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; copies.<span class="hljs-property">length</span>; i++) &#123;    copies[i]()  &#125;&#125;<span class="hljs-keyword">let</span> microTimerFunc <span class="hljs-comment">// 在下一轮微任务执行cb数组</span><span class="hljs-keyword">let</span> macroTimerFunc <span class="hljs-comment">// 在下一轮宏任务执行cb数组</span><span class="hljs-keyword">let</span> useMacroTask = <span class="hljs-literal">false</span><span class="hljs-comment">// 依次尝试使用setImmediate,messageChanel,setTimeout来实现macroTimerFunc</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(setImmediate)) &#123;  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">setImmediate</span>(flushCallbacks)  &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MessageChannel</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (  <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">MessageChannel</span>) ||  <span class="hljs-comment">// PhantomJS</span>  <span class="hljs-title class_">MessageChannel</span>.<span class="hljs-title function_">toString</span>() === <span class="hljs-string">&#x27;[object MessageChannelConstructor]&#x27;</span>)) &#123;  <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>()  <span class="hljs-keyword">const</span> port = channel.<span class="hljs-property">port2</span>  channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = flushCallbacks  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    port.<span class="hljs-title function_">postMessage</span>(<span class="hljs-number">1</span>)  &#125;&#125; <span class="hljs-keyword">else</span> &#123;  macroTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)  &#125;&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) &#123;  <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()  microTimerFunc = <span class="hljs-function">() =&gt;</span> &#123;    p.<span class="hljs-title function_">then</span>(flushCallbacks)  &#125;&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 回退到使用macroTimerFunc</span>  microTimerFunc = macroTimerFunc&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">nextTick</span> (cb?: <span class="hljs-title class_">Function</span>, ctx?: <span class="hljs-title class_">Object</span>) &#123;  <span class="hljs-keyword">let</span> _resolve  callbacks.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cb) &#123;      <span class="hljs-keyword">try</span> &#123;        cb.<span class="hljs-title function_">call</span>(ctx)      &#125; <span class="hljs-keyword">catch</span> (e) &#123;        <span class="hljs-title function_">handleError</span>(e, ctx, <span class="hljs-string">&#x27;nextTick&#x27;</span>)      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;      <span class="hljs-title function_">_resolve</span>(ctx)    &#125;  &#125;)  <span class="hljs-keyword">if</span> (!pending) &#123;    pending = <span class="hljs-literal">true</span>    <span class="hljs-keyword">if</span> (useMacroTask) &#123;      <span class="hljs-title function_">macroTimerFunc</span>()    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-title function_">microTimerFunc</span>()    &#125;  &#125;  <span class="hljs-comment">// 如果调用了nextTick但没传cb，默认给一个Promise.resolve()来resolve</span>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;      _resolve = resolve    &#125;)  &#125;&#125;</code></pre></div></li></ul><h1 id="组件生命周期关系"><a href="#组件生命周期关系" class="headerlink" title="组件生命周期关系"></a>组件生命周期关系</h1><ul><li>  组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</li><li>  组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</li></ul><h3 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h3><p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount- &gt;子 mounted-&gt;父 mounted</p><h3 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h3><p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><h3 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h3><p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p><h1 id="计算属性和侦听属性"><a href="#计算属性和侦听属性" class="headerlink" title="计算属性和侦听属性"></a>计算属性和侦听属性</h1><h2 id="Computed"><a href="#Computed" class="headerlink" title="Computed"></a><code>Computed</code></h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">initComputed (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>, <span class="hljs-attr">computed</span>: <span class="hljs-title class_">Object</span>) &#123;  <span class="hljs-keyword">const</span> watchers = vm.<span class="hljs-property">_computedWatchers</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)  <span class="hljs-keyword">const</span> isSSR = <span class="hljs-title function_">isServerRendering</span>()  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> computed) &#123;    <span class="hljs-keyword">const</span> userDef = computed[key]    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.<span class="hljs-property">get</span>    ...⭐️<span class="hljs-number">1</span>      watchers[key] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(        vm,        getter || noop,        noop,        &#123; <span class="hljs-attr">computed</span>: <span class="hljs-literal">true</span> &#125;      )    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;⭐️<span class="hljs-number">2</span>      <span class="hljs-title function_">defineComputed</span>(vm, key, userDef)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;      <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> vm.<span class="hljs-property">$data</span>) &#123;        <span class="hljs-comment">// ... key名称被data或者prop占用的警告</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript">createComputedGetter (key) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">computedGetter</span> () &#123;    <span class="hljs-keyword">const</span> watcher = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">_computedWatchers</span>[key]    <span class="hljs-keyword">if</span> (watcher) &#123;⭐️<span class="hljs-number">2</span>      watcher.<span class="hljs-title function_">depend</span>()      <span class="hljs-keyword">return</span> watcher.evaluate()    &#125;  &#125;&#125;</code></pre></div><ol><li>实例 initState 阶段遍历 Computed 内的 key，为每个 key 创建 computed watcher</li><li>利用 Object.defineProperty 给 key 值添加 getter</li><li>渲染函数访问到 computed 内的属性时候触发 getter，生成一个 Dep 实例，并且此时 Dep.target 是渲染 watcher，渲染 watcher 就订阅了这个 key 的变化</li><li>执行这个 compute key 的计算逻辑，访问依赖的数据会触发其中响应式数据的 getter，则 computed watcher 也就订阅了 data 的变化，最后也返回计算值并缓存起来</li><li>当依赖的响应式数据变化时，响应的 computed watcher 会收到通知</li><li>computed watcher 会重新求值，比较两次运算结果，结果改变时才会通知渲染 watcher 更新</li></ol><h2 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a><code>Watch</code></h2><ul><li>  deep</li><li>  immediate</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">initWatch (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>, <span class="hljs-attr">watch</span>: <span class="hljs-title class_">Object</span>) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> watch) &#123;    <span class="hljs-keyword">const</span> handler = watch[key]    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(handler)) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; handler.<span class="hljs-property">length</span>; i++) &#123;        <span class="hljs-comment">// 遍历handlers</span>        <span class="hljs-title function_">createWatcher</span>(vm, key, handler[i])      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-title function_">createWatcher</span>(vm, key, handler)    &#125;  &#125;&#125;</code></pre></div><ol><li>遍历 Watch 内的 key</li><li>遍历每一个 handler，为每一个 handler 创建 user watcher</li><li>user watcher 会被添加进订阅响应数据的 subs 数组完成订阅</li><li>响应式数据的变化会通知到 user watcher</li><li>渲染函数如果访问这个 watch 属性，也同理会被推入该 watch 属性的 subs 数组,订阅其变化</li></ol><h1 id="Vue事件"><a href="#Vue事件" class="headerlink" title="Vue事件"></a>Vue事件</h1><p>Vue 支持 2 种事件类型，原生 DOM 事件和自定义事件，它们主要的区别在于添加和删除事件的方式不一样</p><ul><li>原生事件使用<code>add/removeEventListener</code>直接添加到<code>el</code>上</li><li>自定义事件使用一个事件中心来维护</li><li>自定义事件的派发是往当前实例上派发</li><li>只有组件节点才可以添加自定义事件，并且添加原生 DOM 事件需要使用 <code>.native</code> 修饰符；而普通元素使用 <code>.native</code> 修饰符是没有作用的，也只能添加原生 DOM 事件。<blockquote><p>vue3中已经舍弃.native，全局的所有事件都交由vue管理</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 简化</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">eventsMixin</span> (<span class="hljs-title class_">Vue</span>) &#123;  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$on</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event, fn</span>)&#123;    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(event)) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = event.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;        <span class="hljs-variable language_">this</span>.$on(event[i], fn)      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      (vm.<span class="hljs-property">_events</span>[event] || (vm.<span class="hljs-property">_events</span>[event] = [])).<span class="hljs-title function_">push</span>(fn)    &#125;    <span class="hljs-keyword">return</span> vm  &#125;  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$once</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event, fn</span>)&#123;    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>    vm.$on(event, <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-comment">/*参数*/</span></span>)&#123;      vm.$off(event, on)      fn.<span class="hljs-title function_">apply</span>(vm, <span class="hljs-variable language_">arguments</span>)    &#125;)    <span class="hljs-keyword">return</span> vm  &#125;  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$off</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event, fn</span>)&#123;    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>    <span class="hljs-comment">// all</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) &#123;      vm.<span class="hljs-property">_events</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)      <span class="hljs-keyword">return</span> vm    &#125;    <span class="hljs-comment">// array of events</span>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(event)) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = event.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;        <span class="hljs-variable language_">this</span>.$off(event[i], fn)      &#125;      <span class="hljs-keyword">return</span> vm    &#125;    <span class="hljs-comment">// specific event</span>    <span class="hljs-keyword">const</span> cbs = vm.<span class="hljs-property">_events</span>[event]    <span class="hljs-keyword">if</span> (!cbs) &#123;      <span class="hljs-keyword">return</span> vm    &#125;    <span class="hljs-keyword">if</span> (!fn) &#123;      vm.<span class="hljs-property">_events</span>[event] = <span class="hljs-literal">null</span>      <span class="hljs-keyword">return</span> vm    &#125;    <span class="hljs-keyword">if</span> (fn) &#123;      <span class="hljs-comment">// specific handler</span>      <span class="hljs-keyword">let</span> cb      <span class="hljs-keyword">let</span> i = cbs.<span class="hljs-property">length</span>      <span class="hljs-keyword">while</span> (i--) &#123;        cb = cbs[i]        <span class="hljs-keyword">if</span> (cb === fn || cb.<span class="hljs-property">fn</span> === fn) &#123;          cbs.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>)          <span class="hljs-keyword">break</span>        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> vm  &#125;  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$emit</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event,...args</span>)&#123;    <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>    <span class="hljs-keyword">let</span> cbs = vm.<span class="hljs-property">_events</span>[event]    <span class="hljs-keyword">if</span> (cbs) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = cbs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;        <span class="hljs-keyword">try</span> &#123;          cbs[i].<span class="hljs-title function_">apply</span>(vm, args)        &#125; <span class="hljs-keyword">catch</span> (e) &#123;          <span class="hljs-comment">// handle Error</span>        &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> vm  &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-next学习</title>
    <link href="/2022/02/24/vue3/"/>
    <url>/2022/02/24/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="VUE3带来的好东西"><a href="#VUE3带来的好东西" class="headerlink" title="VUE3带来的好东西"></a>VUE3带来的好东西</h1><h2 id="Proxy-API"><a href="#Proxy-API" class="headerlink" title="Proxy API"></a><code>Proxy API</code></h2><h3 id="vue2-X存在的缺陷"><a href="#vue2-X存在的缺陷" class="headerlink" title="vue2.X存在的缺陷"></a>vue2.X存在的缺陷</h3><ul><li>无法检测对象中 <code>property</code> 的添加或移除；</li><li>通过下标操作数组不会触发响应 ，<code>vm.items[indexOfItem] = newValue</code>能做到但性能考虑放弃；</li><li>修改数组的长度时不会触发响应式，<code>vm.items.length = newLength</code>；</li><li>vue2时代的解决方法<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Object新增元素</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(object, propertyName, value)<span class="hljs-comment">// or</span><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">// 下标修改数组</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">set</span>(vm.<span class="hljs-property">array1</span>, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">array1</span>, indexOfItem, newValue)<span class="hljs-comment">// or</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">array1</span>.<span class="hljs-title function_">splice</span>(indexOfItem, <span class="hljs-number">1</span>, newValue)<span class="hljs-comment">// 修改数组长度</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">array1</span>.<span class="hljs-title function_">splice</span>(newLength)</code></pre></div></li><li>重写了数组部分方法以支持响应式<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">pop</span>()<span class="hljs-title function_">push</span>()<span class="hljs-title function_">shift</span>()<span class="hljs-title function_">unshift</span>()<span class="hljs-title function_">splice</span>()<span class="hljs-title function_">sort</span>()<span class="hljs-title function_">reverse</span>()</code></pre></div><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a><code>defineProperty</code></h3></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-params">obj<span class="hljs-comment">/* 对象*/</span>, prop<span class="hljs-comment">/* 属性*/</span>, descriptor<span class="hljs-comment">/*描述符*/</span></span>)&#123;  <span class="hljs-comment">//对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。</span>  <span class="hljs-comment">//数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。</span>  <span class="hljs-comment">//存取描述符是由 getter 函数和 setter 函数所描述的属性。</span>  <span class="hljs-comment">//一个描述符只能是这两者其中之一；不能同时是两者。</span>  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。</span>  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。</span>  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>,  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//当 writable 属性设置为 false 时，该属性被称为“不可写的”。它不能被重新赋值。</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// 或者</span>  <span class="hljs-comment">//</span>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123; ... &#125;,  <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123; ... &#125;,  enumerable : <span class="hljs-literal">true</span>,  configurable : <span class="hljs-literal">true</span>&#125;</code></pre></div><ol><li>兼容<code>IE9</code></li><li>劫持了对象上的<code>属性</code></li><li>数据结构越复杂初始性能会越差,需要递归遍历绑定<code>defineProperty</code></li><li>为保持响应式还需要为新增数据再次绑定<code>defineProperty</code></li><li>需要对原始数据修改来触发拦截器</li></ol><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><code>proxy</code></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)handler.<span class="hljs-title function_">getPrototypeOf</span>()<span class="hljs-comment">//Object.getPrototypeOf 方法的捕捉器。</span>handler.<span class="hljs-title function_">setPrototypeOf</span>()<span class="hljs-comment">//Object.setPrototypeOf 方法的捕捉器。</span>handler.<span class="hljs-title function_">isExtensible</span>()<span class="hljs-comment">//Object.isExtensible 方法的捕捉器。</span>handler.<span class="hljs-title function_">preventExtensions</span>()<span class="hljs-comment">//Object.preventExtensions 方法的捕捉器。</span>handler.<span class="hljs-title function_">getOwnPropertyDescriptor</span>()<span class="hljs-comment">//Object.getOwnPropertyDescriptor 方法的捕捉器。</span>handler.<span class="hljs-title function_">defineProperty</span>()<span class="hljs-comment">//Object.defineProperty 方法的捕捉器。</span>handler.<span class="hljs-title function_">has</span>()<span class="hljs-comment">//in 操作符的捕捉器。</span>handler.<span class="hljs-title function_">get</span>()<span class="hljs-comment">//属性读取操作的捕捉器。</span>handler.<span class="hljs-title function_">set</span>()<span class="hljs-comment">//属性设置操作的捕捉器。</span>handler.<span class="hljs-title function_">deleteProperty</span>()<span class="hljs-comment">//delete 操作符的捕捉器。</span>handler.<span class="hljs-title function_">ownKeys</span>()<span class="hljs-comment">//Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</span>handler.<span class="hljs-title function_">apply</span>()<span class="hljs-comment">//函数调用操作的捕捉器。</span>handler.<span class="hljs-title function_">construct</span>()<span class="hljs-comment">//new 操作符的捕捉器。</span></code></pre></div><ol><li>不兼容<code>IE</code></li><li>劫持<code>整个对象</code>，无需对对象本体作出修改</li><li>响应数组的改变</li><li>拦截器响应的是<code>proxy</code>生成的代理对象，原数据的修改将不会触发拦截器</li><li>拦截器种类繁多</li></ol><h2 id="组合式API生命周期"><a href="#组合式API生命周期" class="headerlink" title="组合式API生命周期"></a>组合式API生命周期</h2><p><code>onXXXX</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">beforeCreate + <span class="hljs-function"><span class="hljs-params">created</span> =&gt;</span> setupbeforeMount =&gt; onBeforeMountmounted =&gt; onMountedbeforeUpdate =&gt; onBeforeUpdateupdated =&gt; onUpdatedbeforeDestroy =&gt; onBeforeUnmountdestroyed =&gt; onUnmounted<span class="hljs-comment">// keep-live组件</span>activated =&gt; onActivateddeactivated =&gt; onDeactivated<span class="hljs-comment">// 错误捕获</span>oneErrorCaptured<span class="hljs-comment">// 追踪</span>onRenderTrackedonRenderTriggered</code></pre></div><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a><code>Composition API</code></h2><p>组合式api，解决关注点分离问题，同一逻辑代码可以摆放在一起</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a><code>Hooks</code></h2><h2 id="css-in-js"><a href="#css-in-js" class="headerlink" title="css in js"></a><code>css in js</code></h2><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>自定钩子与组件生命周期统一</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">created</span>() <span class="hljs-comment">// 在元素的 attribute 或事件监听器被应用之前调用。</span><span class="hljs-title function_">beforeMount</span>()<span class="hljs-title function_">mounted</span>()<span class="hljs-title function_">beforeUpdate</span>()<span class="hljs-title function_">updated</span>()<span class="hljs-title function_">beforeUnmount</span>()<span class="hljs-title function_">unmounted</span>()<span class="hljs-keyword">const</span> app = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">createApp</span>(&#123;&#125;)app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;highlight&#x27;</span>, &#123;  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding, vnode</span>) &#123;    el.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = binding.<span class="hljs-property">value</span>  &#125;&#125;)</code></pre></div><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><h2 id="实现reactive"><a href="#实现reactive" class="headerlink" title="实现reactive"></a>实现reactive</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// reactivity.js 猴版响应式框架</span><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<span class="hljs-keyword">const</span> effectStack = [];<span class="hljs-keyword">const</span> <span class="hljs-title function_">isObject</span> = obj =&gt; obj !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">const</span> baseHandler = &#123;  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;    <span class="hljs-keyword">const</span> ret = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key);    <span class="hljs-title function_">track</span>(target, key);    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&quot;object&quot;</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(ret);    &#125;    <span class="hljs-keyword">return</span> ret;  &#125;,  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, val</span>) &#123;    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, val);    <span class="hljs-title function_">trigger</span>(target, key, val);  &#125;,&#125;;<span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;  <span class="hljs-keyword">let</span> activeEffect = effectStack[effectStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    targetMap.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()));  &#125;  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);  <span class="hljs-keyword">if</span> (!dep) &#123;    depsMap.<span class="hljs-title function_">set</span>(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));  &#125;  <span class="hljs-keyword">if</span> (!dep.<span class="hljs-title function_">has</span>(activeEffect)) &#123;    dep.<span class="hljs-title function_">add</span>(activeEffect);    <span class="hljs-comment">// TODO</span>    activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(dep);  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, val</span>) &#123;  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);  <span class="hljs-keyword">if</span> (!depsMap) &#123;    <span class="hljs-comment">// never been tracked</span>    <span class="hljs-keyword">return</span>;  &#125;  <span class="hljs-keyword">const</span> effects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();  <span class="hljs-keyword">if</span> (key) &#123;    <span class="hljs-keyword">const</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);    dep.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effect</span>) =&gt;</span> &#123;      effects.<span class="hljs-title function_">add</span>(effect);    &#125;);  &#125;  effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">ef</span>) =&gt;</span> <span class="hljs-title function_">ef</span>());&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveEffect</span>(<span class="hljs-params">fn,options</span>)&#123;  <span class="hljs-keyword">const</span> effect = <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveEffect</span>(<span class="hljs-params"></span>)&#123;      <span class="hljs-keyword">try</span> &#123;        effectStack.<span class="hljs-title function_">push</span>(effect)        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>()      &#125; <span class="hljs-keyword">finally</span> &#123;        effectStack.<span class="hljs-title function_">pop</span>()      &#125;  &#125;  effect.<span class="hljs-property">deps</span> = []  effect.<span class="hljs-property">options</span> = options  <span class="hljs-keyword">return</span> effect&#125;<span class="hljs-comment">// ---------</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">target</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, baseHandler);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options=&#123;&#125;</span>) &#123;  <span class="hljs-keyword">const</span> effect = <span class="hljs-title function_">createReactiveEffect</span>(fn, options);  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">lazy</span>) &#123;    <span class="hljs-title function_">effect</span>();  &#125;  <span class="hljs-keyword">return</span> effect;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">computed</span>(<span class="hljs-params">fn</span>)&#123;  <span class="hljs-keyword">const</span> runner = <span class="hljs-title function_">effect</span>(fn,&#123;<span class="hljs-attr">computed</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">lazy</span>:<span class="hljs-literal">true</span>&#125;)  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">effect</span>:runner,    <span class="hljs-keyword">get</span> <span class="hljs-title function_">val</span>()&#123;      <span class="hljs-keyword">return</span> <span class="hljs-title function_">runner</span>()    &#125;  &#125;&#125;</code></pre></div><h2 id="简单实现vuex"><a href="#简单实现vuex" class="headerlink" title="简单实现vuex"></a>简单实现vuex</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;reactive,inject,provide&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STORE_KEY</span> = <span class="hljs-title class_">Symbol</span>()<span class="hljs-keyword">function</span> <span class="hljs-title function_">useStore</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-variable constant_">STORE_KEY</span>)&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">options</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>(options)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Store</span>&#123;<span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>)&#123;<span class="hljs-keyword">const</span> &#123;state,mutations&#125; = options<span class="hljs-variable language_">this</span>.<span class="hljs-property">_state</span> = <span class="hljs-title function_">reactive</span>(&#123;<span class="hljs-attr">data</span>:state&#125;)<span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span> = mutations&#125;<span class="hljs-keyword">get</span> <span class="hljs-title function_">state</span>()&#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_state</span>.<span class="hljs-property">data</span>&#125;<span class="hljs-title function_">commit</span>(<span class="hljs-params">type,payload</span>)&#123;<span class="hljs-keyword">const</span> entry = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_mutations</span>[type]entry &amp;&amp; <span class="hljs-title function_">entry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>,payload)&#125;<span class="hljs-title function_">install</span>(<span class="hljs-params">app</span>)&#123;app.<span class="hljs-title function_">provide</span>(<span class="hljs-variable constant_">STORE_KEY</span>,<span class="hljs-variable language_">this</span>)&#125;&#125;<span class="hljs-keyword">export</span> &#123;createStore,useStore&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue组件之间通信方式</title>
    <link href="/2022/02/24/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/02/24/vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="ref和-refs"><a href="#ref和-refs" class="headerlink" title="ref和$refs"></a><code>ref和$refs</code></h3><ul><li><p>  <code>ref</code>挂载在普通 HTML 组件上访问它得到 DOM</p></li><li><p>  <code>ref</code>挂载在 VUE 组件上访问它得到组件实例</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;usernameInput&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">base-input</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-input</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">base-input</span>&gt;</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">usernameInput</span><span class="hljs-comment">// composition API</span><span class="hljs-keyword">const</span> usernameInput = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<span class="hljs-title function_">onMounted</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">// ref</span>    usernameInput.<span class="hljs-property">value</span>&#125;<span class="hljs-comment">// setup中没有this</span><span class="hljs-title function_">defineExpose</span>(&#123;    a,    b&#125;)<span class="hljs-comment">// 定义暴露到组件实例上的属性</span></code></pre></div><h3 id="emit和prop"><a href="#emit和prop" class="headerlink" title="$emit和prop"></a><code>$emit</code>和<code>prop</code></h3><ul><li>  子组件<code>props</code>接收父组件传递的数据</li><li>  动态数据加冒号<code>:</code></li><li>  子组件可对收到的<code>props</code>设置校验</li><li>子组件定义<code>$emit</code>自定义方法<br>  <code>this.$emit(&#39;childToParentMsg&#39;,this.childInfo,this.type)</code></li><li>  父组件就可以<code>v-on</code>监听该方法</li><li>  该方法绑定父组件的<code>methods</code></li><li>  获得方法中传递的参数</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&quot;emit1&quot;</span>, <span class="hljs-string">&quot;emit2&quot;</span>]);<span class="hljs-title function_">defineProps</span>(&#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,&#125;);</code></pre></div><h3 id="parent和-children"><a href="#parent和-children" class="headerlink" title="$parent和$children"></a><code>$parent</code>和<code>$children</code></h3><ul><li>  $parent 得到 <strong>对象</strong></li><li>  $children 得到子组件实例对象 <strong>数组</strong></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// Composition API</span><span class="hljs-title function_">getCurrentInstance</span>();</code></pre></div><h3 id="provide和inject"><a href="#provide和inject" class="headerlink" title="provide和inject"></a><code>provide</code>和<code>inject</code></h3><ul><li><p>  父组件向<code>任意深度</code>子组件传值</p></li><li><p>  父组件中通过<code>provide</code>来提供变量</p></li><li><p>  子组件中通过<code>inject</code>来注入变量</p></li><li><p>不论子组件有多深，只要调用了<code>inject</code>那么就可以注入<code>provider</code>中的数据。只要在父组件的生命周期内，子组件都可以调用。</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;parent&quot;</span>, &#123;<span class="hljs-attr">provide</span>: &#123;<span class="hljs-comment">// 提供了for变量</span><span class="hljs-attr">for</span>: <span class="hljs-string">&quot;test&quot;</span>,&#125;,&#125;);<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;child&quot;</span>, &#123;<span class="hljs-comment">//</span><span class="hljs-attr">inject</span>: [<span class="hljs-string">&quot;foo&quot;</span>],<span class="hljs-comment">// 将for变量插入本实例</span><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">mymessage</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>,&#125;;&#125;,&#125;);<span class="hljs-comment">// Composition API</span><span class="hljs-keyword">import</span> &#123;inject,provide&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-title function_">inject</span>(_name)<span class="hljs-title function_">provide</span>(_name,_reactive_value)</code></pre></div></li></ul><h3 id="attrs-amp-amp-listeners"><a href="#attrs-amp-amp-listeners" class="headerlink" title="$attrs &amp;&amp; $listeners"></a><code>$attrs</code> &amp;&amp; <code>$listeners</code></h3><ul><li><p>  <code>$attrs</code>包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外),通过<code>v-bind=&quot;$attrs&quot;</code> 传入内部组件</p></li><li><p><code>$listeners</code>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// A-&gt;B-&gt;C</span><span class="hljs-comment">// 二级子组件C</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;C&quot;</span>, &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">`</span><span class="hljs-string">              &lt;div&gt;</span><span class="hljs-string">                  &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messagec&quot; @input=&quot;passCData($attrs.messagec)&quot;&gt; &lt;/div&gt;</span><span class="hljs-string">          `</span>,<span class="hljs-attr">methods</span>: &#123;<span class="hljs-title function_">passCData</span>(<span class="hljs-params">val</span>) &#123;<span class="hljs-comment">//触发父组件A中的事件</span><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;getCData&quot;</span>, val);&#125;,&#125;,&#125;);<span class="hljs-comment">// 一级子组件B</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;B&quot;</span>, &#123;<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">mymessage</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>,&#125;;&#125;,<span class="hljs-attr">template</span>: <span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;input type=&quot;text&quot; v-model=&quot;mymessage&quot; @input=&quot;passData(mymessage)&quot;&gt; </span><span class="hljs-string">              &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string">      `</span>,<span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;message&quot;</span>], <span class="hljs-comment">//props中取走了A传下来的一个attr</span><span class="hljs-comment">// 另外一个使用:bind=&quot;$attrs&quot;继续向下传递给C</span><span class="hljs-attr">methods</span>: &#123;<span class="hljs-title function_">passData</span>(<span class="hljs-params">val</span>) &#123;<span class="hljs-comment">//触发父组件中的事件</span><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&quot;getChildData&quot;</span>, val);&#125;,&#125;,&#125;);<span class="hljs-comment">// 父组件A</span><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;A&quot;</span>, &#123;<span class="hljs-attr">template</span>: <span class="hljs-string">`</span><span class="hljs-string">          &lt;div&gt;</span><span class="hljs-string">              &lt;p&gt;this is parent compoent!&lt;/p&gt;</span><span class="hljs-string">              &lt;B :messagec=&quot;messagec&quot; :message=&quot;message&quot; v-on:getCData=&quot;getCData&quot; v-on:getChildData=&quot;getChildData(message)&quot;&gt;&lt;/B&gt;</span><span class="hljs-string">          &lt;/div&gt;</span><span class="hljs-string">      `</span>,<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-attr">messagec</span>: <span class="hljs-string">&quot;hello c&quot;</span>, <span class="hljs-comment">//传递给c组件的数据</span>&#125;;&#125;,<span class="hljs-attr">methods</span>: &#123;<span class="hljs-title function_">getChildData</span>(<span class="hljs-params">val</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是来自B组件的数据&quot;</span>);&#125;,<span class="hljs-comment">//执行C子组件触发的事件</span><span class="hljs-title function_">getCData</span>(<span class="hljs-params">val</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;这是来自C组件的数据：&quot;</span> + val);&#125;,&#125;,&#125;);</code></pre></div></li><li><p>Vue3中</p><ul><li><code>listener</code>合并到 <code>attrs</code>中</li><li><code>attrs</code>中还包含<code>class</code>和<code>style</code></li></ul></li></ul><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>一个空Vue实例</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// eventBus.js</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span>  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<span class="hljs-comment">// componentA</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">EventBus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;eventBus.js&#x27;</span><span class="hljs-attr">methods</span>:&#123;    <span class="hljs-title function_">someFunc</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;funcName&#x27;</span>,&#123;            <span class="hljs-comment">//props</span>        &#125;)    &#125;&#125;<span class="hljs-comment">// componentsB</span><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;funcName&#x27;</span>,<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;        <span class="hljs-comment">//params取得传过来的参数</span>    &#125;)&#125;</code></pre></div><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><ul><li><a href="https://github.com/vuejs/pinia">pinia</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/02/24/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/02/24/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="树型结构"><a href="#树型结构" class="headerlink" title="树型结构"></a>树型结构</h2><ul><li><p>  节点不能闭环</p></li><li><p>  只有一个根节点</p></li><li><p>  除了根节点，每个节点有且只有一个父节点</p></li><li><p>  深度：节点到根节点的最长路径经过节点个数</p></li><li><p>  高度：节点到叶节点最长路径经过节点个数</p></li><li><p>  树的高度：根节点到叶节点的最长路径经过节点个数</p></li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>最多只有两个子节点的树结构</p><p>二叉树是 n 个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>任意节点的左右子树高度差不大于 1</p><h4 id="满二叉树：每一层节点数都达到最大值"><a href="#满二叉树：每一层节点数都达到最大值" class="headerlink" title="满二叉树：每一层节点数都达到最大值"></a>满二叉树：每一层节点数都达到最大值</h4><ul><li>  一个层数为 k 的满二叉树总结点数为：2^k-1</li><li>  第 i 层上的结点数为：2^(i-1)</li><li>  一个层数为 k 的满二叉树的叶子结点个数（也就是最后一层）：2^(k-1)</li></ul><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><h4 id="二叉搜索树【BST】：右子大于父大于左子"><a href="#二叉搜索树【BST】：右子大于父大于左子" class="headerlink" title="二叉搜索树【BST】：右子大于父大于左子"></a>二叉搜索树【BST】：右子大于父大于左子</h4><blockquote><p>二叉搜索树的中序遍历得到升序排列</p></blockquote><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BinaryTree</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> <span class="hljs-title class_">Node</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;<span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;&#125;;<span class="hljs-keyword">let</span> root = <span class="hljs-literal">null</span>;&#125;</code></pre></div><ul><li>前序遍历<blockquote><p>root -&gt; left -&gt; right</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrderTraverse</span>(<span class="hljs-params">node</span>) &#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> stack = [];<span class="hljs-keyword">if</span>(node) stack.<span class="hljs-title function_">push</span>(node)<span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">let</span> curNode = stack.<span class="hljs-title function_">pop</span>();res.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">val</span>);curNode.<span class="hljs-property">right</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">right</span>); <span class="hljs-comment">//  先右再左入栈</span>curNode.<span class="hljs-property">left</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">left</span>); <span class="hljs-comment">//  则左边先出栈</span>&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">preOrderTraverse</span>(<span class="hljs-params">root</span>)&#123;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>)&#123;<span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)node.<span class="hljs-property">left</span> &amp;&amp; <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>)node.<span class="hljs-property">right</span> &amp;&amp; <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>)&#125;<span class="hljs-title function_">traverse</span>(root)<span class="hljs-keyword">return</span> res&#125;</code></pre></div><ul><li>中序遍历<blockquote><p>left -&gt; root -&gt; right</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">root</span>)&#123;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = []<span class="hljs-keyword">let</span> node = root<span class="hljs-keyword">while</span>(node || stack.<span class="hljs-property">length</span>)&#123;<span class="hljs-keyword">while</span>(node)&#123;stack.<span class="hljs-title function_">push</span>(node)node = node.<span class="hljs-property">left</span>&#125;node = stack.<span class="hljs-title function_">pop</span>()res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)node = node.<span class="hljs-property">right</span>&#125;<span class="hljs-keyword">return</span> res&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">inOrderTraverse</span>(<span class="hljs-params">root</span>)&#123;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>)&#123;<span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> node.<span class="hljs-property">left</span> &amp;&amp; <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>)res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)node.<span class="hljs-property">right</span> &amp;&amp; <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>)&#125;<span class="hljs-title function_">traverse</span>(root)<span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li>后序遍历<blockquote><p>left -&gt; right -&gt; root</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">postOrderTraverse</span>(<span class="hljs-params">root</span>)&#123;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">const</span> stack = []<span class="hljs-keyword">if</span>(root) stack.<span class="hljs-title function_">push</span>(root)<span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>)&#123;<span class="hljs-keyword">const</span> node = stack.<span class="hljs-title function_">pop</span>()res.<span class="hljs-title function_">unshift</span>(node.<span class="hljs-property">val</span>)node.<span class="hljs-property">left</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)node.<span class="hljs-property">right</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)&#125;<span class="hljs-keyword">return</span> res&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">postOrderTraverse</span>(<span class="hljs-params">root</span>)&#123;<span class="hljs-keyword">const</span> res = []<span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">node</span>)&#123;<span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span> node.<span class="hljs-property">left</span> &amp;&amp; <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">left</span>)node.<span class="hljs-property">right</span> &amp;&amp; <span class="hljs-title function_">traverse</span>(node.<span class="hljs-property">right</span>)res.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>)&#125;&#125;</code></pre></div><h2 id="二叉树算法题"><a href="#二叉树算法题" class="headerlink" title="二叉树算法题"></a>二叉树算法题</h2><ul><li>  计算路径</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">pathSum</span>(<span class="hljs-params">root, sum</span>) &#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">if</span> (root.<span class="hljs-property">value</span> === sum) <span class="hljs-keyword">return</span> [root.<span class="hljs-property">value</span>];<span class="hljs-keyword">const</span> paths = [];<span class="hljs-keyword">function</span> <span class="hljs-title function_">searchPath</span>(<span class="hljs-params">node, target, prePath</span>) &#123;<span class="hljs-keyword">const</span> target = sum - node.<span class="hljs-property">val</span>;<span class="hljs-keyword">const</span> curPath = [...prePath, node.<span class="hljs-property">val</span>];<span class="hljs-keyword">if</span> (!node.<span class="hljs-property">left</span> &amp;&amp; !node.<span class="hljs-property">right</span> &amp;&amp; target === <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 一直要到叶子结点</span>paths.<span class="hljs-title function_">push</span>(curPath);<span class="hljs-keyword">return</span>;&#125;node.<span class="hljs-property">left</span> &amp;&amp; <span class="hljs-title function_">searchPath</span>(node.<span class="hljs-property">left</span>, target, curPath);node.<span class="hljs-property">right</span> &amp;&amp; <span class="hljs-title function_">searchPath</span>(node.<span class="hljs-property">right</span>, target, curPath);&#125;<span class="hljs-title function_">searchPath</span>(root, sum, []);<span class="hljs-keyword">return</span> paths;&#125;</code></pre></div><ul><li>  二叉树镜像 / 翻转二叉树</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mirrorTree</span>(<span class="hljs-params">root</span>)&#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mirror</span>(<span class="hljs-params">node</span>)&#123;    <span class="hljs-keyword">if</span>(!node) <span class="hljs-keyword">return</span>    [node.<span class="hljs-property">left</span>,node.<span class="hljs-property">right</span>] = [node.<span class="hljs-property">right</span>,node.<span class="hljs-property">left</span>]    <span class="hljs-title function_">mirror</span>(node.<span class="hljs-property">left</span>)    <span class="hljs-title function_">mirror</span>(node.<span class="hljs-property">right</span>)  &#125;  <span class="hljs-title function_">mirror</span>(root)  <span class="hljs-keyword">return</span> root&#125;<span class="hljs-comment">// stack</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mirrorTree</span>(<span class="hljs-params">root</span>)&#123;  <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root  <span class="hljs-keyword">const</span> <span class="hljs-title function_">swap</span> = node =&gt; [node.<span class="hljs-property">left</span>,node.<span class="hljs-property">right</span>] = [node.<span class="hljs-property">right</span>,node.<span class="hljs-property">left</span>]  <span class="hljs-keyword">const</span> stack = [root]  <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">const</span> node = stack.<span class="hljs-title function_">pop</span>()    <span class="hljs-title function_">swap</span>(node)    node.<span class="hljs-property">left</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>)    node.<span class="hljs-property">right</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>)  &#125;  <span class="hljs-keyword">return</span> root&#125;</code></pre></div><ul><li>  计算二叉树的最大深度</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TreeNode</span>(<span class="hljs-params">val</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val;<span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;&#125;<span class="hljs-comment">// 后序遍历</span><span class="hljs-comment">// DFS</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">return</span> root ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>), <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>)) + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">// 递归深度加1</span><span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> left = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<span class="hljs-keyword">const</span> right = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right) + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// BFS</span><span class="hljs-comment">//递归实现</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> max;<span class="hljs-keyword">function</span> <span class="hljs-title function_">BFS</span>(<span class="hljs-params">node, dep</span>) &#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, ++dep);<span class="hljs-title function_">BFS</span>(node.<span class="hljs-property">left</span>, dep);<span class="hljs-title function_">BFS</span>(node.<span class="hljs-property">right</span>, dep);&#125;<span class="hljs-title function_">BFS</span>(root, <span class="hljs-number">0</span>);<span class="hljs-keyword">return</span> max;&#125;<span class="hljs-comment">// 栈实现</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">0</span>]];<span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> [node, dep] = stack.<span class="hljs-title function_">pop</span>();max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, dep + <span class="hljs-number">1</span>);node.<span class="hljs-property">left</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>, dep + <span class="hljs-number">1</span>);node.<span class="hljs-property">right</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>, dep + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> max;&#125;</code></pre></div><ul><li>二叉搜素树中第 k 大的值<blockquote><p>二叉搜索树 + 逆向中序遍历 =&gt; 降序排列 val</p></blockquote></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">kthLargest</span>(<span class="hljs-params">root, k</span>) &#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<span class="hljs-keyword">let</span> res = root.<span class="hljs-property">val</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">DFS</span>(<span class="hljs-params">node</span>) &#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<span class="hljs-title function_">DFS</span>(node.<span class="hljs-property">right</span>);<span class="hljs-keyword">if</span> (--k === <span class="hljs-number">0</span>) &#123;res = node.<span class="hljs-property">val</span>;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-title function_">DFS</span>(node.<span class="hljs-property">right</span>);&#125;<span class="hljs-title function_">DFS</span>(root);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><ul><li>二叉树的最近公共祖先<br>  对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">root, p, q</span>) &#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (root === p || root === q) <span class="hljs-keyword">return</span> root;<span class="hljs-keyword">const</span> l = <span class="hljs-title function_">lowerCommonAncestor</span>(root.<span class="hljs-property">left</span>, p, q);<span class="hljs-keyword">const</span> r = <span class="hljs-title function_">lowerCommonAncestor</span>(root.<span class="hljs-property">right</span>, p, q);l &amp;&amp; r ? root : l || r;&#125;</code></pre></div><ul><li>二叉搜索树的最近公共祖先<br>  二叉搜索树中 rightTree &gt; root &gt; leftTree</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">lowestCommonAncestor</span>(<span class="hljs-params">root, p, q</span>) &#123;<span class="hljs-keyword">if</span> (root.<span class="hljs-property">val</span> &lt; p.<span class="hljs-property">val</span> &amp;&amp; root.<span class="hljs-property">val</span> &lt; q.<span class="hljs-property">val</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">right</span>, p, q);&#125;<span class="hljs-keyword">if</span> (root.<span class="hljs-property">val</span> &gt; p.<span class="hljs-property">val</span> &amp;&amp; root.<span class="hljs-property">val</span> &gt; q.<span class="hljs-property">val</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">left</span>, p, q);&#125;<span class="hljs-keyword">return</span> root;&#125;</code></pre></div><ul><li>  二叉搜索树节点间最小差</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 中序排列后，最小差就是该数组中相邻元素最小差</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">minDiffInBST</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> min = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">DFS</span>(<span class="hljs-params">node</span>) &#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span>;<span class="hljs-title function_">DFS</span>(node.<span class="hljs-property">left</span>);<span class="hljs-keyword">if</span> (pre === <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">// init阶段</span>pre = node.<span class="hljs-property">val</span>;&#125; <span class="hljs-keyword">else</span> &#123;min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(min, node.<span class="hljs-property">val</span> - pre);pre = node.<span class="hljs-property">val</span>;&#125;<span class="hljs-comment">// 中序列遍历，pre存储上一个值，由于BST特性，cur.val永远大于pre</span><span class="hljs-title function_">DFS</span>(node.<span class="hljs-property">right</span>);&#125;&#125;<span class="hljs-comment">// 使用辅助栈</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">minDiffInBST</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<span class="hljs-keyword">let</span> min = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFE_INTEGER</span>;<span class="hljs-keyword">const</span> stack = [];<span class="hljs-keyword">while</span> (root || stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">while</span> (root) &#123;stack.<span class="hljs-title function_">push</span>(root);root = root.<span class="hljs-property">left</span>;&#125;<span class="hljs-keyword">const</span> node = stack.<span class="hljs-title function_">pop</span>();<span class="hljs-keyword">if</span> (pre === <span class="hljs-literal">null</span>) &#123;pre = node.<span class="hljs-property">val</span>;&#125; <span class="hljs-keyword">else</span> &#123;min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(min, node.<span class="hljs-property">val</span> - pre);pre = node.<span class="hljs-property">val</span>;&#125;root = node.<span class="hljs-property">right</span>;&#125;<span class="hljs-keyword">return</span> min;&#125;</code></pre></div><ul><li>层序遍历，打印二叉树<br>  [[第一层],[第二层],[第三层]]</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">levelOrder</span> (root) &#123;<span class="hljs-keyword">const</span> stack = [[root, <span class="hljs-number">0</span>]];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> [node, level] = stack.<span class="hljs-title function_">shift</span>();<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">if</span> (!res[level]) res[level] = [];res[level].<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);node.<span class="hljs-property">left</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>([node.<span class="hljs-property">left</span>, level + <span class="hljs-number">1</span>]);node.<span class="hljs-property">right</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>, level + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">const</span> levelOrder = <span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">const</span> stack = [root];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">if</span> (root) &#123;<span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">const</span> preLevelSize = stack.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> curLevel = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; preLevelSize; i++) &#123;<span class="hljs-keyword">const</span> n = stack.<span class="hljs-title function_">shift</span>();<span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">break</span>;curLevel.<span class="hljs-title function_">push</span>(n.<span class="hljs-property">val</span>);n.<span class="hljs-property">left</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(n.<span class="hljs-property">left</span>);n.<span class="hljs-property">right</span> &amp;&amp; stack.<span class="hljs-title function_">push</span>(n.<span class="hljs-property">right</span>);&#125;res.<span class="hljs-title function_">push</span>(curLevel);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><ul><li>判断平衡二叉树<br>  平衡二叉树，左右子树深度差不大于 1</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isBalanced</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">let</span> res = <span class="hljs-literal">true</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>) &#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> left = <span class="hljs-title function_">dfs</span>(node.<span class="hljs-property">left</span>);<span class="hljs-keyword">let</span> right = <span class="hljs-title function_">dfs</span>(node.<span class="hljs-property">right</span>);<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(left - right) &gt; <span class="hljs-number">1</span>) res = <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right) + <span class="hljs-number">1</span>;&#125;<span class="hljs-title function_">dfs</span>(root);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">isBalanced</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">node</span>) &#123;<span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">const</span> left = <span class="hljs-title function_">dfs</span>(node.<span class="hljs-property">left</span>);<span class="hljs-keyword">const</span> right = <span class="hljs-title function_">dfs</span>(node.<span class="hljs-property">right</span>);<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(left - right) &gt; <span class="hljs-number">1</span> || left === -<span class="hljs-number">1</span> || right === -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left, right) + <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">dfs</span>(root) !== -<span class="hljs-number">1</span>;&#125;</code></pre></div><ul><li>  判断对称二叉树</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 对称的二叉树</span><span class="hljs-comment">// l = r</span><span class="hljs-comment">// l.right = r.left &amp;&amp; l.left = r.right</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isMirrorTree</span>(<span class="hljs-params">root</span>) &#123;<span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">recur</span>(<span class="hljs-params">l, r</span>) &#123;<span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span> &amp;&amp; r == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span> || r == <span class="hljs-literal">null</span> || l !== r) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-title function_">recur</span>(l.<span class="hljs-property">left</span>, r.<span class="hljs-property">right</span>) &amp;&amp; <span class="hljs-title function_">recur</span>(l.<span class="hljs-property">right</span>, l, left);&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">recur</span>(root.<span class="hljs-property">left</span>, root.<span class="hljs-property">right</span>);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链与闭包</title>
    <link href="/2022/02/24/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <url>/2022/02/24/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h1><h2 id="作用域：变量可以起作用的范围"><a href="#作用域：变量可以起作用的范围" class="headerlink" title="作用域：变量可以起作用的范围"></a>作用域：变量可以起作用的范围</h2><ul><li><p>全局作用域</p><p>变量在函数外的当前global顶层声明</p><p> <code>全局变量</code>：在任何地方都可以访问到的变量，关闭网页或浏览器才会销毁。顶层</p><blockquote><p>听过var声明的全局变量会直接挂载在Global对象上，let和const则不会，但他们效果是相同的。</p></blockquote></li></ul><ul><li><p>函数作用域（局部作用域）</p><p>变量在函数内声明</p><p> <code>局部变量</code>：只在固定的代码片段内可访问到的变量,在函数开始执行时创建，函数执行完后<code>局部变量</code>会自动销毁。</p></li><li><p>块级作用域（es5）</p><p>任何一对花括号<code>&#123;&#125;</code>也会生成一个独立的作用域。</p></li><li><p>词法作用域</p><p>js的作用域范围在书写时就已经确定，不受代码执行的动态影响。（静态作用域）</p></li><li><p>自由变量</p><p>当前作用域没有定义的变量，这成为<code>自由变量</code>（既不是局部变量也不是函数参数）</p><ul><li>自由变量会向父级作用域中寻找</li><li><strong>自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时的作用域</strong></li></ul></li></ul><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ul><li><p>js中的函数在创建时会创建一个<code>变量对象</code>保存当前作用域中的所有函数与变量；</p></li><li><p>js中的代码在执行时会创建执行上下文，而执行上下文中的<code>[scope chain] </code>保存了所有父级作用域的中<code>变量对象</code>的引用，随着函数的执行，会将当前的活动对象链接到<code>[scope chain]</code>的最前端。</p></li><li><p>函数的活动对象初始只有<code>arguments</code>，变量的查找会从<code>arguments</code>开始循着<code>scope chain</code>的顺序依次往外部查找变量标识符号，直到全局作用域。</p></li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul><li><p>函数与其词法环境共同构成 <em>闭包（closure）</em> 。</p></li><li><p>词法环境 = 代码内变量标识符与值之间的关联关系（环境记录）+ 对外部词法环境的引用</p></li><li><p>所有函数会自动通过隐藏的 [[Environment]] 属性记住创建它们的位置,保存对其创建位置的此法环境的引用.</p></li><li><p>函数在书写的位置之外的作用域被调用时，可以访问其所在函数体内的变量</p></li></ul><h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ul><li><p>实现数据(变量和方法)私有化</p></li><li><p>函数柯里化</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func,...args1</span>)&#123;  <span class="hljs-keyword">const</span> fnLen = func.<span class="hljs-property">length</span>  <span class="hljs-keyword">const</span> argsArr = [...args1]  <span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry</span>(<span class="hljs-params">...args2</span>)&#123;    argsArr = [...argsArr,...args2]    <span class="hljs-keyword">return</span> argsArr.<span class="hljs-property">length</span> &gt;= fnLen ? func.<span class="hljs-title function_">apply</span>(func,argsArr) : _curry  &#125;  <span class="hljs-keyword">return</span> _curry&#125;<span class="hljs-comment">// 传世经典累加函数add</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">...args1</span>)&#123;  <span class="hljs-keyword">let</span> res = [...args1].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a+b)  <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerAdd</span>(<span class="hljs-params">...args2</span>)&#123;    res = [...res,...args2].<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a+b)    <span class="hljs-keyword">return</span> innerAdd  &#125;  innerAdd.<span class="hljs-property">toString</span> = <span class="hljs-function">() =&gt;</span> res  <span class="hljs-comment">// 打印方法会调用toString</span>  <span class="hljs-keyword">return</span> innerAdd&#125;</code></pre></div></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCounter</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// 执行结束后不会被清除</span>  <span class="hljs-keyword">const</span> myFunction = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    counter = counter + <span class="hljs-number">1</span>; <span class="hljs-comment">// myFunction函数可以读取add函数内部的变量</span>    <span class="hljs-keyword">return</span> counter;  &#125;;  <span class="hljs-keyword">return</span> myFunction;&#125;<span class="hljs-keyword">const</span> increment = <span class="hljs-title function_">addCounter</span>();<span class="hljs-keyword">const</span> c1 = <span class="hljs-title function_">increment</span>();<span class="hljs-keyword">const</span> c2 = <span class="hljs-title function_">increment</span>();<span class="hljs-keyword">const</span> c3 = <span class="hljs-title function_">increment</span>();<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;increment:&quot;</span>, c1, c2, c3);<span class="hljs-comment">// increment: 1 2 3</span></code></pre></div><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li>老生常谈的for循环setTimeout打印问题<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)  &#125;, <span class="hljs-number">1000</span> * i)&#125;<span class="hljs-comment">// 6 6 6 6 6 6</span><span class="hljs-comment">// 创建的6个setTimeout闭包共享一个词法作用域</span>**闭包只能取得包含函数中任何变量赋值最后一个值** <span class="hljs-comment">// 6</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;  (<span class="hljs-function">(<span class="hljs-params">j</span>) =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)    &#125;, <span class="hljs-number">1000</span> * j)  &#125;)(i)&#125;<span class="hljs-comment">// 1 2 3 4 5 6</span><span class="hljs-comment">// 6个setTimeout闭包有自己独立的词法环境</span><span class="hljs-comment">// 闭包读取到不同的i值</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span> ;i&lt;<span class="hljs-number">7</span>;i++)&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j);  &#125;,<span class="hljs-number">1000</span>*i,i)&#125;<span class="hljs-comment">// setTimeout 可以接受一个参数当函数调用时传入</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ;i&lt;<span class="hljs-number">7</span>;i++)&#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);  &#125;,<span class="hljs-number">1000</span>*i)&#125;</code></pre></div></li><li><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num2</span>) &#123;  <span class="hljs-keyword">var</span> num = <span class="hljs-number">15</span>;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">abc</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 函数作为返回值</span>    num++;    <span class="hljs-keyword">return</span>(num + num2);  &#125;  <span class="hljs-keyword">return</span> abc;&#125;<span class="hljs-keyword">var</span> aa = <span class="hljs-title function_">fn</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">//  没有引用？？</span><span class="hljs-title function_">aa</span>(); <span class="hljs-comment">//16+20</span><span class="hljs-title function_">aa</span>(); <span class="hljs-comment">//17+20</span><span class="hljs-title function_">fn</span>(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span><span class="hljs-title function_">fn</span>(<span class="hljs-number">20</span>)(); <span class="hljs-comment">//36</span></code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端涉及到的数据存储</title>
    <link href="/2022/02/24/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    <url>/2022/02/24/%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LocalStorage-h5-web-storage"><a href="#LocalStorage-h5-web-storage" class="headerlink" title="LocalStorage[h5 web storage]"></a><code>LocalStorage</code>[h5 web storage]</h3><ul><li><p>不会过期</p></li><li><p>数据大小5MB</p></li><li><p>同源共享同一份<code>localStorage</code></p></li><li><p>只能为<code>string</code>类型,注意需要<code>JSON</code>转换</p></li></ul><h3 id="SessionStorage-h5-web-storage"><a href="#SessionStorage-h5-web-storage" class="headerlink" title="SessionStorage[h5 web storage]"></a><code>SessionStorage</code>[h5 web storage]</h3><ul><li><p>会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）</p></li><li><p>数据大小5MB</p></li><li><p>不跨窗口共享,就算同一<code>url</code>的多个<code>tab</code>各自独立</p></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h3><ul><li><p>手动设置过期时间，否则浏览器关闭失效</p></li><li><p>数据大小 4KB</p></li><li><p>参与每次<code>http</code>请求</p></li><li><p>有<code>path</code>和<code>domain</code>概念，</p></li><li><p>某些浏览器对单网站cookie数目有限制(不超过20个)</p></li><li><p>cookie字段</p><ul><li><p><code>name</code></p></li><li><p><code>value</code></p></li><li><p><code>domain</code>　        可以访问此cookie的域，默认为该请求源的域<code>origin</code></p></li><li><p><code>path</code>　        　 可以访问此cookie的页面路径</p></li><li><p><code>expires / max-age</code> 过期时间，如没设置则与会话时效相同（关闭浏览器窗口失效）</p></li><li><p><code>HttpOnly</code>　      禁止js读取<code>Document.cookie</code></p></li><li><p><code>Secure</code>          只使用HTTPS传输</p></li><li><p><code>sameSite = </code> 防止【XSRF】攻击</p><ul><li><code>Strict</code>  跨域时不允许带上任何cookie</li><li><code>Lax</code>  只有三种情况可以带上cookie[a连接,get提交的表单,预加载link]<blockquote><p>现代浏览器会将没有声明 SameSite 值的 cookie 默认设置为Lax</p></blockquote></li><li><code>None</code> 不对发送进行限制，需配合<code>secure</code>使用用 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: widget_session=xxxxx; <span class="hljs-title class_">SameSite</span>=<span class="hljs-title class_">None</span>; <span class="hljs-title class_">Secure</span></code></pre></div></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;<span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">Expires</span>=&lt;date&gt;<span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">Max</span>-<span class="hljs-title class_">Age</span>=&lt;non-zero-digit&gt;<span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">Domain</span>=&lt;domain-value&gt;<span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">Path</span>=&lt;path-value&gt;<span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">Secure</span><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">HttpOnly</span><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">SameSite</span>=<span class="hljs-title class_">Strict</span><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">SameSite</span>=<span class="hljs-title class_">Lax</span><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; <span class="hljs-title class_">SameSite</span>=<span class="hljs-title class_">None</span>; <span class="hljs-title class_">Secure</span></code></pre></div><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a><code>IndexedDB</code></h3></li><li><p>除非被清理否则一直存在</p></li><li><p>数据大小无限制</p></li><li><p>IndexedDB 是一个基于 JavaScript 的面向对象数据库，相比webStorage提供存储大量结构化数据的能力</p></li></ul><h2 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a><code>manifest</code></h2><p><code>manifest.json</code>在一个JSON文本文件中提供有关应用程序的信息（如名称，作者，图标和描述）。manifest 的目的是将Web应用程序安装到设备的主屏幕，为用户提供更快的访问和更丰富的体验。</p><p>Web应用程序清单是被称为<code>渐进式Web应用程序(PWA)</code>的Web技术集合的一部分, 它们是可以安装到设备的主屏幕的网络应用程序，而不需要用户通过应用商店，伴随着其他功能, 比如离线可用和接收推送通知。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端性能优化</title>
    <link href="/2022/02/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2022/02/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="【打包时间】"><a href="#【打包时间】" class="headerlink" title="【打包时间】"></a>【打包时间】</h1><ul><li>缩小loader的作用范围<code>include</code>,<code>exclude</code></li><li>缩小模块搜索范围<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-comment">//...</span>  <span class="hljs-attr">resolve</span>: &#123;    <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>), <span class="hljs-string">&#x27;node_modules&#x27;</span>], <span class="hljs-comment">// 搜索位置</span>    <span class="hljs-attr">extensions</span>:[<span class="hljs-string">&quot;.js&quot;</span>,<span class="hljs-string">&quot;.jsx&quot;</span>] <span class="hljs-comment">// 搜索的后缀名,虽然写的时候可以省略,但会增加搜索的性能损耗</span>  &#125;&#125;;</code></pre></div></li></ul><h1 id="【打包大小】"><a href="#【打包大小】" class="headerlink" title="【打包大小】"></a>【打包大小】</h1><ul><li><p>资源压缩<br>  css/js/图片压缩</p></li><li><p>代码分割<br>  分离第三方库去设置长缓存或者CDN</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;      config.<span class="hljs-title function_">optimizationsplitChunks</span>(&#123;        <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;all&#x27;</span>,        <span class="hljs-attr">cacheGroups</span>: &#123;          <span class="hljs-attr">vendors</span>: &#123;            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chunk-vendors&#x27;</span>,            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_module[\\/]/</span>,            <span class="hljs-attr">priority</span>: <span class="hljs-number">10</span>,            <span class="hljs-attr">chunks</span>: <span class="hljs-string">&#x27;initial&#x27;</span>          &#125;,          <span class="hljs-attr">echarts</span>: &#123;            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;chunk-echarts&#x27;</span>,            <span class="hljs-attr">priority</span>: <span class="hljs-number">20</span>,            <span class="hljs-attr">test</span>: <span class="hljs-regexp">/[\\/]node_module[\\/]_?echarts(.*)/</span>          &#125;        &#125;      &#125;)    &#125;&#125;</code></pre></div></li><li><p>babel转译优化<br>babel会在在每个需要编译的地方都加上helper函数，造成冗余</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// .babelrc</span><span class="hljs-string">&quot;plugins&quot;</span>: [        <span class="hljs-string">&quot;@babel/plugin-transform-runtime&quot;</span>]<span class="hljs-comment">// 自动移除语法转换后内联的辅助函数（inline Babel helpers），使用@babel/runtime/helpers里的辅助函数来替代；</span></code></pre></div></li><li><p>按需打包组件（如element-ui）和<code>tree shaking</code></p></li><li><p><code>gzip</code>压缩</p><h1 id="【加载阶段】"><a href="#【加载阶段】" class="headerlink" title="【加载阶段】"></a>【加载阶段】</h1><h2 id="白屏loading提示或者骨架屏"><a href="#白屏loading提示或者骨架屏" class="headerlink" title="白屏loading提示或者骨架屏"></a>白屏loading提示或者骨架屏</h2><h2 id="路由懒加载-异步组件"><a href="#路由懒加载-异步组件" class="headerlink" title="路由懒加载/异步组件"></a>路由懒加载/异步组件</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// router</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;  <span class="hljs-attr">routes</span>: [    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;@/components/home&#x27;</span>),    &#125;,    &#123;      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,      <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;@/components/home&#x27;</span>),    &#125;,  ],&#125;)<span class="hljs-comment">// async component</span><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></code></pre></div></li></ul><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 主要逻辑</span><span class="hljs-keyword">const</span> imgList = [...<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectAll</span>(<span class="hljs-string">&#x27;img&#x27;</span>)]<span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyLoad</span>(<span class="hljs-params">imgList</span>)&#123;  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>  <span class="hljs-keyword">const</span> len = imgList.<span class="hljs-property">length</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">let</span> doneList = []    imgList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>&#123;      <span class="hljs-keyword">const</span> react = img.<span class="hljs-title function_">getBoundingClientRect</span>()      <span class="hljs-comment">// Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置</span>      <span class="hljs-keyword">if</span>(react.<span class="hljs-property">top</span>&lt;<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>)&#123;        img.<span class="hljs-property">src</span> = img.<span class="hljs-property">dataset</span>.<span class="hljs-property">src</span>  <span class="hljs-comment">// 在这里赋值图片src</span>        doneList.<span class="hljs-title function_">push</span>(index)        count++        <span class="hljs-keyword">if</span>(count === len)&#123;          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>,lazyLoad)        &#125;      &#125;    &#125;)    imgList = imgList.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">img,index</span>)=&gt;</span>!doneList.<span class="hljs-title function_">includes</span>(i))  &#125;&#125;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>,_.<span class="hljs-title function_">debounce</span>(lazyLoad))<span class="hljs-comment">//</span></code></pre></div><h2 id="虚拟列表"><a href="#虚拟列表" class="headerlink" title="虚拟列表"></a>虚拟列表</h2><p>  动态渲染长列表</p><h2 id="图片占位符"><a href="#图片占位符" class="headerlink" title="图片占位符"></a>图片占位符</h2><p><a href="https://www.npmjs.com/package/sqip">sqip</a></p><h2 id="优化文档结构"><a href="#优化文档结构" class="headerlink" title="优化文档结构"></a>优化文档结构</h2><ul><li><p>css资源请求放在文档最前</p></li><li><p>脚本放在最后且非核心代码异步加载</p><blockquote><p>js脚本组织DOM解析，而css资源又回阻塞js执行</p></blockquote><p>异步加载的方式</p><ol><li>动态创建script标签</li><li>script<code>defer</code></li><li>script<code>async</code><br><img src="../images/script.png" alt="script"></li></ol><ul><li>普通的<code>script</code>，html解析暂停，立即下载和执行这个脚本</li><li><code>&lt;script async&gt;</code>，html解析和该脚本的加载同时进行，下载完后执行脚本时暂停html解析</li><li><code>&lt;script defer&gt;</code>，html解析和该脚本的加载同时进行，脚本在页面解析完成后才执行—&gt;<code>DOMContentLoaded</code> 之前执行</li></ul></li></ul><h2 id="使用CDN"><a href="#使用CDN" class="headerlink" title="使用CDN"></a>使用CDN</h2><ol><li><p>安装<code>html-webpack-plugin</code></p></li><li><p>修改<code>public/index.html</code></p>   <div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span></span><span class="hljs-tag">      <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;</span></span><span class="hljs-tag">    /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span> /&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.css) &#123; %&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">link</span></span><span class="hljs-tag">      <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span></span><span class="hljs-tag">      <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;style&quot;</span></span><span class="hljs-tag">    /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.css[i] %&gt;&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> /&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的CSS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>      <span class="hljs-comment">&lt;!--  --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span>    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>    &lt;% for (var i in htmlWebpackPlugin.options.cdn &amp;&amp;    htmlWebpackPlugin.options.cdn.js) &#123; %&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    &lt;% &#125; %&gt;    <span class="hljs-comment">&lt;!-- 使用CDN的JS文件 --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li><li><p>配置<code>vue.config.js</code></p>   <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 判断生产环境</span><span class="hljs-keyword">const</span> isProduction = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&quot;production&quot;</span>;<span class="hljs-keyword">const</span> cdn = &#123;  <span class="hljs-comment">// 随便抓几个</span>  <span class="hljs-attr">js</span>: [    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.6.0/vue.runtime.esm.js&quot;</span>,    <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.1.3/vue-router.esm.js&quot;</span>  ],&#125;;<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;  <span class="hljs-attr">configureWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.<span class="hljs-property">externals</span> = &#123;        <span class="hljs-comment">// 排除的依赖，不从bundle中引入的依赖</span>        <span class="hljs-string">&quot;vue&quot;</span>: <span class="hljs-string">&quot;Vue&quot;</span>,        <span class="hljs-string">&quot;vue-router&quot;</span>: <span class="hljs-string">&quot;VueRouter&quot;</span>      &#125;;    &#125;  &#125;,  <span class="hljs-attr">chainWebpack</span>: <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (isProduction) &#123;      config.<span class="hljs-title function_">plugin</span>(<span class="hljs-string">&quot;html&quot;</span>).<span class="hljs-title function_">tap</span>(<span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 传递给 html-webpack-plugin&#x27;s 构造函数的新参数</span>        args[<span class="hljs-number">0</span>].<span class="hljs-property">cdn</span> = cdn;        <span class="hljs-keyword">return</span> args;      &#125;);    &#125;  &#125;,&#125;;</code></pre></div></li></ol><h2 id="预解析DNS"><a href="#预解析DNS" class="headerlink" title="预解析DNS"></a>预解析DNS</h2><p><code>DNS Prefetch</code> 是一种DNS 预解析技术，当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。</p><ol><li><p><code>HTTP</code>中浏览器会对<code>&lt;a&gt;标签</code>自动开启dns预解析</p><blockquote><p>对于https页面，大部分浏览器是关闭a标签的dns预解析的</p></blockquote></li><li><p><code>HTTPS</code>用meta信息来告知浏览器, 当前页面要做DNS预解析:<br><code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</code></p></li><li><p>在页面<code>&lt;head&gt;</code>中使用<code>&lt;link&gt;标签</code>来强制对DNS预解析:</p></li></ol><p><code> &lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</code></p><h2 id="预渲染和服务端渲染"><a href="#预渲染和服务端渲染" class="headerlink" title="预渲染和服务端渲染"></a>预渲染和服务端渲染</h2><ul><li><code>SSR:server side render</code></li><li><code>prerender-spa-plugin</code>不适用于个性化的，内容变化大，多路由的页面，可以用来优化单页应用。</li></ul><h1 id="【运行阶段】"><a href="#【运行阶段】" class="headerlink" title="【运行阶段】"></a>【运行阶段】</h1><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li>合理使用浏览器缓存策略</li><li>不频繁操作DOM，使用虚拟DOM或<code>fragment</code>批量操作</li><li>读取元素的位置大小属性（如<code>scrollTop</code>,<code>offsetHeight</code>…）浏览器会立即重排，更不能将这些属性放入循环中</li><li>使用事件委托</li><li>使用<code>Web Worker</code></li><li>使用<code>requestAnimationFrame</code>代替有高性能需求的计时器<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2></li><li>避免<code>css</code>选择器嵌套过深</li><li>避免大量使用<code>id</code>选择器，每个<code>id</code>都会变为一个单独的全局变量</li><li>避免使用<code>table</code>，<code>table</code>会频繁触发重排</li><li>更换<code>class</code>代替直接修改<code>style</code></li><li>合理使用GPU加速<ul><li> <code>css3</code>动画<code>transform</code>代替修改几何信息<code>left,top...</code></li><li> <code>opacity</code>代替<code>visibility</code></li><li> 复杂动画元素脱离文档流<code>position:absolute/fixed</code></li><li> 加上<code>will-change</code>属性的元素会交给合成层渲染（GPU</li></ul></li></ul><h1 id="【资源优化】"><a href="#【资源优化】" class="headerlink" title="【资源优化】"></a>【资源优化】</h1><h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><h3 id="高效图片格式"><a href="#高效图片格式" class="headerlink" title="高效图片格式"></a>高效图片格式</h3><ul><li><a href="https://en.wikipedia.org/wiki/WebP">WebP</a></li><li>矢量图<a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a></li><li>Base64位图 <a href="https://en.wikipedia.org/wiki/Base64">base64</a><h3 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;picture&gt;&lt;source srcset=&quot;banner_w1000.jpg&quot; media=&quot;(min-width: 801px)&quot;&gt;&lt;source srcset=&quot;banner_w800.jpg&quot; media=&quot;(max-width: 800px)&quot;&gt;&lt;img src=&quot;banner_w800.jpg&quot; alt=&quot;&quot;&gt;&lt;/picture&gt;</code></pre></div><h3 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h3></li><li><a href="https://tinypng.com/">tinypng</a></li><li><a href="https://webpack.docschina.org/plugins/image-minimizer-webpack-plugin/#root">webpack插件</a></li></ul><h3 id="小图合并"><a href="#小图合并" class="headerlink" title="小图合并"></a>小图合并</h3><ul><li>合并雪碧图</li><li>使用<code>icon-font</code>字体图标<div class="hljs code-wrapper"><pre><code class="hljs javascript">svg-sprite-loader</code></pre></div></li></ul><h1 id="性能检测报告"><a href="#性能检测报告" class="headerlink" title="性能检测报告"></a>性能检测报告</h1><ul><li><code>Performance</code></li><li><code>Lighthouse</code></li></ul><h2 id="关键时间点"><a href="#关键时间点" class="headerlink" title="关键时间点"></a>关键时间点</h2><ul><li><code>FCP</code>页面上呈现第一DOM元素的时间，之前都是白屏</li><li><code>TTI</code>页面可以交互的时间</li><li><code>LCP</code>视口内最大面积内容渲染时间</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> timing = <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-property">timing</span><span class="hljs-keyword">const</span> navigation = <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">performance</span>.<span class="hljs-property">navigation</span><span class="hljs-comment">// DNS</span><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DNS</span> = timing.<span class="hljs-property">domainLookupEnd</span> - timing.<span class="hljs-property">domainLookupStart</span><span class="hljs-comment">// Network</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">NetWork</span> = timing.<span class="hljs-property">responseEnd</span> - timing.<span class="hljs-property">navigationStart</span><span class="hljs-comment">// 渲染</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">Processing</span> = (timing.<span class="hljs-property">domComplete</span> || timing.<span class="hljs-property">domLoading</span>) - timing.<span class="hljs-property">domLoading</span><span class="hljs-comment">// 可交互</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">Active</span> = timing.<span class="hljs-property">domInteractive</span> = timing.<span class="hljs-property">navigationStart</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生js</title>
    <link href="/2022/02/24/%E5%8E%9F%E7%94%9Fjs/"/>
    <url>/2022/02/24/%E5%8E%9F%E7%94%9Fjs/</url>
    
    <content type="html"><![CDATA[<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><blockquote><p>js 是一门函数优先的轻量级解释型语言，基于原型编程的动态脚本语言</p></blockquote><ol><li>函数是一等公民（变量提升，函数可以作为函数的参数，返回值，可以赋值给变量，【函数式编程的条件】</li><li>面向对象编程</li><li>弱类型语言（变量的类型在运行时会变化，强类型语言的变量类型编译时就确定且不会改变</li><li>基于原型（区别于基于类[类和实例]，js 中万物皆为[对象]<blockquote><p>基于原型的语言具有所谓原型对象（prototypical object）的概念。原型对象可以作为一个模板，新对象可以从中获得原始的属性。任何对象都可以指定其自身的属性，任何对象都可以作为另一个对象的原型（prototype），从而允许后者共享前者的属性。</p></blockquote></li></ol><h2 id="BOM（Browser-Object-Model）-浏览器对象模型"><a href="#BOM（Browser-Object-Model）-浏览器对象模型" class="headerlink" title="BOM（Browser Object Model） 浏览器对象模型"></a>BOM（Browser Object Model） 浏览器对象模型</h2><ul><li><p><code>navigator</code>    用户信息</p><ul><li><code>Navigator.geolocation</code>地理位置</li><li><code>NavigatorID.userAgent</code>用户代理信息</li></ul></li><li><p><code>location</code>    文档位置</p><ul><li><code>location.href/hash/search/domain/path/port/protcol</code></li><li><code>location.reload()</code></li><li><code>location.replace()</code></li></ul></li><li><p><code>history</code>    窗口浏览器历史</p><ul><li><code>history.go()</code></li><li><code>history.back()</code></li><li><code>history.forward()</code></li><li><blockquote><p>window.go(-1) = window.back() + f5 // 丢失表单</p></blockquote></li></ul></li><li><p><code>screen</code> 屏幕信息</p></li></ul><h2 id="DOM-（Document-Object-Model）-文档对象模型"><a href="#DOM-（Document-Object-Model）-文档对象模型" class="headerlink" title="DOM （Document Object Model） 文档对象模型"></a>DOM （Document Object Model） 文档对象模型</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(id);<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(name);<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(name);parentNode.<span class="hljs-title function_">appendChild</span>(node);element.<span class="hljs-property">innerHTML</span>;<span class="hljs-comment">//innerHTML 从对象起始位置到终止位置的全部内容（包括html标签</span><span class="hljs-comment">//outerHTML 包括对象自身标签</span><span class="hljs-comment">//innerText innerHTML但不包括html标签，</span><span class="hljs-comment">//textContent 所有文本内容，包括script和style标签内</span>element.<span class="hljs-property">style</span>.<span class="hljs-property">left</span>;element.<span class="hljs-title function_">setAttribute</span>();element.<span class="hljs-title function_">getAttribute</span>();element.<span class="hljs-title function_">addEventListener</span>();<span class="hljs-variable language_">window</span>.<span class="hljs-property">content</span>;<span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span>;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">dump</span>();<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>();</code></pre></div><h2 id="js严格模式use-strict"><a href="#js严格模式use-strict" class="headerlink" title="js严格模式use strict"></a>js严格模式<code>use strict</code></h2><ol><li>无法意外创建全局变量</li><li>静默失败将会被抛出异常(给不可写属性赋值, 给只读属性赋值, 给不可扩展对象的新属性赋值,删除必可删除的属性…etc)</li><li>函数参数名唯一</li><li>禁止使用<code>with</code></li><li><code>eval()</code>会有自己的作用域</li><li>禁止删除声明变量</li><li>禁止使用<code>.callee</code>和<code>.arguments</code></li><li>保留关键字</li><li>禁止了不在脚本或者函数层面的函数声明 <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123; &#125; <span class="hljs-comment">// !!! 语法错误</span>  <span class="hljs-title function_">f</span>();&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>) &#123; &#125; <span class="hljs-comment">// !!! 语法错误</span>  <span class="hljs-title function_">f2</span>();&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// 合法</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">eit</span>(<span class="hljs-params"></span>) &#123; &#125; <span class="hljs-comment">// 同样合法</span>&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web安全</title>
    <link href="/2022/02/24/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <url>/2022/02/24/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>两个URl <strong>!同协议 !同域名 !同端口</strong></li><li>同源策略限制了同一个源加载的脚本和文档如何与其他源的资源进行交互，包括js脚本，缓存的读取，cookie，ajax等</li><li>三种标签不受同源限制<code>script</code> <code>link</code> <code>img</code></li></ul><h3 id="跨域的方法"><a href="#跨域的方法" class="headerlink" title="跨域的方法"></a>跨域的方法</h3><ul><li><p>代理服务器<code>nginx,各种devServer</code></p></li><li><p><code>document.domain</code></p><p>前提是两个页面主要域相同</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;someWebSite.com/dir1/pageA.html&#x27;</span><span class="hljs-string">&#x27;someWebSite.com/dir2/pageB.html&#x27;</span>都设置<span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;someWebSite.com&#x27;</span>则他们之间通信将通过同源检测，并都访问父源的cookie</code></pre></div></li><li><p><code>window.name</code>  </p></li><li><p><code>postMessage</code></p><p>对新打开的窗口或者iframe的contentWindow属性、执行window.open返回的窗口对象</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-comment">// pageA中代码</span><span class="hljs-variable language_">window</span>.<span class="hljs-property">iframe</span>[i].<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-string">&#x27;pageB的URL&#x27;</span>)<span class="hljs-comment">// pageB中的代码</span><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>)     <span class="hljs-comment">// data</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">source</span>)   <span class="hljs-comment">// a中window的引用</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">origin</span>)  <span class="hljs-comment">// pageA的URL</span>&#125;,<span class="hljs-literal">false</span>)<span class="hljs-comment">// 反过来pageB向pageA发送数据</span><span class="hljs-comment">// 在pageA中加入window.addEventListener</span><span class="hljs-comment">// 在pageB中e.source.postMessage</span></code></pre></div></li><li><p><code>iframe</code>+<code>hash</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// pageA通过iframe嵌入了pageB</span><span class="hljs-keyword">var</span> B = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementByTagName</span>(<span class="hljs-string">&quot;iframe&quot;</span>);B.<span class="hljs-property">src</span> = B.<span class="hljs-property">src</span> + <span class="hljs-string">&quot;#&quot;</span> + <span class="hljs-string">&quot;data&quot;</span>;<span class="hljs-comment">// pageB中的代码</span><span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;data = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>; <span class="hljs-comment">//  &lt;-  pageB就获取到了hash值</span>&#125;;</code></pre></div></li><li><p><code>jsonp</code></p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">&#123; url, params, callback &#125;</span>) &#123;  <span class="hljs-keyword">const</span> attrs = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(params))&#123;    attrs.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>)  &#125;  attrs.<span class="hljs-title function_">push</span>(<span class="hljs-string">`callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>)  url+= attrs.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)    script.<span class="hljs-property">src</span> = url    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);    <span class="hljs-keyword">try</span>&#123;      <span class="hljs-variable language_">window</span>[callback] = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;        <span class="hljs-title function_">resolve</span>(data)        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">removeChild</span>(script)      &#125;    &#125;<span class="hljs-keyword">catch</span>(err)&#123;      <span class="hljs-title function_">reject</span>(err)    &#125;  &#125;)&#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 发送</span><span class="hljs-title function_">jsonp</span>(&#123;<span class="hljs-attr">url</span>: <span class="hljs-string">&quot;http://localhost:3000/jsptest&quot;</span>,<span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">msg</span>: <span class="hljs-string">&quot;jsptestmessage&quot;</span> &#125;,<span class="hljs-attr">callback</span>: <span class="hljs-string">&quot;jsonpCallback&quot;</span>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<span class="hljs-comment">//处理data</span>    &#125;);</code></pre></div></li><li><p><code>imgPing</code><strong>添加img标签src中放入get请求</strong></p><p>只能发送GET请求，无法接受返回</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();img.<span class="hljs-property">onload</span> = img.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;已发送&quot;</span>);&#125;;img.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://xxx.xxx.com/query?key=value&quot;</span>;<span class="hljs-comment">// 设置完src属性那一刻开始请求就发送了</span></code></pre></div></li><li><p><code>CORS</code>跨域资源共享（详见下文）</p></li><li><p><code>websocket</code>协议</p></li><li><p><code>Fetch</code>API</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">postData</span>(<span class="hljs-params">url, data</span>) &#123;<span class="hljs-comment">// Default options are marked with *</span>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url, &#123;      <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-comment">// must match &#x27;Content-Type&#x27; header</span>      <span class="hljs-comment">// ...</span>      <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;cors&quot;</span>, <span class="hljs-comment">// no-cors, cors, *same-origin</span>      <span class="hljs-comment">// ... </span>      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>()); <span class="hljs-comment">// parses response to JSON</span>  &#125;</code></pre></div></li></ul><h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a><code>CORS</code>跨域</h3><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul><li>方法<code>POST</code> <code>GET</code> <code>HEAD</code>,</li><li><code>Content-Type</code>：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><h5 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h5><ul><li><code>request header</code>中添加<code>Origin</code>字段</li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul><li><p><code>Access-Control-Allow-Origin</code>:允许跨域访问的域，可以是一个域的列表，也可以是通配符”*“</p></li><li><p><code>Access-Control-Allow-Credentials</code>:是否允许请求带有 cookie</p><p>如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名</p><p>并且 ajax 中要打开</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;  <span class="language-xml">&lt;-------</span></code></pre></div></li><li><p><code>Access-Control-Expose-Headers</code>: 自定义字段</p></li></ul><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><ul><li>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code></li><li>正式通信前会先发起”预检”请求</li><li>一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样</li></ul><h5 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h5><ul><li><code>OPTIONS</code>请求发送预检请求</li><li><code>Origin</code>来源域</li><li><code>Access-Control-Request-Method</code>接下来请求的方法</li><li><code>Access-Control-Request-Headers</code>自定义首部</li></ul><h5 id="响应-1"><a href="#响应-1" class="headerlink" title="响应"></a>响应</h5><ul><li><code>Access-Control-Allow-Origin</code>允许跨域访问的域</li><li><code>Access-Control-Allow-Methods</code>服务器支持的所有跨域请求的方法</li><li><code>Access-Control-Max-Age</code>预检请求有效期</li><li><code>Access-Control-Allow-Credentials</code>与简单请求相同</li></ul><h2 id="跨页面通信"><a href="#跨页面通信" class="headerlink" title="跨页面通信"></a>跨页面通信</h2><ul><li>透明<code>iframe</code>+<code>postMessage</code></li><li><code>service worker</code>+<code>postMessage</code></li><li>使用<code>localStorage</code>的回调监听变化<code>window.addEventListener(&#39;storage&#39;, e=&gt;e.key)</code></li></ul><h2 id="XSS跨域脚本攻击"><a href="#XSS跨域脚本攻击" class="headerlink" title="XSS跨域脚本攻击"></a>XSS跨域脚本攻击</h2><p><code>Cross-site scripting</code></p><blockquote><p>浏览器渲染过程中执行了预期外的恶意代码</p></blockquote><blockquote><p>XSS利用web开发过程中的漏洞执行攻击</p></blockquote><ul><li><p>存储型XSS</p><p>  input, textarea等）中写入恶意脚本上传到服务器，其他人下载带有该脚本的html页面至浏览器时脚本运行</p></li><li><p>反射型XSS</p><p>  将恶意代码加入<code>URL</code>中提交给服务器，服务器返回内容就带上了恶意代码，浏览器下载页面则执行了恶意代码，服务器不存储恶意代码</p></li><li><p>DOM XSS</p><ul><li>JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等函数</li><li><code>&lt;a&gt;</code>标签的<code>href</code>属性</li><li>DOM中的内联事件监视器,<code>location</code>,<code>onclick</code>,<code>onerror</code>,<code>onload</code>等</li><li>都可以将字符串作为代码执行</li></ul></li></ul><h3 id="防范XSS"><a href="#防范XSS" class="headerlink" title="防范XSS"></a>防范XSS</h3><ul><li><p>使用内容安全策略CSP<code>Content Security Policy</code>,限制该页面可以获取的资源和来源</p></li><li><p>对所有用户提交内容进行可靠的输入验证，包括URL、查询关键字、HTTP头、REFER、POST数据等</p></li><li><p>任何内容输出到页面之前都必须加以<code>en-code</code>编码，避免生成意外的html标签；</p></li><li><p><code>cookie</code> 内不存储敏感信息如账号密码等，并设施<code>http only</code></p></li></ul><h2 id="CSRF跨域请求伪造"><a href="#CSRF跨域请求伪造" class="headerlink" title="CSRF跨域请求伪造"></a>CSRF跨域请求伪造</h2><p><code>Cross-site request forgery</code></p><blockquote><p>利用用户登录态</p></blockquote><h3 id="防御CSRF"><a href="#防御CSRF" class="headerlink" title="防御CSRF"></a>防御CSRF</h3><ul><li>验证<code>http</code>请求的来源<code>origin</code>和<code>referrer</code></li><li>设置<code>cookie</code>的<code>SameSite</code>属性，使<code>cookie</code>只可被第一方使用</li><li>设置客户端请求携带<code>session token</code>，并在服务器端验证<code>token</code></li><li>验证码 </li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="SQl注入"><a href="#SQl注入" class="headerlink" title="SQl注入"></a>SQl注入</h4><ol><li><p>黑客提交畸形数据改变语义提交sql查询得到非法数据</p></li><li><p>防御</p><ol><li>过滤sql保留字</li><li>减少抛出不必要的数据库错误信息</li><li>禁止动态拼接sql语句访问数据库</li></ol></li></ol><h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><ol><li>点击透明iframe</li><li>监听鼠标移动位置</li><li>H5拖拽</li><li>防御：<ol><li>服务端添加 <code>X-Frame-Options</code> 响应头</li><li>js判断顶层视口是否同源</li><li>敏感操作复杂操作（验证码，二次确认</li></ol></li></ol><h4 id="window-opener"><a href="#window-opener" class="headerlink" title="window.opener"></a><code>window.opener</code></h4><ol><li>修改<code>window.opener.location</code>可以改写来源站点的地址</li><li>防御：<ol><li>设置a标签的rel属性<code>rel=noopener</code>,禁止新页面传递源页面地址</li><li>外部链接改为经由服务器跳转</li><li>使用window.open打开外链</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串算法题</title>
    <link href="/2022/02/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h2><ul><li>  <code>charAt()</code> 返回索引位置字符</li><li>  <code>charCodeAt()</code>返回索引位置字符 UTF16 代码</li><li></li><li>  <code>concat()</code> 拼接</li><li>  <code>indexOf()</code>, <code>lastIndexOf()</code> 返回索引</li><li>  <code>includes()</code> 返回 Boolean</li><li>  <code>match()</code> 匹配正则</li><li>  <code>replace()</code> 替换</li><li>  <code>split()</code> 分割字符串</li><li>  <code>slice()</code> 截取返回新字符串，以索引</li><li>  <code>substring()</code> //截取返回新字符串，以长度</li><li>  <code>trim()</code> //删除空格</li><li>  <code>toLowerCase(), toUpperCase()</code></li></ul><h3 id="最长公公前缀"><a href="#最长公公前缀" class="headerlink" title="最长公公前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公公前缀</a></h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><span class="hljs-comment">// 输出: &quot;fl&quot;</span><span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-keyword">function</span> (<span class="hljs-params">strs</span>) &#123;<span class="hljs-keyword">if</span> (!strs.<span class="hljs-property">length</span> || strs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">let</span> prefix = strs[<span class="hljs-number">0</span>]; <span class="hljs-comment">//  第一个字符串作为参考</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; strs.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-comment">// 后续和他比较</span><span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从0索引开始，判断公共部分则j++</span><span class="hljs-keyword">for</span> (; j &lt; prefix.<span class="hljs-property">length</span> &amp;&amp; j &lt; strs[i].<span class="hljs-property">length</span>; j++) &#123;<span class="hljs-keyword">if</span> (prefix[j] !== strs[i][j]) <span class="hljs-keyword">break</span>;&#125;prefix = prefix.<span class="hljs-title function_">substr</span>(<span class="hljs-number">0</span>, j); <span class="hljs-comment">// 和strs[i]比较完后重合的部分</span>&#125;<span class="hljs-keyword">return</span> prefix;&#125;;</code></pre></div><h3 id="连字符转为驼峰"><a href="#连字符转为驼峰" class="headerlink" title="连字符转为驼峰"></a>连字符转为驼峰</h3><div class="hljs code-wrapper"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">toCamelCase</span> = (<span class="hljs-params">str: <span class="hljs-built_in">string</span></span>) =&gt; str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-\w/g</span>, <span class="hljs-function">(<span class="hljs-params">$</span>) =&gt;</span> $.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">toUpperCase</span>());</code></pre></div><h3 id="将字符串改为首字母大写"><a href="#将字符串改为首字母大写" class="headerlink" title="将字符串改为首字母大写"></a>将字符串改为首字母大写</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// -i-hate -_you_</span><span class="hljs-comment">// \b匹配单词边界</span><span class="hljs-comment">// 加上判断是否会有下划线</span><span class="hljs-comment">// \w 字母、数字、下划线</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">firstUpper</span> = (<span class="hljs-params">str: string</span>) =&gt; str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\b_?\w/g</span>, <span class="hljs-function">(<span class="hljs-params">$</span>) =&gt;</span> $.<span class="hljs-title function_">toUpperCase</span>());</code></pre></div><h3 id="反转句子"><a href="#反转句子" class="headerlink" title="反转句子"></a>反转句子</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  正则</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">str</span>) &#123;<span class="hljs-keyword">return</span> str.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);<span class="hljs-comment">// \s \s是指空白,包括空格、换行、tab缩进等所有的空白</span><span class="hljs-comment">// 去除单词之间多余的空白</span>&#125;<span class="hljs-comment">//</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseWords</span>(<span class="hljs-params">str</span>) &#123;<span class="hljs-comment">// 也可以使用string+ &#x27; &#x27;</span><span class="hljs-comment">// 这里使用数组</span><span class="hljs-keyword">let</span> arr = [];str = srt.<span class="hljs-title function_">trim</span>();<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> word = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">// 去除头尾多余空格</span><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<span class="hljs-keyword">let</span> char = str.<span class="hljs-title function_">charAt</span>(left);<span class="hljs-keyword">if</span> (char === <span class="hljs-string">&quot; &quot;</span> &amp;&amp; word) &#123;arr.<span class="hljs-title function_">unshift</span>(word);word = <span class="hljs-string">&quot;&quot;</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char !== <span class="hljs-string">&quot; &quot;</span>) &#123;word += char;&#125;left++;&#125;arr.<span class="hljs-title function_">unshift</span>(word);<span class="hljs-comment">// 上面单词的添加是基于该位置字符是否为空</span><span class="hljs-comment">// 则最后一个单词的末尾非空将不会被添加</span><span class="hljs-comment">// 所以最后加上arr.unshift(word)</span><span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>);&#125;</code></pre></div><h3 id="检查回文"><a href="#检查回文" class="headerlink" title="检查回文"></a>检查回文</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseCheck</span>(<span class="hljs-params">str</span>) &#123;<span class="hljs-keyword">let</span> s = str.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[\W_]/g</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 格式掉不是字母的别的玩意</span><span class="hljs-comment">// | `\W`   | 匹配任意不是字母，数字，下划线 |</span><span class="hljs-comment">// `[]` 字符串用中括号括起来，表示匹配其中的任一字符</span><span class="hljs-keyword">return</span> s === s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 指针</span><span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt; r) &#123;<span class="hljs-keyword">if</span> (str[l++] === str[r--]) &#123;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="最长不重复子串长度"><a href="#最长不重复子串长度" class="headerlink" title="最长不重复子串长度"></a>最长不重复子串长度</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 滑动窗口</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">longest1</span>(<span class="hljs-params">str</span>) &#123;<span class="hljs-keyword">const</span> <span class="hljs-variable language_">window</span> = [];<span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">indexOf</span>(str[i]);<span class="hljs-keyword">if</span> (index !== -<span class="hljs-number">1</span>) &#123;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, index + <span class="hljs-number">1</span>);<span class="hljs-comment">// 有重复值时缩小窗口</span>&#125;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">push</span>(str[i]);<span class="hljs-comment">// 无重复扩大窗口</span>maxLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLen, <span class="hljs-variable language_">window</span>.<span class="hljs-property">length</span>);&#125;<span class="hljs-keyword">return</span> maxLen;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">longest2</span>(<span class="hljs-params">str</span>) &#123;<span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; j &lt; str.<span class="hljs-property">length</span>; j++) &#123;<span class="hljs-keyword">const</span> _index = str.<span class="hljs-title function_">substring</span>(i, j).<span class="hljs-title function_">indexOf</span>(str[j]);<span class="hljs-keyword">if</span> (_index !== -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// _index为重复项位置</span>i += _index + <span class="hljs-number">1</span>;&#125;maxLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxLen, j - i + <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> maxLen;&#125;<span class="hljs-comment">// map + 双指针</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">longest3</span>(<span class="hljs-params">str</span>) &#123;<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<span class="hljs-keyword">let</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-comment">// 设 i 位置右侧字符无重复</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; str.<span class="hljs-property">length</span>; j++) &#123;<span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(str[j])) &#123;i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(map.<span class="hljs-title function_">get</span>(str[j]) + <span class="hljs-number">1</span>, i);<span class="hljs-comment">// Math.max:检测到重复，更新i的位置，注意不一定是str[j]+1，str[j]+1不一定比上一个重复元素的查重位置更靠后</span><span class="hljs-comment">// 3 =&gt; 0</span><span class="hljs-comment">// 2 =&gt; 1</span><span class="hljs-comment">// 1 =&gt; 2</span><span class="hljs-comment">// 1 =&gt; has , i = 3 // 检测到重复移动左指针</span><span class="hljs-comment">// 3 =&gt; has , i = Math.max((0+1),3) = 3</span><span class="hljs-comment">// 2 =&gt; has , i = Math.max(3,1) = 3</span><span class="hljs-comment">// [3,2,1,1,3,2] 3查重的位置明显小于1查重</span>&#125;map.<span class="hljs-title function_">set</span>(str[j], j);maxLen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(j - i + <span class="hljs-number">1</span>, maxLen);&#125;&#125;</code></pre></div><h3 id="计算二进制数中-1-的个数"><a href="#计算二进制数中-1-的个数" class="headerlink" title="计算二进制数中 1 的个数"></a>计算二进制数中 1 的个数</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// n 为32位二进制数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">hammingWeight1</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-keyword">const</span> numStr = n.<span class="hljs-title function_">toString</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 转为二进制后记数</span><span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; numStr.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (numStr[i] === <span class="hljs-string">&quot;1&quot;</span>) &#123;showTimes++;&#125;&#125;<span class="hljs-keyword">return</span> showTimes;&#125;<span class="hljs-comment">// 位运算</span><span class="hljs-comment">// &gt;&gt;&gt; 无符号向右移</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">hammingWeight2</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;showTimes += n &amp; <span class="hljs-number">1</span>;<span class="hljs-comment">// &amp;运算，1的二进制为1</span><span class="hljs-comment">// 则左右都为1时输出1</span>n &gt;&gt;&gt;= <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> showTimes;&#125;<span class="hljs-comment">// 整体n &amp;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">hammingWeight3</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-keyword">let</span> showTimes = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;showTimes++;n &amp;= n - <span class="hljs-number">1</span>;<span class="hljs-comment">// 二进制 - 中</span><span class="hljs-comment">// n-1 相当 于n把最右边的1变为0,其后面的0变为1</span><span class="hljs-comment">// n与n-1进行与运算,1&amp;1=1,即只改变了最右边第一个1</span><span class="hljs-comment">// n       =&gt; 0001100</span><span class="hljs-comment">// n-1     =&gt; 0001011</span><span class="hljs-comment">// n&amp;(n-1) =&gt; 0001000</span><span class="hljs-comment">// n-1     =&gt; 0000111</span><span class="hljs-comment">// n&amp;(n-1) =&gt; 0000000</span><span class="hljs-comment">// 跳出循环</span>&#125;<span class="hljs-keyword">return</span> showTimes;&#125;</code></pre></div><h3 id="请实现一个函数用来判断字符串是否表示数值（包括整数和小数）"><a href="#请实现一个函数用来判断字符串是否表示数值（包括整数和小数）" class="headerlink" title="请实现一个函数用来判断字符串是否表示数值（包括整数和小数）"></a>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numberCheck</span>(<span class="hljs-params">s</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\s$/</span>.<span class="hljs-title function_">test</span>(s)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Number</span>(s).<span class="hljs-title function_">toString</span>() !== <span class="hljs-string">&quot;NaN&quot;</span>;&#125;</code></pre></div><h3 id="千分位加逗号"><a href="#千分位加逗号" class="headerlink" title="千分位加逗号"></a>千分位加逗号</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numFormat</span>(<span class="hljs-params">num</span>) &#123;<span class="hljs-keyword">var</span> res = num.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d+/</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<span class="hljs-comment">// 整数部分</span><span class="hljs-keyword">return</span> n.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d(?=(\d&#123;3&#125;)+$)/g</span>, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">1</span></span>) =&gt;</span> $<span class="hljs-number">1</span> + <span class="hljs-string">&quot;,&quot;</span>);&#125;);<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// or</span><span class="hljs-title class_">Number</span>.<span class="hljs-title function_">toLocaleString</span>();</code></pre></div><h3 id="解析-URL-参数"><a href="#解析-URL-参数" class="headerlink" title="解析 URL 参数"></a>解析 URL 参数</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseQueryString</span>(<span class="hljs-params">url</span>) &#123;<span class="hljs-keyword">const</span> rule = <span class="hljs-regexp">/([^?=&amp;]+)=([^&amp;#]*)/g</span>;<span class="hljs-keyword">return</span> url.<span class="hljs-property">match</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<span class="hljs-keyword">const</span> [key, value] = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;=&quot;</span>);k = <span class="hljs-built_in">decodeURIComponent</span>(key);v = <span class="hljs-built_in">decodeURIComponent</span>(value);a[k] = a[k] ? [...a[k], value] : value;<span class="hljs-keyword">return</span> a;&#125;, &#123;&#125;);&#125;</code></pre></div><h3 id="字符串相加-大数相加"><a href="#字符串相加-大数相加" class="headerlink" title="字符串相加/大数相加"></a>字符串相加/大数相加</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">stringAdd</span>(<span class="hljs-params">num1, num2</span>) &#123;<span class="hljs-keyword">let</span> l1 = num1.<span class="hljs-property">length</span>;<span class="hljs-keyword">let</span> l2 = num2.<span class="hljs-property">length</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-comment">// 进位</span><span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (l1 || l2) &#123;<span class="hljs-keyword">if</span> (l1) carry += +num1[--l1];<span class="hljs-keyword">if</span> (l2) carry += +num2[--l2];<span class="hljs-comment">// 当前位</span>res = (carry % <span class="hljs-number">10</span>) + res;<span class="hljs-comment">// 计算出超过十的进位</span>carry = carry &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;&#125;<span class="hljs-keyword">if</span> (carry) res = carry + res;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="字符串相乘-大数相乘"><a href="#字符串相乘-大数相乘" class="headerlink" title="字符串相乘/大数相乘"></a>字符串相乘/大数相乘</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">stringMulti</span>(<span class="hljs-params">x, y</span>) &#123;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;0&quot;</span> || y === <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> y;<span class="hljs-keyword">if</span> (y === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">const</span> len1 = x.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> len2 = y.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len1 + len2).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> num1, num2;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;num1 = x[i];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;num2 = y[j];multi = num1 * num2;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;multi&quot;</span> + multi);<span class="hljs-comment">// 参考乘法草稿</span><span class="hljs-keyword">const</span> cur = multi + pos[i + j + <span class="hljs-number">1</span>];<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;cur&quot;</span> + cur);<span class="hljs-comment">// 进位</span>pos[i + j] += (cur / <span class="hljs-number">10</span>) | <span class="hljs-number">0</span>;<span class="hljs-comment">// 余数</span>pos[i + j + <span class="hljs-number">1</span>] = cur % <span class="hljs-number">10</span>;&#125;&#125;<span class="hljs-keyword">let</span> res = pos.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-keyword">while</span> (res[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;0&quot;</span>) &#123;res = res.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="实现一个trim函数"><a href="#实现一个trim函数" class="headerlink" title="实现一个trim函数"></a>实现一个<code>trim</code>函数</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// trim 返回去除了首尾空白的字符串</span><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_trim</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-comment">//1.regexp</span><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\s+$/</span>, <span class="hljs-string">&quot;&quot;</span>);&#125;;<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_trim</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">const</span> str = <span class="hljs-variable language_">this</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">let</span> trimFlag = <span class="hljs-literal">true</span>;<span class="hljs-keyword">let</span> tailIndex; <span class="hljs-comment">// 找出最后一个不是空格的索引</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = str.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">if</span> (str[j] !== <span class="hljs-string">&quot; &quot;</span>) &#123;tailIndex = j;<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-comment">// 越过末位后又开始忽略空格</span><span class="hljs-keyword">if</span> (i &gt;= tailIndex) &#123;trimFlag = <span class="hljs-literal">true</span>;&#125;<span class="hljs-keyword">if</span> (str[i] === <span class="hljs-string">&quot; &quot;</span> &amp;&amp; trimFlag) &#123;<span class="hljs-keyword">continue</span>;&#125; <span class="hljs-keyword">else</span> &#123;trimFlag = <span class="hljs-literal">false</span>;res += str[i];&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="实现前缀树-prefixTree"><a href="#实现前缀树-prefixTree" class="headerlink" title="实现前缀树 prefixTree"></a>实现前缀树 prefixTree</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrefixTree</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">tree</span> = &#123;&#125;;&#125;<span class="hljs-title class_">PrefixTree</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">insert</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<span class="hljs-comment">// 依次将单词的每个字母向tree对象中递归添加属性</span><span class="hljs-comment">// msy= &gt;</span><span class="hljs-comment">// &#123;m:&#123;s:&#123;y:&#123;isEnd:true&#125;&#125;&#125;&#125;</span><span class="hljs-keyword">let</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tree</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> word) &#123;<span class="hljs-keyword">if</span> (!node[n]) node[n] = &#123;&#125;;node = node[n];&#125;node.<span class="hljs-property">isEnd</span> = <span class="hljs-literal">true</span>;&#125;;<span class="hljs-title class_">PrefixTree</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">loop</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<span class="hljs-keyword">let</span> node = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tree</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> word) &#123;<span class="hljs-keyword">if</span> (!node[n]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;node = node[n];&#125;<span class="hljs-keyword">return</span> node;&#125;;<span class="hljs-title class_">PrefixTree</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">search</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">word</span>) &#123;<span class="hljs-keyword">const</span> ret = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loop</span>(word);<span class="hljs-keyword">return</span> ret !== <span class="hljs-literal">undefined</span> &amp;&amp; ret.<span class="hljs-property">isEnd</span> === <span class="hljs-literal">true</span>;&#125;;<span class="hljs-title class_">PrefixTree</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">startWith</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loop</span>(prefix);&#125;;</code></pre></div><h3 id="自定义字符串排序"><a href="#自定义字符串排序" class="headerlink" title="自定义字符串排序"></a><a href="https://leetcode-cn.com/problems/custom-sort-string/submissions/">自定义字符串排序</a></h3><p>将 s 字符串中的字符按照 order 字符串中的前后顺序进行排序</p><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">输入: order = <span class="hljs-string">&quot;cba&quot;</span>, s = <span class="hljs-string">&quot;abcd&quot;</span>输出: <span class="hljs-string">&quot;cbad&quot;</span>解释:“<span class="hljs-keyword">a</span>”、“b”、“c”是按顺序出现的，所以“<span class="hljs-keyword">a</span>”、“b”、“c”的顺序应该是“c”、“b”、“<span class="hljs-keyword">a</span>”。因为“d”不是按顺序出现的，所以它可以在返回的字符串中的任何位置。“dcba”、“cdba”、“cbda”也是有效的输出。</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> customSort = <span class="hljs-keyword">function</span> (<span class="hljs-params">order, s</span>) &#123;<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> str <span class="hljs-keyword">of</span> order) &#123;<span class="hljs-comment">// Map是有序的，保证遍历map的顺序就是order的顺序,</span>map.<span class="hljs-title function_">set</span>(str, <span class="hljs-number">0</span>); <span class="hljs-comment">// 首先假设这个位置的str出现了0次</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> str <span class="hljs-keyword">of</span> s) &#123;map.<span class="hljs-title function_">set</span>(str, map.<span class="hljs-title function_">get</span>(str) ? map.<span class="hljs-title function_">get</span>(str) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>); <span class="hljs-comment">// 遍历s，查找是否存在在map上,存储这个字符出现的次数</span>&#125;res = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [str, time] <span class="hljs-keyword">of</span> map) &#123;<span class="hljs-comment">// 按照顺序遍历map给res添加字符</span>res += str.<span class="hljs-title function_">repeat</span>(time);&#125;<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div><h3 id="版本号排序"><a href="#版本号排序" class="headerlink" title="版本号排序"></a>版本号排序</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 0.0.1 , 0.2.1</span><span class="hljs-keyword">const</span> versions = [<span class="hljs-string">&quot;9.0.1&quot;</span>, <span class="hljs-string">&quot;0.1.2&quot;</span>, <span class="hljs-string">&quot;0.3.1&quot;</span>, <span class="hljs-string">&quot;1.0.0&quot;</span>];<span class="hljs-keyword">function</span> <span class="hljs-title function_">sort</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> <span class="hljs-title class_">Arr</span> = a.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<span class="hljs-keyword">let</span> <span class="hljs-title class_">Brr</span> = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>);<span class="hljs-keyword">while</span> (<span class="hljs-title class_">Arr</span>.<span class="hljs-property">length</span> || <span class="hljs-title class_">Brr</span>.<span class="hljs-property">length</span>) &#123;<span class="hljs-keyword">let</span> A = <span class="hljs-title class_">Arr</span>.<span class="hljs-title function_">shift</span>() || <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> B = <span class="hljs-title class_">Brr</span>.<span class="hljs-title function_">shift</span>() || <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (A - B !== <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> A - B;&#125;&#125;&#125;);&#125;</code></pre></div><h3 id="字母的所有组合"><a href="#字母的所有组合" class="headerlink" title="字母的所有组合"></a>字母的所有组合</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">anagrams</span> = str =&gt; &#123;  <span class="hljs-keyword">if</span>(str.<span class="hljs-property">length</span>===<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> [str , str[<span class="hljs-number">1</span>] + str[<span class="hljs-number">0</span>]]  <span class="hljs-comment">// 手写长度为2时候的排列</span>  <span class="hljs-comment">// 这里使用reduce的第三个参数index，正在处理的元素</span>  <span class="hljs-comment">// 如果提供了initialValue，则起始索引号为0，否则从索引1起始。</span>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc,cur,index</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> other = str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,index)+str.<span class="hljs-title function_">slice</span>(index+<span class="hljs-number">1</span>)    <span class="hljs-comment">// other为除了当前处理元素外的字母</span>    <span class="hljs-comment">// a bcd =&gt;</span>    <span class="hljs-comment">// b cd =&gt; bcd bdc</span>    <span class="hljs-comment">// c bd =&gt; cbd cdb</span>    <span class="hljs-comment">// d bc =&gt; dbc dcb</span>    <span class="hljs-comment">// b...</span>    <span class="hljs-keyword">return</span> acc.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">anagrams</span>(other).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">char</span>=&gt;</span>cur+char))    <span class="hljs-comment">// 递归至两位数数组颠倒排序,并将所有可能与当前处理元素组合</span>  &#125;,[])  <span class="hljs-comment">// 指定initialValue</span>&#125;<span class="hljs-title function_">anagrams</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>) =&gt; [  <span class="hljs-string">&#x27;abcd&#x27;</span>, <span class="hljs-string">&#x27;abdc&#x27;</span>, <span class="hljs-string">&#x27;acbd&#x27;</span>,  <span class="hljs-string">&#x27;acdb&#x27;</span>, <span class="hljs-string">&#x27;adbc&#x27;</span>, <span class="hljs-string">&#x27;adcb&#x27;</span>,  <span class="hljs-string">&#x27;bacd&#x27;</span>, <span class="hljs-string">&#x27;badc&#x27;</span>, <span class="hljs-string">&#x27;bcad&#x27;</span>,  <span class="hljs-string">&#x27;bcda&#x27;</span>, <span class="hljs-string">&#x27;bdac&#x27;</span>, <span class="hljs-string">&#x27;bdca&#x27;</span>,  <span class="hljs-string">&#x27;cabd&#x27;</span>, <span class="hljs-string">&#x27;cadb&#x27;</span>, <span class="hljs-string">&#x27;cbad&#x27;</span>,  <span class="hljs-string">&#x27;cbda&#x27;</span>, <span class="hljs-string">&#x27;cdab&#x27;</span>, <span class="hljs-string">&#x27;cdba&#x27;</span>,  <span class="hljs-string">&#x27;dabc&#x27;</span>, <span class="hljs-string">&#x27;dacb&#x27;</span>, <span class="hljs-string">&#x27;dbac&#x27;</span>,  <span class="hljs-string">&#x27;dbca&#x27;</span>, <span class="hljs-string">&#x27;dcab&#x27;</span>, <span class="hljs-string">&#x27;dcba&#x27;</span>]</code></pre></div><h3 id="字符串按字母排序"><a href="#字符串按字母排序" class="headerlink" title="字符串按字母排序"></a>字符串按字母排序</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sortCharactersInString</span> = (<span class="hljs-params">str</span>) =&gt;str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-title function_">localeCompare</span>(b)).<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// sortCharactersInString(&#x27;cabbage&#x27;) -&gt; &#x27;aabbceg&#x27;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆及相关算法</title>
    <link href="/2022/02/24/%E5%A0%86/"/>
    <url>/2022/02/24/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>堆就是完全二叉树</p><div class="hljs code-wrapper"><pre><code class="hljs">完全二叉树：除了深度最深的一层外所有层节点数都满员深度：从根节点到该节点经历的节点个数</code></pre></div></li><li><p>每一个节点都比左右子节点大–&gt;最大堆，最大值在根节点</p></li><li><p>每一个节点都比左右子节点小–&gt;最小堆，最小值在根节点</p></li><li><p>完全二叉树可以使用数组来存储</p></li></ul><h3 id="建立堆"><a href="#建立堆" class="headerlink" title="建立堆"></a>建立堆</h3><ul><li>将节点与父节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//小顶堆</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildHeap</span>(<span class="hljs-params">items,heapSize</span>)&#123;  <span class="hljs-keyword">while</span>(heapSize&lt;items.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// items 第一个是&lt;empty item&gt;</span>    heapSize++    <span class="hljs-title function_">heapify</span>(items,heapSize)  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">items,i</span>)&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span> &amp;&amp; items[i] &lt; items[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)])&#123;    [items[i],items[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)]] =  [items[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)],items[i]]    <span class="hljs-comment">// 交换位置</span>    i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)  &#125; &#125;</code></pre></div><ul><li>将节点与子节点比较</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//大顶堆</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">buildHeap</span>(<span class="hljs-params">items</span>)&#123;  <span class="hljs-keyword">const</span> heapSize = items.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// &lt;-- items.length - 1 !</span>  <span class="hljs-comment">// 最后叶子节点的索引值</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123; <span class="hljs-comment">// &lt;-i&gt;=1 !</span>    <span class="hljs-comment">// i 为最后一个非 叶子 节点的索引，i还有子节点</span>    <span class="hljs-title function_">heapify</span>(items,heapSize,i)  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">items, heapSize, i</span>) &#123;  <span class="hljs-comment">// 自上而下式堆化</span>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;      <span class="hljs-keyword">var</span> maxIndex = i;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>          maxIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[maxIndex] &lt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;          maxIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (maxIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[maxIndex]] = [items[maxIndex],items[i]]      i = maxIndex;   &#125;&#125;</code></pre></div><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>建立大顶堆/小顶堆</li><li>则索引1位置为当前堆的 最大值/最小值</li><li>循环将[1]与[末尾]交换位置，并且缩小堆的大小（相当于将上一次的最值移出堆）</li><li>一直堆化</li><li>大顶堆得到升序 / 小顶堆得到降序排列</li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>)&#123;  <span class="hljs-comment">// 输入需要为[,]</span>  <span class="hljs-comment">// const heap = [,]</span>  <span class="hljs-comment">// let i = 0</span>  <span class="hljs-comment">// while(i&lt;arr.length)&#123;</span>  <span class="hljs-comment">//   heap.push(arr[i++])</span>  <span class="hljs-comment">// &#125;</span>  <span class="hljs-keyword">const</span> heapSize  =  arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>  <span class="hljs-title function_">buildHeap</span>(arr,heapSize)    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = heapSize ; i&gt;<span class="hljs-number">1</span> ;i--)&#123;    [arr[i],arr[<span class="hljs-number">1</span>]]=[arr[<span class="hljs-number">1</span>],arr[i]]    heapSize --    <span class="hljs-title function_">heapify</span>(arr,heapSize,<span class="hljs-number">1</span>)  &#125;  <span class="hljs-keyword">return</span> arr&#125;</code></pre></div><h3 id="topK问题"><a href="#topK问题" class="headerlink" title="topK问题"></a>topK问题</h3><p>求出前k个最大/最小值，或者出现次数最多/最少的k个值</p><ul><li>求大值，建立最小堆</li><li>求小值，建立最大堆<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如求前k个最大值</span><span class="hljs-comment">// 先用前k个数据建立小顶堆</span><span class="hljs-comment">// 为什么求前k大建立小顶堆？？？</span><span class="hljs-comment">// 如果建立大顶堆，交换堆顶后，堆顶依然是最大的，依次比较之后的数据只会改变堆顶而已，收集不了别的值</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">topK</span>(<span class="hljs-params">data,k</span>)&#123;  <span class="hljs-keyword">let</span> heap = [,...data]  <span class="hljs-keyword">const</span> heapSize = k  <span class="hljs-title function_">buildHeap</span>(heap,heapSize)  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = k ; j &lt;data.<span class="hljs-property">length</span> ;j++)&#123;    <span class="hljs-comment">// 将余下的数据依次与堆顶比较</span>    <span class="hljs-comment">// 比小顶堆的堆顶大则交换</span>    <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; data[j])&#123;      heap[<span class="hljs-number">1</span>] = data[j]      <span class="hljs-title function_">heapify</span>(heap,k,<span class="hljs-number">1</span>)    &#125;  &#125;  heap.<span class="hljs-title function_">shift</span>()  <span class="hljs-keyword">return</span> heap&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildHeap</span>(<span class="hljs-params">items ,heapSize</span>)&#123;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(heapSize/<span class="hljs-number">2</span>) ; i &gt;= <span class="hljs-number">1</span> ; i--)&#123;    <span class="hljs-title function_">heapify</span>(items,heapSize,i)  &#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">items,heapSize,i</span>)&#123;  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">let</span> minIndex = i    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>] ) &#123;        <span class="hljs-comment">// 这里的等号意味着万一这个节点是最后的节点呢</span>        minIndex = i*<span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; items[minIndex] &gt; items[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>] ) &#123;        minIndex = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">if</span> (minIndex === i) <span class="hljs-keyword">break</span>;      [items[i],items[minIndex]] = [items[minIndex],items[i]]      i = minIndex;   &#125;&#125;</code></pre></div></li></ul><h3 id="中位数问题"><a href="#中位数问题" class="headerlink" title="中位数问题"></a>中位数问题</h3><p><code>n</code>个数据中的中位数</p><div class="hljs code-wrapper"><pre><code class="hljs">  [1,2,3] =&gt; 2  [1,2,3,4] =&gt; 2,3  当 n % 2 !== 0 时，中位数为：arr[(n-1)/2]  当 n % 2 === 0 时，中位数为：arr[n/2], arr[n/2 + 1]</code></pre></div><ul><li><p>将前<code>n/2//偶数</code>||<code>（Math.floor(n/2)）+ 1//奇数</code>堆化为大顶堆，后<code>Math.floor(n/2)</code>堆化为小顶堆。</p></li><li><p>结果分别为两个堆顶<code>偶数</code>/前面的堆顶<code>奇数</code></p></li><li><p>动态数组，则把插入的数据与堆顶比较</p><ul><li>【升序】大于大顶堆的顶则加入小顶堆</li><li>【降序】小于小顶堆则加入大顶堆</li><li> 加入后再次堆化，如果堆大小不满足分割中位数要求则继续调整</li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Median</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxHeap</span>()  <span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinHeap</span>()&#125;<span class="hljs-title class_">Median</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">addNum</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>)&#123;  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getTop</span>() || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getSize</span>())&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">insert</span>(num)  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span>.<span class="hljs-title function_">insert</span>(num)  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getSize</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span>.<span class="hljs-title function_">getSize</span>() &gt; <span class="hljs-number">1</span>)&#123;    <span class="hljs-comment">//奇数分布</span>    <span class="hljs-comment">//大顶堆size比小顶堆大1</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span>.<span class="hljs-title function_">insert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">rmTop</span>())    <span class="hljs-comment">//不符合则大顶堆顶插入小顶堆</span>  &#125;  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span>.<span class="hljs-title function_">getSize</span>() &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getSize</span>())&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">insert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span>.<span class="hljs-title function_">rmTop</span>())    <span class="hljs-comment">// </span>  &#125;&#125;<span class="hljs-title class_">Median</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getMedianNum</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-comment">// return console.log(this.maxHeap.getSize());</span>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getSize</span>() &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getSize</span>() === <span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span>.<span class="hljs-title function_">getSize</span>())&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getTop</span>() + <span class="hljs-variable language_">this</span>.<span class="hljs-property">minHeap</span>.<span class="hljs-title function_">getTop</span>())/<span class="hljs-number">2</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxHeap</span>.<span class="hljs-title function_">getTop</span>()&#125;<span class="hljs-comment">// 大顶堆</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">MaxHeap</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getSize</span> = <span class="hljs-function">() =&gt;</span> heap.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getTop</span> = <span class="hljs-function">() =&gt;</span> heap.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">insert</span> = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    <span class="hljs-comment">//插入式建堆</span>    heap.<span class="hljs-title function_">push</span>(num)    <span class="hljs-keyword">let</span> i = heap.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>    <span class="hljs-comment">// push 进去的索引</span>    <span class="hljs-keyword">while</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &gt; heap[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 大顶堆，与父节点比较，大于则交换</span>      [heap[i],heap[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">rmTop</span> = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.<span class="hljs-title function_">pop</span>()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.<span class="hljs-title function_">pop</span>()<span class="hljs-comment">// 拿走了top值，并用末尾节点填充</span>    <span class="hljs-title function_">heapify</span>(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  <span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = i =&gt; &#123;    <span class="hljs-comment">// 堆化</span>    <span class="hljs-keyword">const</span> heapSize = heap.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> maxIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &gt; heap[i]) maxIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &gt; heap[maxIndex]) maxIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> <span class="hljs-comment">// !!!!!!</span>      <span class="hljs-keyword">if</span>(maxIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[maxIndex]] = [heap[maxIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = maxIndex    &#125;  &#125;&#125;<span class="hljs-comment">// 小顶堆</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">MinHeap</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">const</span> heap = [,]  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getSize</span> = <span class="hljs-function">() =&gt;</span> heap.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getTop</span> = <span class="hljs-function">() =&gt;</span> heap.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> ? heap[<span class="hljs-number">1</span>] : <span class="hljs-literal">null</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">insert</span> = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;    heap.<span class="hljs-title function_">push</span>(num)    <span class="hljs-keyword">let</span> i = heap.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)&gt;<span class="hljs-number">0</span> &amp;&amp; heap[i] &lt; heap[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)])&#123;      <span class="hljs-comment">// 小顶堆，与父节点比较，小于则交换</span>      [heap[i],heap[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)]] = [heap[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)],heap[i]]      i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(i/<span class="hljs-number">2</span>)    &#125;  &#125;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">rmTop</span> = <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(!heap.<span class="hljs-property">length</span>&gt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">if</span>(heap.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> heap.<span class="hljs-title function_">pop</span>()    <span class="hljs-keyword">const</span> num = heap[<span class="hljs-number">1</span>]    heap[<span class="hljs-number">1</span>] = heap.<span class="hljs-title function_">pop</span>()    <span class="hljs-title function_">heapify</span>(<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> num  &#125;  <span class="hljs-keyword">const</span> <span class="hljs-title function_">heapify</span> = i =&gt; &#123;    <span class="hljs-keyword">const</span> heapSize = heap.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;      <span class="hljs-keyword">let</span> minIndex = i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i] &lt; heap[i]) minIndex = <span class="hljs-number">2</span>*i      <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; heap[minIndex]) minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>      <span class="hljs-keyword">if</span>(minIndex === i) <span class="hljs-keyword">break</span>      [heap[i],heap[minIndex]] = [heap[minIndex],heap[i]]      <span class="hljs-comment">// 重新赋值i开始下级循环</span>      i = minIndex    &#125;  &#125;&#125;<span class="hljs-comment">// 二分查找法</span><span class="hljs-keyword">const</span> <span class="hljs-title class_">MedianFinder</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = []&#125;<span class="hljs-title class_">MedianFinder</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">addMun</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>)&#123;  <span class="hljs-keyword">const</span> data = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>  <span class="hljs-keyword">if</span>(data.<span class="hljs-property">length</span>&lt;<span class="hljs-number">1</span>)&#123;    data.<span class="hljs-title function_">push</span>(num)    <span class="hljs-keyword">return</span>   &#125;  <span class="hljs-keyword">let</span> L = <span class="hljs-number">0</span>  <span class="hljs-keyword">let</span> R = data.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>  <span class="hljs-keyword">while</span>(L&lt;=R)&#123;    <span class="hljs-keyword">let</span> M = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((L+R)/<span class="hljs-number">2</span>)    <span class="hljs-keyword">if</span>(data[M]===num)&#123;      data.<span class="hljs-title function_">splice</span>(M,<span class="hljs-number">0</span>,num)      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(data[M]&lt;num)&#123;      L ++    &#125;<span class="hljs-keyword">else</span>&#123;      R --    &#125;  &#125;  data.<span class="hljs-title function_">splice</span>(R+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,num)&#125;<span class="hljs-title class_">MedianFinder</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">findMedian</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">length</span>  <span class="hljs-keyword">if</span>(!len) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((len-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)  <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>===<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[mid]+ <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[mid+<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>[mid]  &#125;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工程化批处理</title>
    <link href="/2022/02/24/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/02/24/%E6%89%B9%E9%87%8F%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="1-批量注册中间件"><a href="#1-批量注册中间件" class="headerlink" title="1. 批量注册中间件"></a>1. 批量注册中间件</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers中controllerA.<span class="hljs-property">js</span>controllerB.<span class="hljs-property">js</span>controllerC.<span class="hljs-property">js</span></code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript">./controllers/index.<span class="hljs-property">js</span><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-comment">/**</span><span class="hljs-comment"> * 映射文件夹下的文件为模块</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> <span class="hljs-title function_">mapDir</span> = d =&gt; &#123;    <span class="hljs-keyword">const</span> tree = &#123;&#125;    <span class="hljs-comment">// 获得当前文件夹下的所有的文件夹和文件</span>    <span class="hljs-keyword">const</span> [dirs, files] = <span class="hljs-title function_">_</span>(fs.<span class="hljs-title function_">readdirSync</span>(d))        .<span class="hljs-title function_">partition</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> fs.<span class="hljs-title function_">statSync</span>(path.<span class="hljs-title function_">join</span>(d, p)).<span class="hljs-title function_">isDirectory</span>())    <span class="hljs-comment">// _(value)</span>    <span class="hljs-comment">// 创建一个经 lodash 包装后的对象会启用隐式链。返回的数组、集合、方法相互之间能够链式调用</span>    <span class="hljs-comment">// 递归映射文件夹</span>    dirs.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> &#123;        tree[dir] = <span class="hljs-title function_">mapDir</span>(path.<span class="hljs-title function_">join</span>(d, dir))    &#125;)    <span class="hljs-comment">// 映射文件</span>    files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (path.<span class="hljs-title function_">extname</span>(file) === <span class="hljs-string">&#x27;.js&#x27;</span>) &#123;            tree[path.<span class="hljs-title function_">basename</span>(file, <span class="hljs-string">&#x27;.js&#x27;</span>)] = <span class="hljs-built_in">require</span>(path.<span class="hljs-title function_">join</span>(d, file))        &#125;    &#125;)    <span class="hljs-keyword">return</span> tree&#125;<span class="hljs-comment">// 默认导出当前文件夹下的映射</span><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">mapDir</span>(path.<span class="hljs-title function_">join</span>(__dirname))</code></pre></div><ul><li>  使用</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> controllers = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;../controllers&quot;</span>);router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/A&quot;</span>, controllers.<span class="hljs-property">controllerA</span>);router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/B&quot;</span>, controllers.<span class="hljs-property">controllerB</span>);router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/C&quot;</span>, controllers.<span class="hljs-property">controllerC</span>);</code></pre></div><h2 id="2-批量注册路由"><a href="#2-批量注册路由" class="headerlink" title="2. 批量注册路由"></a>2. 批量注册路由</h2><ul><li>  <code>/routes/...</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">/a.<span class="hljs-property">js</span>&#123;    <span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa-router&#x27;</span>)()    router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/xxx&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;        ctx.....    &#125;)    <span class="hljs-keyword">return</span> router&#125;...b.<span class="hljs-property">js</span>c.<span class="hljs-property">js</span>d.<span class="hljs-property">js</span></code></pre></div><ul><li>  <code>/router/index.js</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;koa-router&quot;</span>)();<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<span class="hljs-keyword">const</span> <span class="hljs-title function_">mapRoutes</span> = (<span class="hljs-params">filePath</span>) =&gt; &#123;<span class="hljs-keyword">const</span> files = fs.<span class="hljs-title function_">readdirSync</span>(filePath); <span class="hljs-comment">//将当前目录下 都读出来</span>files.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<span class="hljs-comment">// 过滤</span><span class="hljs-keyword">if</span> (filePath !== __dirname &amp;&amp; file === <span class="hljs-string">&quot;index.js&quot;</span>) &#123;<span class="hljs-comment">//读取的时候会将当前目录的 index.js 也读取出来，这个不需要，如果拿到别的地方可以不加这个判断</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;routes module must not be &#x27;index.js&#x27; &quot;</span>);&#125;<span class="hljs-keyword">return</span> file !== <span class="hljs-string">&quot;index.js&quot;</span>;&#125;) <span class="hljs-comment">// 将 index.js 过滤掉，路由名字一律不能用 index.js 命名，否则不生效，我这里边的 index.js 如果拿到外面就不用添加这个判断了 ...</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> newFilePath = path.<span class="hljs-title function_">join</span>(filePath, file);<span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">statSync</span>(newFilePath).<span class="hljs-title function_">isDirectory</span>()) &#123;<span class="hljs-comment">// 是目录</span><span class="hljs-title function_">loadRoutes</span>(newFilePath); <span class="hljs-comment">// 递归</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 是文件</span><span class="hljs-keyword">let</span> route = <span class="hljs-built_in">require</span>(newFilePath);<span class="hljs-comment">//注册路由</span>router.<span class="hljs-title function_">use</span>(route.<span class="hljs-title function_">routes</span>());router.<span class="hljs-title function_">use</span>(route.<span class="hljs-title function_">allowedMethods</span>());&#125;&#125;);&#125;;<span class="hljs-title function_">mapRoutes</span>(path.<span class="hljs-title function_">join</span>(__dirname));<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;</code></pre></div><ul><li>  <code>app.js</code></li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./routes/index&quot;</span>);app.<span class="hljs-title function_">use</span>(routes.<span class="hljs-title function_">routes</span>(), routes.<span class="hljs-title function_">allowedMethods</span>());</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2022/02/24/%E6%95%B0%E7%BB%84/"/>
    <url>/2022/02/24/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字面量</span><span class="hljs-keyword">let</span> arr = []<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<span class="hljs-comment">// 构造函数</span><span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>()<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-regexp">/传入数组代表数组长度/</span>)<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-string">&#x27;item1&#x27;</span>,<span class="hljs-string">&#x27;item2&#x27;</span>/传入元素/)<span class="hljs-keyword">let</span> arr = <span class="hljs-title class_">Array</span>(<span class="hljs-number">10</span>)/省略<span class="hljs-keyword">new</span>操作符/<span class="hljs-comment">// Array.of</span><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">7</span>) 创建一个具有单个元素 <span class="hljs-number">7</span> 的数组，而<span class="hljs-title class_">Array</span>(<span class="hljs-number">7</span>) 创建一个长度为<span class="hljs-number">7</span>的空数组<span class="hljs-comment">// Array.from</span><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike[, mapFn[, thisArg]]类数组对象)</code></pre></div><h2 id="变异方法（改变原数组）"><a href="#变异方法（改变原数组）" class="headerlink" title="变异方法（改变原数组）"></a>变异方法（改变原数组）</h2><ul><li>  <code>pop()</code>删除最后一个元素</li><li>  <code>shift()</code>删除第一个元素</li><li>  <code>push()</code>添加元素至末尾</li><li>  <code>unshift()</code>添加元素至首位</li><li>  <code>splice(start,delCount,new1,new2...)</code>往数组索引为 start 位置删除 delCont 个元素，并从该位置加入 new 新元素</li><li>  <code>sort()</code>排序</li><li><code>reverse()</code>倒序,返回新数组<br>  es6</li><li>  <code>copyWithin(target,start,end)</code>拷贝数组中索引从 start 到 end（end）的元素添加至 target</li><li>  <code>fill(value,start,end)</code>将数组中索引 start 到 end（不含）的位置填充为 value 元素</li></ul><h2 id="非变异方法"><a href="#非变异方法" class="headerlink" title="非变异方法"></a>非变异方法</h2><ul><li>  <code>slice(start,end)</code>潜拷贝，返回索引从 start 到 end（不含）的元素组成新数组</li><li>  <code>join()</code>指定分隔符将数字元素连成字符串</li><li>  <code>concat()</code>合并数组</li><li>  <code>indexOf()/lastIndexOf()</code>查找元素索引,可传入起始位置</li><li>  <code>includes()</code>查找是否包含元素返回 Boolean,可传入起始位置</li><li>  <code>...</code>展开运算符</li></ul><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>遍历数组的回调<code>mapFn</code>包含自动传入的参数(currentValue,currentIndex,thisArr)</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// parseInt(string, radix)   解析一个字符串并返回指定基数的十进制整数</span><span class="hljs-comment">// 解释了</span>[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>].<span class="hljs-title function_">map</span>(<span class="hljs-built_in">parseInt</span>)=&gt;  <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-number">0</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-number">2</span>)=&gt;  <span class="hljs-number">1</span>,<span class="hljs-title class_">NaN</span>,<span class="hljs-title class_">NaN</span></code></pre></div><ul><li><p>  <code>map()</code>使用指定函数映射每一个元素后的返回值组成的新数组</p></li><li><p>  <code>flatmap()</code>使用指定函数映射每一个元素后的返回值组成新数组并执行一次扁平化</p></li><li><p>  <code>some()</code>测试是否至少有一个元素可以通过提供的函数,返回布尔值，找到第一个就会停止遍历</p></li><li><p>  <code>every()</code>检测数组所有元素是否都符合判断条件,返回布尔值，遇到false就会停止遍历</p></li><li><p>  <code>forEach()</code>对数组的每个元素执行一次提供的函数,不会改变原数组</p></li><li><p>  <code>filter()</code>返回通过制定函数过滤后「返回true」的数组</p></li><li><p>  <code>find()</code>返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined</p></li><li><p>  <code>findIndex()</code>返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1</p></li><li><p>  <code>reduce()和reduceRight()</code>累加器,累加函数的 return 作为下一次累加的 pre 值，并可指定初始值</p></li><li><p>  <code>flat(depth)</code>按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回（_会移除数组中的空项_）</p></li><li><p>调用遍历器[Symbol.Iterator]</p><ul><li>  <code>of Object.keys()</code></li><li>  <code>of Object.values()</code></li><li>  <code>of Object.entries()</code></li></ul>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].<span class="hljs-title function_">keys</span>()) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].<span class="hljs-title function_">values</span>()) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(elem);&#125;<span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-comment">// &#x27;b&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>].<span class="hljs-title function_">entries</span>()) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, elem);&#125;<span class="hljs-comment">// 0 &quot;a&quot;</span><span class="hljs-comment">// 1 &quot;b&quot;</span></code></pre></div></li></ul><h2 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h2><ol><li><p><code>arr.constructor===Array</code></p></li><li><p><code>arr instanceof Array</code></p></li><li><p><code>Array.prototype.isPrototypeOf(arr)</code></p><blockquote><p>这三种查找原型的方法，如果手动更改对象的原型也可欺骗过检测</p></blockquote></li><li><p><code>Object.prototype.toString.call(arr)===&#39;[object Array]&#39;</code></p></li><li><p><code>Array.isArray()</code></p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> notArr = &#123;<span class="hljs-attr">__proto__</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#125;;notArr.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Array</span>;<span class="hljs-comment">// true</span><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(notArr);<span class="hljs-comment">// true</span>notArr <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>;<span class="hljs-comment">// true</span><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(notArr);<span class="hljs-comment">// &quot;[object Object]&quot;</span><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(notArr);<span class="hljs-comment">// false</span></code></pre></div><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">// 1</span><span class="hljs-keyword">let</span> uni1 = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr));<span class="hljs-comment">// 2</span><span class="hljs-keyword">let</span> uni2 = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr)];<span class="hljs-comment">// 3</span><span class="hljs-keyword">let</span> uni3 = arr.<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (pre.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || pre[pre.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] !== cur) pre.<span class="hljs-title function_">push</span>(cur);<span class="hljs-keyword">return</span> pre;&#125;, []);<span class="hljs-comment">// 4</span><span class="hljs-keyword">let</span> uni4 = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<span class="hljs-keyword">if</span>(!pre.<span class="hljs-title function_">includes</span>(cur))&#123;pre.<span class="hljs-title function_">push</span>(cur)&#125;<span class="hljs-keyword">return</span> pre&#125;,[])<span class="hljs-comment">// 5</span><span class="hljs-keyword">let</span> uni4 = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">indexOf</span>(item) === index;&#125;);</code></pre></div><h2 id="计算数组中元素出现的次数"><a href="#计算数组中元素出现的次数" class="headerlink" title="计算数组中元素出现的次数"></a>计算数组中元素出现的次数</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>];<span class="hljs-comment">//reduce</span><span class="hljs-keyword">let</span> countArr = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">obj, i</span>) =&gt;</span> &#123;<span class="hljs-keyword">if</span> (obj[i]) &#123;obj[i]++;&#125; <span class="hljs-keyword">else</span> &#123;obj[i] = <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> obj;&#125;, &#123;&#125;);<span class="hljs-comment">// &#123; &#x27;1&#x27;: 2, &#x27;2&#x27;: 2, &#x27;3&#x27;: 2, &#x27;4&#x27;: 4 &#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr) &#123;<span class="hljs-keyword">if</span> (i <span class="hljs-keyword">in</span> obj) &#123;obj[i]++;&#125; <span class="hljs-keyword">else</span> &#123;obj[i] = <span class="hljs-number">1</span>;&#125;&#125;</code></pre></div><h2 id="对于-obj-按照属性分类"><a href="#对于-obj-按照属性分类" class="headerlink" title="对于 obj 按照属性分类"></a>对于 obj 按照属性分类</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 面试题教你归类json</span><span class="hljs-comment">// JSON.parse(jsonStr)</span><span class="hljs-keyword">let</span> person = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">21</span> &#125;,&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Hank&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;,&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jery&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span> &#125;,];<span class="hljs-keyword">function</span> <span class="hljs-title function_">groupBy</span>(<span class="hljs-params">objArr, prop</span>) &#123;<span class="hljs-keyword">return</span> objArr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, obj</span>) =&gt;</span> &#123;<span class="hljs-keyword">let</span> key = obj[prop];<span class="hljs-keyword">if</span> (!acc[key]) acc[key] = [];acc[key].<span class="hljs-title function_">push</span>(obj);<span class="hljs-keyword">return</span> acc;&#125;, &#123;&#125;);&#125;<span class="hljs-keyword">let</span> res = <span class="hljs-title function_">groupBy</span>(person, <span class="hljs-string">&quot;age&quot;</span>);</code></pre></div><h2 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 1 reduce</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat1</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">res, item</span>) =&gt;</span>  &#123;    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">concat</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item) ? <span class="hljs-title function_">flat1</span>(item) : item);  &#125;, []);&#125;<span class="hljs-comment">//2 递归</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat2</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">let</span> res = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr) &#123;    res.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item) ? (...<span class="hljs-title function_">flat2</span>(item)) : item)  &#125;  <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 3 展开运算符</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat3</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">while</span> (arr.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span>  <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))) &#123;    arr = [].<span class="hljs-title function_">concat</span>(...arr);  &#125;  <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 4 toString</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat4</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">return</span> arr    .<span class="hljs-title function_">toString</span>()    .<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>)    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span>  <span class="hljs-title class_">Number</span>(item));&#125;<span class="hljs-comment">// 5 join</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat5</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">return</span> arr    .<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;,&quot;</span>)    .<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>)    .<span class="hljs-title function_">map</span>((item) =  <span class="hljs-title class_">Number</span>(item));&#125;<span class="hljs-comment">// 6 flat()</span><span class="hljs-title function_">flat</span>(<span class="hljs-title class_">Infinity</span>);</code></pre></div><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="V8-中的-sort"><a href="#V8-中的-sort" class="headerlink" title="V8 中的 sort()"></a>V8 中的 sort()</h3><ul><li>  7.0 之前 arr.length =10【插入排序】， 10【快速排序】</li><li>  7.0 之后 【timesort】</li></ul><h3 id="常见排序方法"><a href="#常见排序方法" class="headerlink" title="常见排序方法"></a>常见排序方法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote><p>O(n^2) 第一个循环设定冒泡范围，第二个循环冒泡元素</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) || arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-comment">// 外层循环是冒泡范围</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 提前退出flag</span><span class="hljs-comment">// 内层循环是冒泡比较</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; len - i; j++) &#123;<span class="hljs-keyword">if</span> (arr[j - <span class="hljs-number">1</span>] &gt; arr[j]) &#123;[arr[j - <span class="hljs-number">1</span>], arr[j]] = [arr[j], arr[j - <span class="hljs-number">1</span>]];flag = <span class="hljs-literal">true</span>;&#125;&#125;<span class="hljs-keyword">if</span> (flag === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote><p>O(n^2)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertSort</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) || arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">const</span> pivot = arr[i]; <span class="hljs-comment">// 从index开始选出基准值</span><span class="hljs-keyword">let</span> j = i;<span class="hljs-keyword">while</span> (arr[j - <span class="hljs-number">1</span>] &gt; pivot &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 与基准值比较,将基准值插入正确位置</span>arr[j] = arr[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 把比基准大的元素向右边搬移</span>j--;&#125;arr[j] = pivot;&#125;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">// 也可以使用交换,性能低</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertSort2</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j - <span class="hljs-number">1</span>]; j--) &#123;[arr[j], arr[j - <span class="hljs-number">1</span>]] = [arr[j - <span class="hljs-number">1</span>], arr[j]];&#125;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote><p>O(n^2) 不稳定</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectSort</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr) !== <span class="hljs-literal">true</span> || arr.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">let</span> minIndex = i;<span class="hljs-comment">// 假设i为从i到len的最小值</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<span class="hljs-comment">// 从i+1开始寻找最小值</span><span class="hljs-keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;minIndex = j;&#125;&#125;<span class="hljs-comment">// 替换i位置的值得</span>[arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><blockquote><p>对于大量数据,上述三种 O(n^2)的时间复杂度难以接受</p></blockquote><h4 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h4><blockquote><p>O(n log n)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-comment">// once function &#x27;mergeSort&#x27; run ,split arr to two group length equally</span><span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>);<span class="hljs-keyword">const</span> left = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, mid);<span class="hljs-keyword">const</span> right = arr.<span class="hljs-title function_">slice</span>(mid);<span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left), <span class="hljs-title function_">mergeSort</span>(right));&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">l, r</span>) &#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (l.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; r.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//notice: ‘&amp;&amp;’ not ‘||‘</span><span class="hljs-keyword">if</span> (l[<span class="hljs-number">0</span>] &gt; r[<span class="hljs-number">0</span>]) &#123;res.<span class="hljs-title function_">push</span>(r.<span class="hljs-title function_">shift</span>());&#125; <span class="hljs-keyword">else</span> &#123;res.<span class="hljs-title function_">push</span>(l.<span class="hljs-title function_">shift</span>());&#125;&#125;<span class="hljs-comment">// one of l and r is empty,concat it to Array &#x27;res&#x27;</span><span class="hljs-keyword">return</span> res.<span class="hljs-title function_">concat</span>(l).<span class="hljs-title function_">concat</span>(r);&#125;</code></pre></div><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote><p>平均 O(n log n)</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>)&#123;  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr; <span class="hljs-comment">//一直排序到区间内只有一个数</span>  <span class="hljs-keyword">var</span> pivotIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(arr.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>); <span class="hljs-comment">//基准位置（可任意选取）</span>  <span class="hljs-keyword">var</span> pivot = arr.<span class="hljs-title function_">splice</span>(pivotIndex, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]; <span class="hljs-comment">//找出基准数并把它从原数组删除</span>  <span class="hljs-keyword">var</span> left = [];  <span class="hljs-comment">// 空间复杂度O(n)</span>  <span class="hljs-keyword">var</span> right = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-keyword">if</span> (arr[i] &lt; pivot) &#123;<span class="hljs-comment">// 小于在左边大于在右</span>      left.<span class="hljs-title function_">push</span>(arr[i]);    &#125; <span class="hljs-keyword">else</span> &#123;      right.<span class="hljs-title function_">push</span>(arr[i]);    &#125;  &#125;  <span class="hljs-keyword">return</span> [...<span class="hljs-title function_">quickSort</span>(left), pivot, ...<span class="hljs-title function_">quickSort</span>(right)]&#125;<span class="hljs-comment">// 不使用额外空间,在原数组交换元素位置</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>) &#123;  <span class="hljs-keyword">function</span> <span class="hljs-title function_">quick</span>(<span class="hljs-params">arr,l,r</span>)&#123;    <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">partition</span>(arr,l,r)    <span class="hljs-comment">// partition函数取出一个基准索引，并会依据基准分为大于小于基准的两部分</span>    <span class="hljs-keyword">if</span>(l&lt;index)&#123;      <span class="hljs-title function_">quick</span>(arr,l,index-<span class="hljs-number">1</span>)    &#125;    <span class="hljs-keyword">if</span>(r&gt;index)&#123;      <span class="hljs-title function_">quick</span>(arr,index+<span class="hljs-number">1</span>,r)    &#125;  &#125;  <span class="hljs-title function_">quick</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)  <span class="hljs-keyword">return</span> arr&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">arr,l,r</span>)&#123;  <span class="hljs-comment">// 这里直接使用r作为基准，不用随机值</span>  <span class="hljs-comment">// i 是排序后pivot的正确位置，初始设置为最左</span>  <span class="hljs-keyword">let</span> i = l  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = l ; j&lt;r ; j++)&#123;    <span class="hljs-comment">// 判断相对于基准的大小并更新i的位置</span>    <span class="hljs-comment">// i左边是已经比较完的区间,都比arr[r]小</span>    <span class="hljs-keyword">if</span>(arr[j]&lt;arr[r])&#123;      [arr[j],arr[i]] = [arr[i],arr[j]]<span class="hljs-comment">// j向右扫的过程中遇到比基准小的值时,i停留在上一个比基准大的位置,则对他两进行交换</span>      i++    &#125;  &#125;  <span class="hljs-comment">// pivot归位,最后以i位置完成分界</span>  [arr[i],arr[r]] = [arr[r],arr[i]]  <span class="hljs-keyword">return</span> i&#125;</code></pre></div><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote><p>平均 O(n log 2n) 最坏 O(n^2)<br>相当于设置动态间隔的插入排序</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 移动</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">shellSort1</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> arr;<span class="hljs-keyword">let</span> gap = len &gt;&gt; <span class="hljs-number">1</span>;<span class="hljs-comment">// 这里初始设为长度一半</span><span class="hljs-keyword">for</span> (; gap &gt; <span class="hljs-number">0</span>; gap = gap &gt;&gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 不断缩小间隔的长度</span><span class="hljs-comment">// 最终会为1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = gap; i &lt; len; i++) &#123;<span class="hljs-keyword">const</span> pivot = arr[i];<span class="hljs-keyword">let</span> j = i;<span class="hljs-keyword">while</span> (arr[j - gap] &gt; pivot &amp;&amp; j - gap &gt;= <span class="hljs-number">0</span>) &#123;arr[j] = arr[j - gap];j -= gap;&#125;arr[j] = pivot;&#125;&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 建立大顶堆</span><span class="hljs-comment">// 依次将末尾元素与heap[1]交换位置并调整堆，同时缩小堆的大小（排除最后的大数）</span><span class="hljs-comment">// heap[2]和heap[1]交换完成后就是升序排序</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">const</span> heap = [, ...arr];<span class="hljs-keyword">let</span> heapSize = arr.<span class="hljs-property">length</span>;<span class="hljs-title function_">buildHeap</span>(heap, heapSize);<span class="hljs-comment">// 开始交换头尾</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = heapSize; k &gt; <span class="hljs-number">1</span>; k--) &#123;[heap[k], heap[<span class="hljs-number">1</span>]] = [heap[<span class="hljs-number">1</span>], heap[k]];<span class="hljs-title function_">heapify</span>(heap, --heapSize, <span class="hljs-number">1</span>);&#125;heap.<span class="hljs-title function_">shift</span>();<span class="hljs-keyword">function</span> <span class="hljs-title function_">buildHeap</span>(<span class="hljs-params">heap, size</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(size / <span class="hljs-number">2</span>); i &gt;= <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-title function_">heapify</span>(heap, size, i);&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">heap, heapSize, i</span>) &#123;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">let</span> maxIndex = i;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span> * i] &gt; heap[i]) maxIndex = <span class="hljs-number">2</span> * i;<span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span> &lt;= heapSize &amp;&amp; heap[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] &gt; heap[maxIndex]) maxIndex = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (maxIndex === i) <span class="hljs-keyword">break</span>;[heap[maxIndex], heap[i]] = [heap[i], heap[maxIndex]];i = maxIndex;&#125;&#125;&#125;</code></pre></div><h4 id="记数排序🤯"><a href="#记数排序🤯" class="headerlink" title="记数排序🤯"></a>记数排序🤯</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countSort</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">let</span> maxValue = arr[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> arr) &#123;<span class="hljs-keyword">if</span> (n &gt; maxValue) maxValue = n;&#125;<span class="hljs-comment">// 找出数据中的最大值</span><span class="hljs-keyword">const</span> countArr = <span class="hljs-title class_">Array</span>(maxValue + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 建立计数数组，下标为数据值，元素为相同元素个数</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> arr) &#123;countArr[n]++;&#125;<span class="hljs-comment">// 统计数据出现次数加入计数数组</span><span class="hljs-comment">// 对计数数组执行累加操作</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; countArr.<span class="hljs-property">length</span>; i++) &#123;countArr[i] += countArr[i - <span class="hljs-number">1</span>];&#125;<span class="hljs-comment">// countArr中元素即代表arr中元素小于等于该下标的数量</span><span class="hljs-keyword">const</span> temp = <span class="hljs-title class_">Array</span>(arr.<span class="hljs-property">length</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<span class="hljs-keyword">let</span> num = arr[j];<span class="hljs-keyword">let</span> pos = countArr[num] - <span class="hljs-number">1</span>;<span class="hljs-comment">// 得出顺序正确的索引</span>temp[pos] = num;<span class="hljs-comment">// arr指针向左扫，归位元素后将累加计数数组中计数-1</span>countArr[num]--;&#125;<span class="hljs-keyword">return</span> temp; <span class="hljs-comment">// or copy temp to origin arr</span>&#125;</code></pre></div><h4 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h4><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>);<span class="hljs-comment">//由于js中sort方法的特殊性，对于数据量小于10和大于10的排序方法不一样</span><span class="hljs-comment">// Math.random()-0.5不能做到真正意义上的完全随机</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">while</span> (len) &#123;<span class="hljs-keyword">const</span> i = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * len) &gt;&gt; <span class="hljs-number">0</span><span class="hljs-comment">// 随机位置和末尾交换</span>[arr[i], arr[len-<span class="hljs-number">1</span>]] = [arr[len-<span class="hljs-number">1</span>], arr[i]];len -- <span class="hljs-comment">// const i = (Math.random() * len--) &gt;&gt; 0;</span><span class="hljs-comment">// [arr[i], arr[len]] = [arr[len], arr[i]];</span>&#125;<span class="hljs-keyword">return</span> arr;&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器缓存策略</title>
    <link href="/2022/02/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2022/02/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p>浏览器在本地验证资源是否过期，如果没过期直接使用本地缓存，并返回<code>200</code>和显示(<code>from memory cache / from disk cache)</code>(根据内存空闲情况和资源类型，并且memory cache页面关闭后会清理，下次加载是从disk cache)</p><h2 id="强缓存字段"><a href="#强缓存字段" class="headerlink" title="强缓存字段"></a>强缓存字段</h2><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a><code>Expires</code></h3><ul><li> http 1.0</li><li> 时间戳格式<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code></li><li> ⚠️使用本地时间验证，与服务器时间之间的误差或者本地时间的修改都后会造成缓存失效</li></ul><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a><code>Cache-control</code></h3><ul><li> http 1.1</li><li>可选参数：<ul><li><code>public</code>,<code>private</code><ul><li><code>public</code> 表示该资源可以被所有客户端和代理服务器缓存</li><li><code>private</code> 表示该资源仅能客户端缓存[<em>默认值</em>]</li></ul></li><li><code>max-age</code><em>相对资源首次被请求的时间</em><ul><li>单位为毫秒，表示多长时间后过期</li><li>可设置为 <strong>0</strong> 立即请求新资源</li></ul></li><li><code>s-maxage</code> 会在<code>public</code>字段生效时覆盖<code>Expires</code>和<code>max-age</code> </li><li><code>no-cache</code>,<code>no-store</code><ul><li><code>no-cache</code> 会缓存资源，但要协商缓存验证</li><li><code>no-store</code> 不缓存</li></ul></li><li><code>max-age=0 || no-cache</code>会进入协商缓存</li></ul></li></ul><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a><code>Pragma</code></h3><ul><li> 只为了兼容http1.0</li><li> <code>Pragma = no-cache</code>与<code>Cache-Control: no-cache</code>效果一致</li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>Cache-Control -&gt; Expires</code></p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>浏览器携带缓存标识向服务器发起请求，询问服务器缓存有效性，协商缓存生效，返回<code>304</code>和<code>Not Modified</code>，协商缓存失效，返回<code>200</code>和请求结果</p><h2 id="协商缓存字段"><a href="#协商缓存字段" class="headerlink" title="协商缓存字段"></a>协商缓存字段</h2><h3 id="Last-modified-If-Modified-Since"><a href="#Last-modified-If-Modified-Since" class="headerlink" title="Last-modified + If-Modified-Since"></a><code>Last-modified + If-Modified-Since</code></h3><ul><li><p>服务器返回资源的同时在<code>response header</code>中添加 <code>Last-Modified</code>字段，值是该资源在服务器上的最后修改时间<br>  <code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT</code></p></li><li><p> 再次请求该资源时，浏览器检测到资源中存在 <code>Last-Modified</code>字段，则会将这个时间戳作为<code>If-Modified-Since</code>的值加入请求头中发送给服务器</p></li><li><p> 服务器根据自身资源的修改时间和来自请求的时间戳判断资源是否更新，返回相对应的结果</p></li></ul><blockquote><p>缺点</p></blockquote><ul><li>本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改</li><li><code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，则不能体现被修改过</li></ul><h3 id="ETag-If-Not-Match"><a href="#ETag-If-Not-Match" class="headerlink" title="ETag + If-Not-Match"></a><code>ETag + If-Not-Match</code></h3><ul><li><p> 服务器为资源进行hash计算生成唯一的标识符<code>Etag</code>加入返回头，资源的修改会导致标识改变</p></li><li><p> 浏览器请求时将资源自带的标识作为<code>If-None-Match</code>的值加入请求头中发送给服务器</p></li><li><p> 服务器根据同一资源标识是否一致返回相应结果</p></li><li><p><code>ETag:\W 弱验证</code>: 新旧资源不需要逐字节一一对应新旧资源的比较会使用较为宽松的算法</p></li><li><p><code>If-Match条件请求</code>: 在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源匹配该ETag值时才会返回资源。而对于 PUT 或其他非安全方法来说，只有在满足条件的情况下才可以将数据上传。例如:Range请求 or 避免更新丢失（用户上传覆盖其他用户提交的更新）</p><h1 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h1></li></ul><ol><li><p>先判断<code>Cache-Control</code>，在<code>Cache-Control</code>的<code>max-age</code>之内，直接返回<code>200 from cache</code>；</p></li><li><p>没有<code>Cache-Control</code>再判断<code>Expires</code>，在<code>Expires</code>之内，直接返回<code>200 from cache</code></p></li><li><p><code>Cache-Control=no-cache/no-store</code>或者不符合<code>Expires</code>，浏览器向服务器发送请求</p></li><li><p> 服务器判断<code>If-Modified-Since</code>和<code>If-None-Match</code>，两者同时出现时会忽略<code>If-Modified-Since</code>，有效则返回<code>304</code>，失效则返回新资源。</p></li></ol><h2 id="用户行为的影响"><a href="#用户行为的影响" class="headerlink" title="用户行为的影响"></a>用户行为的影响</h2><ol><li><em>地址栏</em>访问，链接跳转是正常用户行为，将会触发浏览器缓存机制；</li><li><em>F5</em>刷新，进行协商缓存判断；</li><li><em>ctrl+F5</em>刷新，指定强缓存和协商缓存都失效。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法题</title>
    <link href="/2022/02/24/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2022/02/24/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="两数之合"><a href="#两数之合" class="headerlink" title="两数之合"></a>两数之合</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">arr, target</span>) &#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<span class="hljs-comment">// 使用数值-&gt;索引建立map</span><span class="hljs-comment">// 每次循环计算得出当前差值</span><span class="hljs-comment">// 在map中查找这个差值既能得出索引</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">let</span> k = target - arr[i];<span class="hljs-keyword">if</span> (map.<span class="hljs-title function_">has</span>(k)) &#123;res.<span class="hljs-title function_">push</span>([map.<span class="hljs-title function_">get</span>(k), i]);&#125;map.<span class="hljs-title function_">set</span>(arr[i], i);&#125;<span class="hljs-keyword">return</span> res.<span class="hljs-property">length</span> === <span class="hljs-number">1</span> ? res[<span class="hljs-number">0</span>] : res;&#125;</code></pre></div></code></pre><h3 id="排序数组的两数之和"><a href="#排序数组的两数之和" class="headerlink" title="排序数组的两数之和"></a>排序数组的两数之和</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twoSum</span>(<span class="hljs-params">nums, target</span>) &#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt; r) &#123;<span class="hljs-keyword">const</span> curSum = nums[l] + nums[r];<span class="hljs-keyword">if</span> (curNum === target) <span class="hljs-keyword">return</span> [nums[l], nums[r]];<span class="hljs-keyword">if</span> (curNum &gt; target) &#123;r--;&#125; <span class="hljs-keyword">else</span> &#123;l++;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></div></code></pre><h3 id="三数之合"><a href="#三数之合" class="headerlink" title="三数之合"></a>三数之合</h3><p>求出数组中三个数之和等于 target 的所有组合</p><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">arr, target</span>) &#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> res;arr = arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);<span class="hljs-comment">// 按大小排序</span><span class="hljs-comment">// 开始循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-keyword">if</span> (arr[i] &gt;= target) <span class="hljs-keyword">break</span>;<span class="hljs-comment">// 第一个值就大于target后面不用想了</span><span class="hljs-keyword">if</span> (arr[i] === arr[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 跳过重复的值</span><span class="hljs-keyword">let</span> first = i,second = i + <span class="hljs-number">1</span>,third = len - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (second &lt; third) &#123;<span class="hljs-keyword">const</span> sum = arr[first] + arr[second] + arr[third];<span class="hljs-keyword">if</span> (sum === target) &#123;res.<span class="hljs-title function_">push</span>([arr[first], arr[second], arr[third]]);second++;third--;<span class="hljs-comment">// 移动一次指针再跳过重复项</span><span class="hljs-keyword">while</span> (arr[second] === arr[second - <span class="hljs-number">1</span>]) &#123;second++;&#125;<span class="hljs-keyword">while</span> (arr[third] === arr[third + <span class="hljs-number">1</span>]) &#123;third--;&#125;&#125;<span class="hljs-comment">//移动指针</span><span class="hljs-keyword">if</span> (sum &gt; target) third--;<span class="hljs-keyword">if</span> (sum &lt; target) second++;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></code></pre><h3 id="最大面积"><a href="#最大面积" class="headerlink" title="最大面积"></a>最大面积</h3><div class="hljs code-wrapper"><pre><code class="hljs">给定数组，按数组 index 为 x 轴坐标,value 为 y 轴坐标在二纬坐标系画线，连接哪两条线时得到最大面积&gt; 面积 = 两直线中较短的高度 \* 两线间距离<pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">height</span>) &#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = height.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (l &lt; r) &#123;res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, (r - l) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(height[l], height[r]));<span class="hljs-keyword">if</span> (height[l] &lt; height[r]) &#123;l++;&#125; <span class="hljs-keyword">else</span> &#123;r--;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></code></pre><h3 id="删除排序数组中的重复项，不能使用额外空间，返回不重复的长度"><a href="#删除排序数组中的重复项，不能使用额外空间，返回不重复的长度" class="headerlink" title="删除排序数组中的重复项，不能使用额外空间，返回不重复的长度"></a>删除排序数组中的重复项，不能使用额外空间，返回不重复的长度</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">removeDuplicates</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<span class="hljs-keyword">if</span> (arr[j] !== arr[j - <span class="hljs-number">1</span>]) &#123;arr[++i] = arr[j];&#125;&#125;<span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;&#125;</code></pre></div></code></pre><h3 id="设计一个支持在平均时间复杂度-O-1-下，执行以下操作的数据结构。"><a href="#设计一个支持在平均时间复杂度-O-1-下，执行以下操作的数据结构。" class="headerlink" title="设计一个支持在平均时间复杂度 O(1) 下，执行以下操作的数据结构。"></a>设计一个支持在平均时间复杂度 O(1) 下，执行以下操作的数据结构。</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-title function_">insert</span>(val) ：当元素 val 不存在时，向集合中插入该项。<span class="hljs-title function_">remove</span>(val) ：元素 val 存在时，从集合中移除该项。getRandom ：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。示例 :<span class="hljs-comment">// 初始化一个空的集合。</span><span class="hljs-title class_">RandomizedSet</span> randomSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomizedSet</span>();<span class="hljs-comment">// 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span>randomSet.<span class="hljs-title function_">insert</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// 返回 false ，表示集合中不存在 2 。</span>randomSet.<span class="hljs-title function_">remove</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span>randomSet.<span class="hljs-title function_">insert</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// getRandom 应随机返回 1 或 2 。</span>randomSet.<span class="hljs-title function_">getRandom</span>();<span class="hljs-comment">// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span>randomSet.<span class="hljs-title function_">remove</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">// 2 已在集合中，所以返回 false 。</span>randomSet.<span class="hljs-title function_">insert</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span>randomSet.<span class="hljs-title function_">getRandom</span>();<span class="hljs-comment">// map方法</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">RandomSet</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()  <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span> = []&#125;<span class="hljs-title class_">RandomSet</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">insert</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">has</span>(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">set</span>(val,values.<span class="hljs-property">length</span>)  <span class="hljs-comment">// 插入后的索引（插入前的数组长度）</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-title function_">push</span>(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-title class_">RandomSet</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">remove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">has</span>(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">get</span>(val)  <span class="hljs-comment">// 判断在尾部</span>  <span class="hljs-comment">// 似乎也可以用头部</span>  <span class="hljs-keyword">if</span>(index === <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">delete</span>(value)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-title function_">pop</span>()  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">// 不在尾部</span>    <span class="hljs-comment">// values用尾部元素填充该位置</span>    <span class="hljs-comment">// map中修改索引</span>    <span class="hljs-keyword">let</span> last = <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-title function_">pop</span>()    <span class="hljs-comment">// 赋值</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>[index] = last    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">set</span>(last,index)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">delete</span>(val)  &#125;  <span class="hljs-keyword">return</span> val&#125;<span class="hljs-title class_">RandomSet</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getRandom</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-property">length</span>  <span class="hljs-keyword">let</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*len)  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>[index]&#125;<span class="hljs-comment">// set方法</span><span class="hljs-comment">// set是不重复的值的集合</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">RandomSet</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()&#125;<span class="hljs-title class_">RandomizedSet</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">insert</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">has</span>(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">set</span>.<span class="hljs-title function_">add</span>(val)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-title class_">RandomizedSet</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">remove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">has</span>(val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">set</span>.<span class="hljs-title function_">delete</span>(val)  <span class="hljs-keyword">return</span> val&#125;<span class="hljs-title class_">RandomizedSet</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getRandom</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">let</span> len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">values</span>.<span class="hljs-property">length</span>  <span class="hljs-keyword">let</span> index = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*len)  <span class="hljs-keyword">return</span> [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>][index]&#125;</code></pre></div></code></pre><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// arr1 = [1,2,5]  m=3</span><span class="hljs-comment">// arr2 = [2,3,4]  n=3</span><span class="hljs-comment">// 假设arr1能装下arr2</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeArr</span>(<span class="hljs-params">arr1, m, arr2, n</span>) &#123;<span class="hljs-keyword">let</span> index1 = m - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> index2 = n - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> index = m + n - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">if</span> (index2 &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// arr2耗尽</span><span class="hljs-comment">// 剩下保持arr1的值</span>arr1[index--] = arr2[index2--];<span class="hljs-keyword">continue</span>;&#125;arr1[index--] = arr1[index1] &gt;= arr2[index2] ? arr1[index1--] : arr2[index2--];&#125;&#125;</code></pre></div></code></pre><h3 id="计算两个数组的交集"><a href="#计算两个数组的交集" class="headerlink" title="计算两个数组的交集"></a>计算两个数组的交集</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">arr1, arr2</span>) &#123;<span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr1.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> arr2.<span class="hljs-title function_">includes</span>(item)))];&#125;</code></pre></div></code></pre><h3 id="计算多个数组的交集"><a href="#计算多个数组的交集" class="headerlink" title="计算多个数组的交集"></a>计算多个数组的交集</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">intersection</span>(<span class="hljs-params">...arrs</span>) &#123;<span class="hljs-keyword">if</span> (arrs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];<span class="hljs-keyword">if</span> (arrs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arrs[<span class="hljs-number">0</span>];<span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arrs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">pre, next</span>) =&gt;</span> &#123;<span class="hljs-comment">// reduce累加器，每一次的return作为下一次累加的pre，你咋这也能忘</span><span class="hljs-comment">// 后还能添加参数手动制定第一次累加的pre值</span><span class="hljs-keyword">return</span> pre.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> next.<span class="hljs-title function_">includes</span>(item));&#125;)),];&#125;</code></pre></div></code></pre><h3 id="大数相乘-可以输出字符串"><a href="#大数相乘-可以输出字符串" class="headerlink" title="大数相乘(可以输出字符串)"></a>大数相乘(可以输出字符串)</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bigMulti</span>(<span class="hljs-params">x, y</span>) &#123;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;0&quot;</span> || y === <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">if</span> (x === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> y;<span class="hljs-keyword">if</span> (y === <span class="hljs-string">&quot;1&quot;</span>) <span class="hljs-keyword">return</span> x;<span class="hljs-keyword">const</span> len1 = x.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> len2 = y.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len1 + len2).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> num1, num2, mulit, cur;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len1 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;num1 = x[i];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;num2 = y[j];mulit = num1 * num2;cur = mulit + pos[i + j + <span class="hljs-number">1</span>];pos[i + j + <span class="hljs-number">1</span>] = cur % <span class="hljs-number">10</span>;pos[i + j] += (cur / <span class="hljs-number">10</span>) | <span class="hljs-number">0</span>; <span class="hljs-comment">// 取10位以上部分</span>&#125;&#125;<span class="hljs-keyword">let</span> res = pos.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-keyword">while</span> (res[<span class="hljs-number">0</span>] === <span class="hljs-string">&quot;0&quot;</span>) &#123;res = res.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></code></pre><h3 id="保留精度加法"><a href="#保留精度加法" class="headerlink" title="保留精度加法"></a>保留精度加法</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fixAdd</span> = (<span class="hljs-params">x, y</span>) =&gt; &#123;<span class="hljs-keyword">const</span> len1 = x.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> len2 = y.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> maxLen = len1 &gt;= len2 ? len1 : len2;<span class="hljs-keyword">const</span> times = maxLen * <span class="hljs-number">10</span>;<span class="hljs-keyword">return</span> (x * times + y * times) / times;&#125;;</code></pre></div></code></pre><h3 id="满-9-加-1"><a href="#满-9-加-1" class="headerlink" title="满 9 加 1"></a>满 9 加 1</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add1</span>(<span class="hljs-params">num</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dig = num.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; dig &gt;= <span class="hljs-number">0</span>; dig--) &#123;<span class="hljs-keyword">if</span> (num[dig] === <span class="hljs-number">9</span>) &#123;num[dig] = <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;num[dig]++;<span class="hljs-keyword">return</span> num;&#125;&#125;num.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> num;&#125;</code></pre></div></code></pre><h3 id="将数组中的-0-全部移动到最后且非-0-部分保持原顺序"><a href="#将数组中的-0-全部移动到最后且非-0-部分保持原顺序" class="headerlink" title="将数组中的 0 全部移动到最后且非 0 部分保持原顺序"></a>将数组中的 0 全部移动到最后且非 0 部分保持原顺序</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">move0</span>(<span class="hljs-params">num</span>) &#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (i &lt; num.<span class="hljs-property">length</span>) &#123;<span class="hljs-keyword">if</span> (num[i] !== <span class="hljs-number">0</span>) &#123;[mim[i], num[j]] = [num[j], num[i]];i++;j++;&#125; <span class="hljs-keyword">else</span> &#123;i++;&#125;&#125;&#125;</code></pre></div></code></pre><h3 id="数的次方（不使用内置库-pow"><a href="#数的次方（不使用内置库-pow" class="headerlink" title="数的次方（不使用内置库 pow"></a>数的次方（不使用内置库 pow</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果指数n是偶数，x^n = x^(n/2) * x^(n/2)</span><span class="hljs-comment">// 如果指数n是奇数，x^n = x * x^(n/2) * x^(n/2)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">myPow</span>(<span class="hljs-params">x, n</span>) &#123;<span class="hljs-keyword">function</span> <span class="hljs-title function_">_pow</span>(<span class="hljs-params">base, ex</span>) &#123;<span class="hljs-keyword">if</span> (ex === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (ex === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> base;<span class="hljs-keyword">const</span> splitPow = <span class="hljs-title function_">_pow</span>(base, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(ex / <span class="hljs-number">2</span>));<span class="hljs-keyword">return</span> ex % <span class="hljs-number">2</span> ? base * splitPow * splitPow : splitPow * splitPow;&#125;<span class="hljs-keyword">const</span> res = <span class="hljs-title function_">_pow</span>(x, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(n));<span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> / res : res;&#125;</code></pre></div><h3 id="数字的开方-（不使用内置库-pow-和-X-X"><a href="#数字的开方-（不使用内置库-pow-和-X-X" class="headerlink" title="数字的开方 （不使用内置库 pow 和 X ** X"></a>数字的开方 （不使用内置库 pow 和 X ** X</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//  返回值只保留整数部分 ，8 =&gt; 2</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySqrt</span>(<span class="hljs-params">num</span>) &#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = num;<span class="hljs-comment">// 左右指针重合后跳出</span><span class="hljs-keyword">while</span> (l &lt;= r) &#123;<span class="hljs-comment">// 计算一次当前的中间值</span><span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((r - l) / <span class="hljs-number">2</span>) + l;<span class="hljs-comment">// const mid = (r-l) &gt;&gt; 1 + l</span><span class="hljs-keyword">const</span> curPow = mid * mid;<span class="hljs-keyword">if</span> (mid &lt;= num) &#123;l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;r = mid - <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-keyword">return</span> r;&#125;</code></pre></div><h3 id="输出-1-到最大的-n-位数"><a href="#输出-1-到最大的-n-位数" class="headerlink" title="输出 1 到最大的 n 位数"></a>输出 1 到最大的 n 位数</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment">  / <span class="hljs-doctag">@params</span> n=1 一位数，最大9，输出123456789</span><span class="hljs-comment">  / <span class="hljs-doctag">@params</span> n=2 两位数呀 最大99</span><span class="hljs-comment">  */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">printNumbers1</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-comment">//组合字符串</span><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;str += <span class="hljs-string">&quot;9&quot;</span>;n--;&#125;str = <span class="hljs-title class_">Number</span>(str);<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= str; i++) &#123;res.<span class="hljs-title function_">push</span>(i);&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">printNumbers1</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-comment">//最大值就是 10^n-1......</span><span class="hljs-keyword">const</span> max = <span class="hljs-number">10</span> ** n - <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(max).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> res.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> v + i);&#125;</code></pre></div><h3 id="和为-s-的所有正数序列"><a href="#和为-s-的所有正数序列" class="headerlink" title="和为 s 的所有正数序列"></a>和为 s 的所有正数序列</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  15</span><span class="hljs-comment"> * [1,2,3,4,5] [4,5,6] [7,8]</span><span class="hljs-comment"> */</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">findContinuousSequence</span>(<span class="hljs-params">target</span>) &#123;<span class="hljs-comment">// 直接用滑动窗口套</span><span class="hljs-keyword">let</span> l = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> r = <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> sum = <span class="hljs-number">3</span>;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (l &lt; r) &#123;<span class="hljs-keyword">if</span> (sum === target) &#123;<span class="hljs-keyword">const</span> ret = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = j; i &lt;= r; i++) &#123;ret.<span class="hljs-title function_">push</span>(i);&#125;sum -= l;l++;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) &#123;sum -= l;l++;&#125; <span class="hljs-keyword">else</span> &#123;r++;sum += r;&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// 滑动窗口的另外一种实现</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">findContinuousSequence</span>(<span class="hljs-params">target</span>) &#123;<span class="hljs-keyword">const</span> max = target % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? target / <span class="hljs-number">2</span> : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(target / <span class="hljs-number">2</span>);<span class="hljs-comment">// max右边都不可能满足</span><span class="hljs-comment">// t = 9</span><span class="hljs-comment">// max = 1，2，3，4，5，6[x]，7[x]，8[x]</span><span class="hljs-keyword">const</span> <span class="hljs-variable language_">window</span> = [];<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= max; i++) &#123;<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">push</span>(i);sum += i;<span class="hljs-keyword">while</span> (sum &gt; target) &#123;sum -= <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">shift</span>();&#125;<span class="hljs-keyword">if</span> (sum === target) &#123;<span class="hljs-variable language_">window</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span> &amp;&amp; res.<span class="hljs-title function_">push</span>([...<span class="hljs-variable language_">window</span>]);<span class="hljs-comment">//<span class="hljs-doctag">FIXME:</span></span><span class="hljs-comment">// 注意！！</span><span class="hljs-comment">// push window的浅拷贝</span>&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="数组中出现次数超过数组长度一半的元素"><a href="#数组中出现次数超过数组长度一半的元素" class="headerlink" title="数组中出现次数超过数组长度一半的元素"></a>数组中出现次数超过数组长度一半的元素</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 一定会是排序后的数组中点</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">nums</span>) &#123;nums = nums.<span class="hljs-title function_">sort</span>();<span class="hljs-keyword">return</span> nums[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];&#125;<span class="hljs-comment">// 投票记数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">majorityElement</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-keyword">let</span> vote = <span class="hljs-number">1</span>;<span class="hljs-comment">// 前后元素相同投票加1，不同减1，票数抵消则计算后面的元素</span><span class="hljs-keyword">let</span> mid = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> nums) &#123;<span class="hljs-keyword">if</span> (vote === <span class="hljs-number">1</span>) &#123;mid = num;&#125;vote += num === mid ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">return</span> mid;&#125;</code></pre></div><h3 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a>圆圈中最后剩下的数字</h3><p>0,1,···,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p><p>例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 朴朴素素超时方法</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">lastRemaining</span>(<span class="hljs-params">n, m</span>) &#123;<span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> (v += i));<span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (arr &gt; <span class="hljs-number">1</span>) &#123;pos = (pos + m - <span class="hljs-number">1</span>) % arr.<span class="hljs-property">length</span>;arr.<span class="hljs-title function_">splice</span>(pos, <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">// 找规律</span><span class="hljs-comment">// 约瑟夫环</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">lastRemaining</span>(<span class="hljs-params">n, m</span>) &#123;<span class="hljs-comment">// 0，1，2，3，4，5...n-1,n</span><span class="hljs-comment">// n = 1 时输出 0</span><span class="hljs-comment">// 反推得到公式</span><span class="hljs-comment">// n个数字,由于从0开始排列，则索引===数值</span><span class="hljs-comment">// 当前状态用f(n,m)表示，则上一轮为f(n-1,m)</span><span class="hljs-comment">// f(n,m) = (f(n-1,m)+m)%n</span><span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> (<span class="hljs-title function_">lastRemaining</span>(n - <span class="hljs-number">1</span>, m) + m) % n;&#125;<span class="hljs-comment">// 也可以使用迭代实现</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">lastRemaining</span>(<span class="hljs-params">n, m</span>) &#123;<span class="hljs-keyword">let</span> pos = <span class="hljs-number">0</span>; <span class="hljs-comment">// n为1时的 剩下0</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<span class="hljs-comment">// 每一轮都根据规律修改</span>pos = (pos + m) % i;&#125;<span class="hljs-keyword">return</span> pos;&#125;</code></pre></div><h3 id="将数组中的奇数移动到前，偶数移动到后"><a href="#将数组中的奇数移动到前，偶数移动到后" class="headerlink" title="将数组中的奇数移动到前，偶数移动到后"></a>将数组中的奇数移动到前，偶数移动到后</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">exchange</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-comment">// 对撞指针</span><span class="hljs-comment">// 分别寻找符合条件的数</span><span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>,r = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &lt; r) &#123;<span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) l++;<span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) r--;[nums[l], nums[r]] = [nums[r], nums[l]];&#125;<span class="hljs-keyword">return</span> nums;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">exchange</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-comment">// 快慢指针</span><span class="hljs-keyword">let</span> slow = <span class="hljs-number">0</span>,fast = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (fast &lt; nums.<span class="hljs-property">length</span>) &#123;<span class="hljs-keyword">if</span> (nums[fast] % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>) &#123;[nums[slow], nums[fast]] = [num[fast], nums[slow]];slow++;&#125;fast++;&#125;<span class="hljs-keyword">return</span> nums;&#125;</code></pre></div><h3 id="青蛙跳台阶-斐波那契数列"><a href="#青蛙跳台阶-斐波那契数列" class="headerlink" title="青蛙跳台阶/斐波那契数列"></a>青蛙跳台阶/斐波那契数列</h3><div class="hljs code-wrapper"><pre><code class="hljs">&gt; 注意别搞混了，fibonacci 数列排列是固定的&gt; fib 数列 [0,1,1,2,3]&gt; 青蛙跳法 [1,1,2,3,5]</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numWays</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> cur = <span class="hljs-number">2</span>;<span class="hljs-keyword">let</span> pre = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (i++ &lt; n) &#123;<span class="hljs-comment">// 从n=3时迭代推导</span>res = cur + pre;pre = cur;cur = res;&#125;<span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">numWays</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-comment">// 斐波那契数列</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;arr[i] = arr[i - <span class="hljs-number">1</span>] + arr[i - <span class="hljs-number">2</span>];&#125;<span class="hljs-keyword">return</span> arr[i];&#125;<span class="hljs-comment">// 长度为n的斐波那契数组生成器</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacciArray</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, cur, i</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> acc.<span class="hljs-title function_">concat</span>(i &gt; <span class="hljs-number">1</span> ? acc[i - <span class="hljs-number">1</span>] + acc[i - <span class="hljs-number">2</span>] : o);&#125;, []);&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">Fibonacci</span>(<span class="hljs-params">n</span>) &#123;<span class="hljs-keyword">if</span> (n === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title class_">Fibonacci</span>(n - <span class="hljs-number">2</span>);&#125;<span class="hljs-comment">// 尾递归版本</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fibonacci</span>(<span class="hljs-params">n, b1 = <span class="hljs-number">1</span>, b2 = <span class="hljs-number">1</span>, c = <span class="hljs-number">3</span></span>) &#123;<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (n === <span class="hljs-number">3</span>) &#123;<span class="hljs-keyword">return</span> c;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-title class_">Fibonacci</span>(n, b2, b1 + b2, c + <span class="hljs-number">1</span>);&#125;&#125;&#125;</code></pre></div><h3 id="连续子数组的和的最大值"><a href="#连续子数组的和的最大值" class="headerlink" title="连续子数组的和的最大值"></a>连续子数组的和的最大值</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-comment">// 用dp记录该位置作为子数组末尾的累加值</span><span class="hljs-comment">// [nums[0],nums[1]],dp[1] = num[0] + num[1]</span><span class="hljs-comment">// dp[2] = dp[1] + nums[2]</span><span class="hljs-comment">// 同时判断前一dp的值正负</span><span class="hljs-comment">// 前一个dp为正则 当前dp = 前dp + 当前nums</span><span class="hljs-comment">// 如果为负直接丢弃</span><span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> dpi = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;dpi = dpi &gt; <span class="hljs-number">0</span> ? dpi + nums[i] : nums[i];max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(max, dpi);&#125;<span class="hljs-keyword">return</span> max;&#125;</code></pre></div><h3 id="反转嵌套数组"><a href="#反转嵌套数组" class="headerlink" title="反转嵌套数组"></a>反转嵌套数组</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 已知数组 a=[1,[2,[3,[4,null]]]], 实现数组 b=[4,[3,[2,[1,null]]]] ，考虑n级嵌套的情况</span><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-literal">null</span>]]]];<span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseArray</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">arr, temp</span>) &#123;<span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]]</span><span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1] = [2,[3,[4,null]]]</span><span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1][1] = [3,[4,null]]</span><span class="hljs-comment">// arr = [1,[2,[3,[4,null]]]][1][1][1] = [4,null]</span><span class="hljs-keyword">if</span> (arr[<span class="hljs-number">1</span>] === <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> [arr[<span class="hljs-number">0</span>], temp];<span class="hljs-comment">// return</span>&#125;temp = temp ? [arr[<span class="hljs-number">0</span>], temp] : [arr[<span class="hljs-number">0</span>], <span class="hljs-literal">null</span>];<span class="hljs-comment">// temp = [1,null]</span><span class="hljs-comment">// temp = [2,[1,null]]</span><span class="hljs-comment">// temp = [3,[2,[1,null]]]</span><span class="hljs-keyword">return</span> <span class="hljs-title function_">reverse</span>(arr[<span class="hljs-number">1</span>], temp); <span class="hljs-comment">// 递归进嵌套</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-title function_">reverse</span>(arr, <span class="hljs-literal">null</span>);&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reverseArray</span>(a));</code></pre></div><h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><div class="hljs code-wrapper"><pre><code class="hljs">0,1,···,n-1 这 n 个数字排成一个圆圈，从数字 0 开始，每次从这个圆圈里删除第 m 个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。例如，0、1、2、3、4 这 5 个数字组成一个圆圈，从数字 0 开始每次删除第 3 个数字，则删除的前 4 个数字依次是 2、0、4、1，因此最后剩下的数字是 3。</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 递归公式</span><span class="hljs-comment">// f(n,m) = (f(n-1,m)+m)%n 本轮索引=上轮索引+m%n</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">lastRemaining</span>(<span class="hljs-params">n, m</span>) &#123;<span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">return</span> (<span class="hljs-title function_">lastRemaining</span>(n - <span class="hljs-number">1</span>, m) + m) % n;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">lastRemaining</span>(<span class="hljs-params">n, m</span>) &#123;<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">2</span>; j &lt;= m; j++) &#123;i = (i + m) % j;&#125;<span class="hljs-keyword">return</span> i;&#125;</code></pre></div><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><div class="hljs code-wrapper"><pre><code class="hljs">输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。    示例1:    输入: nums = [-2,1,-3,4,-1,2,1,-5,4]    输出: 6    解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 状态转移</span><span class="hljs-comment">// 由连续元素来求和</span><span class="hljs-comment">// dp[i] 位置的累加值由dp[i-1]决定，dp[i-1]不为负则加上dp[i-1]</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">const</span> dp = [nums[<span class="hljs-number">0</span>]];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;dp[i] = dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? nums[i] + dp[i - <span class="hljs-number">1</span>] : nums[i];<span class="hljs-keyword">if</span> (dp[i] &gt; max) max = dp[i];&#125;<span class="hljs-keyword">return</span> max;&#125;<span class="hljs-comment">// 使用变量记忆dp[i-1]的值</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxSubArray</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-keyword">if</span> (nums.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<span class="hljs-keyword">let</span> max = nums[<span class="hljs-number">0</span>];<span class="hljs-keyword">let</span> preDp = <span class="hljs-number">0</span>; <span class="hljs-comment">// init 0</span><span class="hljs-keyword">let</span> curDp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> nums) &#123;curDp = n;curDp += preDp &gt; <span class="hljs-number">0</span> ? preDp : <span class="hljs-number">0</span>;<span class="hljs-keyword">if</span> (curDp &gt; max) max = curDp;preDp = curDp;&#125;<span class="hljs-keyword">return</span> max;&#125;</code></pre></div><h3 id="0-n-1-中缺省的值"><a href="#0-n-1-中缺省的值" class="headerlink" title="[0 ~ n-1]中缺省的值"></a>[0 ~ n-1]中缺省的值</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 正确的数组应该value===index</span><span class="hljs-comment">// [0,1,3] =&gt; 2</span><span class="hljs-comment">// [1,2] =&gt; 0</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">missingNumber</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++) &#123;<span class="hljs-keyword">if</span> (i !== nums[i]) <span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">missingNumber</span>(<span class="hljs-params">nums</span>) &#123;<span class="hljs-keyword">let</span> l = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> r = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span> (l &gt;= r) &#123;<span class="hljs-keyword">let</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((r - l) / <span class="hljs-number">2</span>) + l;<span class="hljs-keyword">if</span> (mid === nums[mid]) &#123;<span class="hljs-comment">// 中间位置数值正确，说明缺省数值在右边</span>l = mid + <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 中间数值已经不正确，说明缺省数值在左边</span>r = mid - <span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-comment">// 跳出while后r在l的左边</span><span class="hljs-keyword">return</span> l;&#125;</code></pre></div><h3 id="输入一个矩形，顺时针打印矩形其中元素"><a href="#输入一个矩形，顺时针打印矩形其中元素" class="headerlink" title="输入一个矩形，顺时针打印矩形其中元素"></a>输入一个矩形，顺时针打印矩形其中元素</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> matrix = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],];<span class="hljs-keyword">function</span> <span class="hljs-title function_">spiralOrder</span>(<span class="hljs-params">matrix</span>) &#123;<span class="hljs-keyword">const</span> rowLen = matrix.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> columnLen = matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> bottom = rowLen - <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> right = columnLen - <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a = left; a &lt;= right; a++) &#123;res.<span class="hljs-title function_">push</span>(matrix[top][a]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b = top + <span class="hljs-number">1</span>; b &lt;= bottom; b++) &#123;res.<span class="hljs-title function_">push</span>(matrix[b][right]);&#125;<span class="hljs-keyword">if</span> (top &gt;= bottom || left &gt;= right) <span class="hljs-keyword">break</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> c = right - <span class="hljs-number">1</span>; c &gt;= left; c--) &#123;res.<span class="hljs-title function_">push</span>(matrix[bottom][c]);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> d = bottom; d &gt;= top; d--) &#123;res.<span class="hljs-title function_">push</span>(matrix[left][d]);&#125;left++;right--;top++;bottom--;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="电商-SKU-全排列-笛卡尔积"><a href="#电商-SKU-全排列-笛卡尔积" class="headerlink" title="电商 SKU 全排列/笛卡尔积"></a>电商 SKU 全排列/笛卡尔积</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> attrs = &#123;<span class="hljs-attr">names</span>: [<span class="hljs-string">&quot;iPhone X&quot;</span>, <span class="hljs-string">&quot;iPhone XS&quot;</span>, <span class="hljs-string">&quot;iPhone 11&quot;</span>],<span class="hljs-attr">colors</span>: [<span class="hljs-string">&quot;黑色&quot;</span>, <span class="hljs-string">&quot;白色&quot;</span>, <span class="hljs-string">&quot;红色&quot;</span>],<span class="hljs-attr">storage</span>: [<span class="hljs-string">&quot;64g&quot;</span>, <span class="hljs-string">&quot;128G&quot;</span>, <span class="hljs-string">&quot;256g&quot;</span>],&#125;;<span class="hljs-keyword">const</span> descartes = <span class="hljs-keyword">function</span> (<span class="hljs-params">chunks</span>) &#123;<span class="hljs-keyword">let</span> res = [];<span class="hljs-keyword">const</span> keysName = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(chunks);<span class="hljs-comment">// 由于是操作对象,多增加一个keys数组</span><span class="hljs-keyword">const</span> helper = <span class="hljs-keyword">function</span> (<span class="hljs-params">chunkIndex, prev</span>) &#123;<span class="hljs-keyword">let</span> curKey = keysName[chunkIndex];<span class="hljs-keyword">let</span> curChunk = chunks[curKey];<span class="hljs-keyword">let</span> isLast = chunkIndex === keysName.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> curChunk) &#123;<span class="hljs-keyword">const</span> cur = prev.<span class="hljs-title function_">concat</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;curKey&#125;</span>:<span class="hljs-subst">$&#123;val&#125;</span>`</span>);<span class="hljs-keyword">if</span> (isLast) &#123;<span class="hljs-comment">// 如果已经处理到数组的最后一项了 则把拼接的结果放入返回值中</span>res.<span class="hljs-title function_">push</span>(cur);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-title function_">helper</span>(chunkIndex + <span class="hljs-number">1</span>, cur);&#125;&#125;&#125;;<span class="hljs-comment">// 从属性数组下标为 0 开始处理</span><span class="hljs-comment">// 并且此时的 prev 是个空数组</span><span class="hljs-title function_">helper</span>(<span class="hljs-number">0</span>, []);<span class="hljs-keyword">return</span> res;&#125;;</code></pre></div></code></pre><h3 id="1-到-n-的数字组成-k-长度的数组的所有组合"><a href="#1-到-n-的数字组成-k-长度的数组的所有组合" class="headerlink" title="1 到 n 的数字组成 k 长度的数组的所有组合"></a>1 到 n 的数字组成 k 长度的数组的所有组合</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入: n = 4, k = 2;</span><span class="hljs-comment">// 输出: [[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">n, k</span>) &#123;<span class="hljs-keyword">const</span> res = [];<span class="hljs-keyword">function</span> <span class="hljs-title function_">helper</span>(<span class="hljs-params">start, prev</span>) &#123;<span class="hljs-keyword">const</span> len = prev.<span class="hljs-property">length</span>;<span class="hljs-keyword">if</span> (len === k) &#123;res.<span class="hljs-title function_">push</span>(prev);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// 剪枝,还能剩下几个空位</span><span class="hljs-keyword">const</span> rest = k - len;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i &lt;= n; i++) &#123;<span class="hljs-keyword">if</span> (n - i + <span class="hljs-number">1</span> &lt; rest) &#123;<span class="hljs-comment">// 递增关系+1</span><span class="hljs-comment">// n是最大数字,减去当前数字+1</span><span class="hljs-keyword">return</span>; <span class="hljs-comment">// 往后的i都不会符合,直接return</span>&#125;<span class="hljs-title function_">helper</span>(i + <span class="hljs-number">1</span>, prev.<span class="hljs-title function_">concat</span>(i));&#125;&#125;<span class="hljs-title function_">helper</span>(<span class="hljs-number">1</span>, []);<span class="hljs-keyword">return</span> res;&#125;</code></pre></div></code></pre><h3 id="请你判断一个-9-x-9-的数独是否有效。根据以下规则-，验证已经填入的数字是否有效"><a href="#请你判断一个-9-x-9-的数独是否有效。根据以下规则-，验证已经填入的数字是否有效" class="headerlink" title="请你判断一个  9 x 9 的数独是否有效。根据以下规则 ，验证已经填入的数字是否有效"></a>请你判断一个  9 x 9 的数独是否有效。根据以下规则 ，验证已经填入的数字是否有效</h3><div class="hljs code-wrapper"><pre><code class="hljs">1. 数字  1-9  在每一行只能出现一次。1. 数字  1-9  在每一列只能出现一次。1. 数字  1-9  在每一个以粗实线分隔的  3x3  宫内只能出现一次。（请参考示例图）1. 空白为&#39;.&#39;<pre><code class="hljs javascript">board = [[<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>],[<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>],[<span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>],[<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>],];<span class="hljs-comment">//输出：true</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidSudoku</span>(<span class="hljs-params">arr</span>) &#123;<span class="hljs-comment">// 用最直白的哈希表，由于要处理顺序递增数组，可以默认全部是0</span><span class="hljs-comment">// 记录index+1位置的数有没有出现过</span><span class="hljs-keyword">const</span> rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<span class="hljs-keyword">const</span> columns = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<span class="hljs-comment">// 9*9的小方块</span><span class="hljs-keyword">const</span> blocks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">9</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>)));<span class="hljs-comment">// 开始循环</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<span class="hljs-keyword">const</span> cur = board[i][j];<span class="hljs-keyword">if</span> (cur === <span class="hljs-string">&quot;.&quot;</span>) countine; <span class="hljs-comment">//跳过</span><span class="hljs-keyword">const</span> index = +cur - <span class="hljs-number">1</span>;rows[i][index]++;columns[j][index]++;blocks[~~(i / <span class="hljs-number">3</span>)][~~[j / <span class="hljs-number">3</span>]][index]++;<span class="hljs-keyword">if</span> (rows[i][index] &gt; <span class="hljs-number">1</span> || columns[j][index] &gt; <span class="hljs-number">1</span> || blocks[~~(i / <span class="hljs-number">3</span>)][~~[j / <span class="hljs-number">3</span>]][index] &gt; <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div></code></pre><h3 id="实现-LRU-缓存结构-（最近最少访问"><a href="#实现-LRU-缓存结构-（最近最少访问" class="headerlink" title="实现 LRU 缓存结构 （最近最少访问"></a>实现 LRU 缓存结构 （最近最少访问</h3><div class="hljs code-wrapper"><pre><code class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">LRUCache</span>(<span class="hljs-params">capacity</span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span> = capacity<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()&#125;<span class="hljs-title class_">LRUCache</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key))&#123;<span class="hljs-keyword">const</span> val = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">get</span>(key)<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key)<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key,val)<span class="hljs-keyword">return</span> val&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>&#125;&#125;<span class="hljs-title class_">LRUCache</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">put</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">key,value</span>)&#123;<span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">has</span>(key))&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(key)&#125;<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">set</span>(key,value)<span class="hljs-comment">// 如果容量超标</span><span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">capacity</span>)&#123;<span class="hljs-comment">// 删除map中的第一个</span><span class="hljs-keyword">const</span> latestKey = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>.<span class="hljs-title function_">delete</span>(latestKey)&#125;&#125;</code></pre></div></code></pre><h3 id="判断一个数是否是质数-素数"><a href="#判断一个数是否是质数-素数" class="headerlink" title="判断一个数是否是质数/素数"></a>判断一个数是否是质数/素数</h3><blockquote><p>质数：大于 1 的自然数只能被 1 和自身整除的数</p></blockquote><blockquote><p>sqrt 平方根</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">num</span>) &#123;<span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; num - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-keyword">if</span> (num % i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// 一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPrime</span>(<span class="hljs-params">num</span>) &#123;<span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-keyword">const</span> sqrt = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(num);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; sqrt; i++) &#123;<span class="hljs-keyword">if</span> (num % i === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="计算-n-以内的质数数量"><a href="#计算-n-以内的质数数量" class="headerlink" title="计算 n 以内的质数数量"></a>计算 n 以内的质数数量</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> countPrimes = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<span class="hljs-comment">// n之前的数组，先全部默认是质数</span><span class="hljs-comment">// primeArray[i] = true</span><span class="hljs-keyword">const</span> primeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-literal">true</span>);<span class="hljs-keyword">let</span> primeCount = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<span class="hljs-comment">// 从2开始,由于2是质数,开始推导2派生出去的质数</span><span class="hljs-comment">// 即2的n次+2后都不会是质数了</span><span class="hljs-keyword">if</span> (primeArray[i]) &#123;primeCount++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i * i; j &lt; n; j += i) &#123;primeArray[j] = <span class="hljs-literal">false</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> primeCount;&#125;;</code></pre></div><h3 id="求出两个数组最长的公共子数组长度"><a href="#求出两个数组最长的公共子数组长度" class="headerlink" title="求出两个数组最长的公共子数组长度"></a>求出两个数组最长的公共子数组长度</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><span class="hljs-comment">// 输出：3</span><span class="hljs-comment">// 解释：长度最长的公共子数组是 [3,2,1]</span><span class="hljs-comment">// 动态规划</span><span class="hljs-comment">// 分别用i，j代表在两个数组中的索引</span><span class="hljs-comment">// 当arr1[i] === arr[j]时</span><span class="hljs-comment">// 该位置的公共长度 dp[i][j] = dp[i-1][j-1] + 1</span><span class="hljs-comment">// 建立二维数组dp</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">commonLongest</span>(<span class="hljs-params">A, B</span>) &#123;<span class="hljs-keyword">const</span> m = A.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> n = B.<span class="hljs-property">length</span>;<span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">// 考虑0的情况，并且dp[x][0]或者dp[0][x]都为0</span><span class="hljs-keyword">const</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<span class="hljs-comment">// 从长度为0开始，则有一位重合 + 1</span><span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">1</span>] === B[j - <span class="hljs-number">1</span>]) &#123;dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;&#125;res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, dp[i][j]);&#125;&#125;<span class="hljs-keyword">return</span> res;&#125;</code></pre></div><h3 id="计算岛屿的周长"><a href="#计算岛屿的周长" class="headerlink" title="计算岛屿的周长"></a>计算岛屿的周长</h3><p>二维数组，1 为陆地，0 为海水，铺成矩阵，陆地与陆地不会对角接壤（不会出现陆地环绕的海水），求出接壤陆地组成的岛屿的周长（一块陆地四条边）</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPerimeter</span>(<span class="hljs-params">grid</span>) &#123;<span class="hljs-keyword">if</span> (!grid || !grid.<span class="hljs-property">length</span> || !grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> row = grid.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> col = grid.<span class="hljs-property">length</span>;<span class="hljs-comment">// 查找第一块陆地</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-title function_">dfs</span>(i, j);&#125;&#125;&#125;<span class="hljs-comment">// 从这个方块的四个方向开始搜索</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>) &#123;<span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= row || y &gt;= col) &#123;<span class="hljs-comment">// 衍生的方块越过了边界，留下一条边</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (grid[x][y] === <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 方块掉进了海里，留下一条边</span><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-keyword">if</span> (grid[x][y] === -<span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 之前访问过</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 标记为访问过</span>grid[x][y] = -<span class="hljs-number">1</span>;<span class="hljs-comment">// 向四周延伸</span><span class="hljs-keyword">return</span> <span class="hljs-title function_">dfs</span>(x + <span class="hljs-number">1</span>, y) + <span class="hljs-title function_">dfs</span>(x - <span class="hljs-number">1</span>, f) + <span class="hljs-title function_">dfs</span>(x, y + <span class="hljs-number">1</span>) + <span class="hljs-title function_">dfs</span>(x, y - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 找规律 n个陆地，m条边是共享的，则周长 = n*4 - m*2</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getPerimeter</span>(<span class="hljs-params">grid</span>) &#123;<span class="hljs-keyword">if</span> (!grid || !grid.<span class="hljs-property">length</span> || !grid[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-keyword">const</span> row = grid.<span class="hljs-property">length</span>;<span class="hljs-keyword">const</span> col = grid.<span class="hljs-property">length</span>;<span class="hljs-keyword">let</span> land = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> shareBorder = <span class="hljs-number">0</span>;<span class="hljs-comment">// 查找第一块陆地</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<span class="hljs-keyword">if</span> (grid[i][j] === <span class="hljs-number">1</span>) &#123;land++;<span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; row &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] === <span class="hljs-number">1</span>) &#123;shareBorder++;&#125;<span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; col &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] === <span class="hljs-number">1</span>) &#123;shareBorder++;&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> land * <span class="hljs-number">4</span> - shareBorder * <span class="hljs-number">2</span>;&#125;</code></pre></div><h3 id="最大公约数（GCD）"><a href="#最大公约数（GCD）" class="headerlink" title="最大公约数（GCD）"></a>最大公约数（GCD）</h3><p>使用递归。基本情况是当 y 等于 0 时。在这种情况下，返回 x。否则，返回 y 的 GCD 和 x / y 的其余部分。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">gcd</span> = (<span class="hljs-params">x, y</span>) =&gt; (!y ? x : <span class="hljs-title function_">gcd</span>(y, x % y));<span class="hljs-comment">// gcd (8, 36) -&gt; 4</span></code></pre></div><h3 id="bifurcate"><a href="#bifurcate" class="headerlink" title="bifurcate"></a>bifurcate</h3><p>按照布尔值对数组中元素分类</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">bifurcate</span> = (<span class="hljs-params">arr, filter</span>) =&gt; arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, val, i</span>) =&gt;</span> (acc[filter[i] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>].<span class="hljs-title function_">push</span>(val), acc), [[], []]);<span class="hljs-title function_">bifurcate</span>([<span class="hljs-string">&quot;beep&quot;</span>, <span class="hljs-string">&quot;boop&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>], [<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>]);<span class="hljs-comment">// [ [&#x27;beep&#x27;, &#x27;boop&#x27;, &#x27;bar&#x27;], [&#x27;foo&#x27;] ]</span></code></pre></div><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/">合并区间</a></h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p> </p><p>示例 1：</p><p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> merge = <span class="hljs-keyword">function</span>(<span class="hljs-params">intervals</span>) &#123;    <span class="hljs-keyword">if</span>(!intervals || !intervals.<span class="hljs-property">length</span> || intervals.<span class="hljs-property">length</span>&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> intervals    intervals.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a[<span class="hljs-number">0</span>]-b[<span class="hljs-number">0</span>])    <span class="hljs-keyword">const</span> res = []    <span class="hljs-keyword">const</span> len = intervals.<span class="hljs-property">length</span>    <span class="hljs-keyword">let</span> pre = intervals[<span class="hljs-number">0</span>]    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span> ; i &lt; len ; i++)&#123;        <span class="hljs-keyword">const</span> cur = intervals[i]        <span class="hljs-comment">// 如果有重合</span>        <span class="hljs-keyword">if</span>(pre[<span class="hljs-number">1</span>]&gt;=cur[<span class="hljs-number">0</span>])&#123;            <span class="hljs-comment">//更新当前处理区间的判断结束位置</span>            pre[<span class="hljs-number">1</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(pre[<span class="hljs-number">1</span>],cur[<span class="hljs-number">1</span>])        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">// 不存在重合了，进入下一个区间</span>            res.<span class="hljs-title function_">push</span>(pre)            pre = cur        &#125;    &#125;    res.<span class="hljs-title function_">push</span>(pre)    <span class="hljs-keyword">return</span> res&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络分层模型</title>
    <link href="/2022/02/24/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/02/24/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI-参考模型"><a href="#OSI-参考模型" class="headerlink" title="OSI 参考模型"></a>OSI 参考模型</h1><p><code>OSI参考模型（OSI/RM）</code>的全称是开放系统互连参考模型<code>（Open System Interconnection Reference Model，OSI/RM）</code>，它是由国际标准化组织（International Standard Organization，ISO）提出的一个网络系统互连模型。</p><ul><li><p>在这个 OSI 七层模型中，每一层都为其上一层提供服务和访问接口</p></li><li><p>不同主机之间的相同层称为<strong>对等层</strong></p></li><li></li><li><p>对等层之间互相通信需要遵守一定的规则，如通信的内容、通信的方式，我们将其称为<strong>协议</strong>（Protocol）。</p></li><li><p>我们将某个主机上运行的某种协议的集合称为<strong>协议栈</strong>。主机正是利用这个协议栈来接收和发送数据的。</p></li><li><p>OSI 参考模型通过将协议栈划分为不同的层次，可以简化问题的分析、处理过程以及网络系统设计的复杂性。</p></li></ul><h2 id="OSI-参考模型中各层的作用"><a href="#OSI-参考模型中各层的作用" class="headerlink" title="OSI 参考模型中各层的作用"></a>OSI 参考模型中各层的作用</h2><h3 id="物理层Physical-Layer"><a href="#物理层Physical-Layer" class="headerlink" title="物理层Physical Layer"></a>物理层<code>Physical Layer</code></h3><ul><li>利用传输介质为数据链路层提供物理信道，传输二进制数据</li><li>数据的单位称为比特<code>bit</code></li></ul><h3 id="数据链路层Data-Link-Layer"><a href="#数据链路层Data-Link-Layer" class="headerlink" title="数据链路层Data Link Layer"></a>数据链路层<code>Data Link Layer</code></h3><blockquote><p>相邻节点</p></blockquote><ul><li>物理地址寻址、数据的成帧、流量控制、检错重发等。控制帧在物理信道的传输</li><li>数据的单位称为帧<code>frame</code></li><li>协议<ul><li><code>ARP</code>（Address Resolution Protocol，地址解析协议）IP地址映射到MAC地址</li><li><code>RARP</code>（Reverse Address Resolution Protocol，逆地址解析协议）</li></ul></li></ul><h3 id="网络层Network-Layer"><a href="#网络层Network-Layer" class="headerlink" title="网络层Network Layer"></a>网络层<code>Network Layer</code></h3><blockquote><p>不相邻节点</p></blockquote><ul><li>将传输层数据封装成包，并根据IP地址选择路由路径并在网络中传输</li><li>数据的单位称为包<code>packet</code></li><li>协议<ul><li><code>IP</code> 协议（Internet Protocol，网际协议）<ol><li><code>IP协议</code>是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则</li><li><code>IP协议</code>屏蔽了下层各种物理子网的差异，向上层提供给统一格式的<code>IP数据报</code></li><li><code>IP数据报</code>传送使用<code>非连接式</code>的传送方式。非连接式的传送方式是指IP传送时，源设备与目的设备双方不必事先连接，即可将IP数据报送达。即源设备完全不用理会目的设备，而只是单纯地将IP数据报逐一送出。至于目的设备是否收到每个信息包、是否收到正确的信息包等，则由上层的协议(例如<code>TCP</code>)来负责检查</li></ol></li><li><code>ICMP</code> 协议（Internet Control Message Protocol，网际控制报文协议）</li><li><code>IGMP</code> 协议（Internet Group Management Protocol，网际组管理协议）</li></ul></li></ul><h3 id="传输层Transport-Layer"><a href="#传输层Transport-Layer" class="headerlink" title="传输层Transport Layer"></a>传输层<code>Transport Layer</code></h3><ul><li><p>提供端对端的接口，向两个主机中进程之间的通信提供服务，根据协议可向会话层交付可靠的网络连接，同时对于高层屏蔽了低层的技术细节</p></li><li><p>数据的单位称为数据段<code>Segment</code>或报文</p></li><li><p>协议</p><ul><li><p><code>TCP</code>（Transmission Control Protocol）传输控制协议</p><ol><li>面向连接（握手繁琐）</li><li>可靠交付，保证数据的完整和顺序无差错</li><li>单播点对点</li><li>头部较大——20字节</li><li>队头阻塞</li></ol></li><li><p><code>UDP</code>（User Datagram Protocol）用户数据协议</p><ol><li>面向报文（无需握手，对应用层交下来的报文，添加首部后直接乡下交付为IP层）</li><li>不可靠交付，数据发送不受丢包和网络波动影响</li><li>单播和广播，</li><li>头部较小——8字节</li><li>直播，在线会议，语音，即时通信</li><li>没有拥塞机制</li></ol></li></ul></li></ul><h3 id="会话层Session-Layer"><a href="#会话层Session-Layer" class="headerlink" title="会话层Session Layer"></a>会话层<code>Session Layer</code></h3><ul><li>管理表示层之间的连接（会话）</li><li>组织和协调两个会话进程之间的通信,并对数据交换进行管理</li></ul><h3 id="表示层Presentation-Layer"><a href="#表示层Presentation-Layer" class="headerlink" title="表示层Presentation Layer"></a>表示层<code>Presentation Layer</code></h3><ul><li>处理数据编码、数据格式转换和加密解密</li></ul><h3 id="应用层Application-Layer"><a href="#应用层Application-Layer" class="headerlink" title="应用层Application Layer"></a>应用层<code>Application Layer</code></h3><ul><li>应用程序访问网络服务的接口</li><li>协议<ul><li><code>HTTP</code>（Hyper Text Transfer Protocol，超文本传输协议）</li><li><code>FTP</code>（File Transfer Protocol，文件传输协议）</li><li>邮件相关的<code>POP3</code>（Post Office Protocol - V3）和<code>SMTP</code>（Simple Mail Transfer Protocol，简单邮件传输协议）</li></ul></li></ul><hr><h1 id="TCP-IP-分层模型"><a href="#TCP-IP-分层模型" class="headerlink" title="TCP/IP 分层模型"></a>TCP/IP 分层模型</h1><ul><li>TCP/IP 分层模型（TCP/IP Layering Model）被称作因特网分层模型(Internet Layering Model)、因特网参考模型(Internet Reference Model)</li></ul><h2 id="TCP-IP-中各层的作用"><a href="#TCP-IP-中各层的作用" class="headerlink" title="TCP/IP 中各层的作用"></a>TCP/IP 中各层的作用</h2><h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><blockquote><p>对应着 OSI/RM 的数据链路层+物理层</p></blockquote><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><blockquote><p>对应OSI/RM 的表示层+会话层+应用层</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟列表的简单实现</title>
    <link href="/2022/02/24/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/24/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/8uttkBw-dwYXsybKePQ3nA">https://mp.weixin.qq.com/s/8uttkBw-dwYXsybKePQ3nA</a></p><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>虚拟列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-tag">html</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-tag">body</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-id">#app</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.visible-area</span>&#123;</span><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><span class="language-css">      &#125;</span><span class="language-css">      <span class="hljs-selector-class">.infinite-list-container</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">overflow</span>: auto;</span><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><span class="language-css">        -webkit-<span class="hljs-attribute">overflow</span>-scrolling: touch;</span><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;</span><span class="language-css">      &#125;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.infinite-list-phantom</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">z-index</span>: -<span class="hljs-number">1</span>;</span><span class="language-css">      &#125;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.infinite-list</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><span class="language-css">      &#125;</span><span class="language-css"></span><span class="language-css">      <span class="hljs-selector-class">.infinite-list-item</span> &#123;</span><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;</span><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#555</span>;</span><span class="language-css">        <span class="hljs-comment">/* box-sizing: border-box; */</span></span><span class="language-css">        <span class="hljs-attribute">border</span>:<span class="hljs-number">6px</span> solid gray;</span><span class="language-css">        <span class="hljs-comment">/* height:200px; */</span></span><span class="language-css">      &#125;</span><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;visible-area&quot;</span>&gt;</span>        我是可视区域              <span class="hljs-tag">&lt;<span class="hljs-name">virtual-list</span> <span class="hljs-attr">:list-data</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">:estimated-item-size</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">:buffer-scale</span>=<span class="hljs-string">&quot;5&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">virtual-list</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">virtual-list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/Faker/3.1.0/faker.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js&quot;</span>;</span><span class="language-javascript">      <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;virtual-list&quot;</span>, &#123;</span><span class="language-javascript">        <span class="hljs-attr">template</span>: <span class="hljs-string">`</span></span><span class="hljs-string"><span class="language-javascript">        &lt;div ref=&quot;list&quot; :style=&quot;&#123;height&#125;&quot; class=&quot;infinite-list-container&quot; @scroll=&quot;scrollEvent($event)&quot;&gt;</span></span><span class="hljs-string"><span class="language-javascript">          &lt;div ref=&quot;phantom&quot; class=&quot;infinite-list-phantom&quot;&gt;&lt;/div&gt;</span></span><span class="hljs-string"><span class="language-javascript">          &lt;div ref=&quot;content&quot; class=&quot;infinite-list&quot;&gt;</span></span><span class="hljs-string"><span class="language-javascript">            &lt;div class=&quot;infinite-list-item&quot; ref=&quot;items&quot; :id=&quot;item.id&quot; :key=&quot;item.id&quot; v-for=&quot;item in visibleData&quot;&gt;</span></span><span class="hljs-string"><span class="language-javascript">              &lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;&#123;&#123;item.id&#125;&#125;&lt;/span&gt;&#123;&#123;item.value&#125;&#125;&lt;/p&gt;</span></span><span class="hljs-string"><span class="language-javascript">            &lt;/div&gt;</span></span><span class="hljs-string"><span class="language-javascript">          &lt;/div&gt;</span></span><span class="hljs-string"><span class="language-javascript">        &lt;/div&gt;</span></span><span class="hljs-string"><span class="language-javascript">        `</span>,</span><span class="language-javascript">        <span class="hljs-attr">props</span>: &#123;</span><span class="language-javascript">          <span class="hljs-comment">//列表数据</span></span><span class="language-javascript">          <span class="hljs-attr">listData</span>: &#123;</span><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Array</span>,</span><span class="language-javascript">            <span class="hljs-attr">default</span>: <span class="hljs-function">() =&gt;</span> [],</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">//预估高度</span></span><span class="language-javascript">          <span class="hljs-attr">estimatedItemSize</span>: &#123;</span><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span><span class="language-javascript">            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">//缓冲区比例</span></span><span class="language-javascript">          <span class="hljs-attr">bufferScale</span>: &#123;</span><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,</span><span class="language-javascript">            <span class="hljs-attr">default</span>: <span class="hljs-number">1</span>,</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">//容器高度 100px or 50vh</span></span><span class="language-javascript">          <span class="hljs-attr">height</span>: &#123;</span><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,</span><span class="language-javascript">            <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;100%&quot;</span>,</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">computed</span>: &#123;</span><span class="language-javascript">          <span class="hljs-comment">// 可视区域内能显示几条数据</span></span><span class="language-javascript">          <span class="hljs-title function_">visibleCount</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">screenHeight</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">estimatedItemSize</span>);</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">// 可视区域上方数据条数</span></span><span class="language-javascript">          <span class="hljs-comment">// Math.min取缓冲区值</span></span><span class="language-javascript">          <span class="hljs-title function_">aboveCount</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">bufferScale</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>);</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">// 可视区域下方数据条数</span></span><span class="language-javascript">          <span class="hljs-title function_">belowCount</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(</span><span class="language-javascript">              <span class="hljs-variable language_">this</span>.<span class="hljs-property">listData</span>.<span class="hljs-property">length</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span>,</span><span class="language-javascript">              <span class="hljs-variable language_">this</span>.<span class="hljs-property">bufferScale</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span></span><span class="language-javascript">            );</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-title function_">visibleData</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">// 需要渲染的数据 = 显示的数据加上上下缓冲区</span></span><span class="language-javascript">            <span class="hljs-keyword">let</span> start = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">aboveCount</span>;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> end = <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">belowCount</span>;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">listData</span>.<span class="hljs-title function_">slice</span>(start, end);</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initPositions</span>();</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">screenHeight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">clientHeight</span>;</span><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-number">0</span>;</span><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">items</span> || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>) &#123;</span><span class="language-javascript">              <span class="hljs-keyword">return</span>;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">            <span class="hljs-comment">//获取真实元素大小，修改对应的尺寸缓存</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateItemsSize</span>();</span><span class="language-javascript">            <span class="hljs-comment">//更新列表总高度</span></span><span class="language-javascript">            <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">bottom</span>;</span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">phantom</span>.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = height + <span class="hljs-string">&quot;px&quot;</span>;</span><span class="language-javascript">            <span class="hljs-comment">//更新真实偏移量</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setStartOffset</span>();</span><span class="language-javascript">          &#125;);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">return</span> &#123;</span><span class="language-javascript">            <span class="hljs-comment">//可视区域高度</span></span><span class="language-javascript">            <span class="hljs-attr">screenHeight</span>: <span class="hljs-number">0</span>,</span><span class="language-javascript">            <span class="hljs-comment">//起始索引</span></span><span class="language-javascript">            <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>,</span><span class="language-javascript">            <span class="hljs-comment">//结束索引</span></span><span class="language-javascript">            <span class="hljs-attr">end</span>: <span class="hljs-number">0</span>,</span><span class="language-javascript">          &#125;;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">          <span class="hljs-title function_">initPositions</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">listData</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d, index</span>) =&gt;</span> (&#123;</span><span class="language-javascript">              index,</span><span class="language-javascript">              <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">estimatedItemSize</span>,</span><span class="language-javascript">              <span class="hljs-attr">top</span>: index * <span class="hljs-variable language_">this</span>.<span class="hljs-property">estimatedItemSize</span>,</span><span class="language-javascript">              <span class="hljs-attr">bottom</span>: (index + <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">estimatedItemSize</span>,</span><span class="language-javascript">            &#125;));</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">//获取列表起始索引</span></span><span class="language-javascript">          <span class="hljs-title function_">getStartIndex</span>(<span class="hljs-params">scrollTop = <span class="hljs-number">0</span></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">//二分法查找</span></span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">binarySearch</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>, scrollTop);</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-title function_">binarySearch</span>(<span class="hljs-params">list, value</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> end = list.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> tempIndex = <span class="hljs-literal">null</span>;</span><span class="language-javascript"></span><span class="language-javascript">            <span class="hljs-keyword">while</span> (start &lt;= end) &#123;</span><span class="language-javascript">              <span class="hljs-keyword">let</span> midIndex = <span class="hljs-built_in">parseInt</span>((start + end) / <span class="hljs-number">2</span>);</span><span class="language-javascript">              <span class="hljs-keyword">let</span> midValue = list[midIndex].<span class="hljs-property">bottom</span>;</span><span class="language-javascript">              <span class="hljs-keyword">if</span> (midValue === value) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">return</span> midIndex + <span class="hljs-number">1</span>;</span><span class="language-javascript">              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &lt; value) &#123;</span><span class="language-javascript">                start = midIndex + <span class="hljs-number">1</span>;</span><span class="language-javascript">              &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midValue &gt; value) &#123;</span><span class="language-javascript">                <span class="hljs-keyword">if</span> (tempIndex === <span class="hljs-literal">null</span> || tempIndex &gt; midIndex) &#123;</span><span class="language-javascript">                  tempIndex = midIndex;</span><span class="language-javascript">                &#125;</span><span class="language-javascript">                end = end - <span class="hljs-number">1</span>;</span><span class="language-javascript">              &#125;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> tempIndex;</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">//更新列表项的当前尺寸</span></span><span class="language-javascript">          <span class="hljs-title function_">updateItemsSize</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> nodes = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">items</span>;</span><span class="language-javascript">            nodes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">node</span>) =&gt;</span> &#123;</span><span class="language-javascript">              <span class="hljs-keyword">let</span> rect = node.<span class="hljs-title function_">getBoundingClientRect</span>();</span><span class="language-javascript">              <span class="hljs-keyword">let</span> height = rect.<span class="hljs-property">height</span>;</span><span class="language-javascript">              <span class="hljs-keyword">let</span> index = +node.<span class="hljs-property">id</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);</span><span class="language-javascript">              <span class="hljs-keyword">let</span> oldHeight = <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[index].<span class="hljs-property">height</span>;</span><span class="language-javascript">              <span class="hljs-keyword">let</span> dValue = oldHeight - height;</span><span class="language-javascript">              <span class="hljs-comment">//存在差值</span></span><span class="language-javascript">              <span class="hljs-keyword">if</span> (dValue) &#123;</span><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[index].<span class="hljs-property">bottom</span> =</span><span class="language-javascript">                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[index].<span class="hljs-property">bottom</span> - dValue;</span><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[index].<span class="hljs-property">height</span> = height;</span><span class="language-javascript">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = index + <span class="hljs-number">1</span>; k &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>.<span class="hljs-property">length</span>; k++) &#123;</span><span class="language-javascript">                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[k].<span class="hljs-property">top</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[k - <span class="hljs-number">1</span>].<span class="hljs-property">bottom</span>;</span><span class="language-javascript">                  <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[k].<span class="hljs-property">bottom</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[k].<span class="hljs-property">bottom</span> - dValue;</span><span class="language-javascript">                &#125;</span><span class="language-javascript">              &#125;</span><span class="language-javascript">            &#125;);</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">//计算偏移量并translate</span></span><span class="language-javascript">          <span class="hljs-title function_">setStartOffset</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">let</span> startOffset;</span><span class="language-javascript">            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> &gt;= <span class="hljs-number">1</span>) &#123;</span><span class="language-javascript">              <span class="hljs-keyword">let</span> size =</span><span class="language-javascript">                <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span>].<span class="hljs-property">top</span> -</span><span class="language-javascript">                (<span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">aboveCount</span>]</span><span class="language-javascript">                  ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">aboveCount</span>].<span class="hljs-property">top</span></span><span class="language-javascript">                  : <span class="hljs-number">0</span>);</span><span class="language-javascript">              startOffset = <span class="hljs-variable language_">this</span>.<span class="hljs-property">positions</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> - <span class="hljs-number">1</span>].<span class="hljs-property">bottom</span> - size;</span><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="language-javascript">              startOffset = <span class="hljs-number">0</span>;</span><span class="language-javascript">            &#125;</span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">content</span>.<span class="hljs-property">style</span>.<span class="hljs-property">transform</span> = <span class="hljs-string">`translate3d(0,<span class="hljs-subst">$&#123;startOffset&#125;</span>px,0)`</span>;</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          <span class="hljs-comment">//滚动事件</span></span><span class="language-javascript">          <span class="hljs-title function_">scrollEvent</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">            <span class="hljs-comment">//当前滚动位置</span></span><span class="language-javascript">            <span class="hljs-keyword">let</span> scrollTop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">list</span>.<span class="hljs-property">scrollTop</span>;</span><span class="language-javascript">            <span class="hljs-comment">// let startBottom = this.positions[this.start - ]</span></span><span class="language-javascript">            <span class="hljs-comment">//此时的开始索引</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getStartIndex</span>(scrollTop);</span><span class="language-javascript">            <span class="hljs-comment">//此时的结束索引</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleCount</span>;</span><span class="language-javascript">            <span class="hljs-comment">//此时的偏移量</span></span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setStartOffset</span>();</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">      &#125;);</span><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">        <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">          <span class="hljs-attr">dataLength</span>: <span class="hljs-number">100000</span>,</span><span class="language-javascript">          <span class="hljs-attr">list</span>: [],</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">        <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; id &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataLength</span>; ++id) &#123;</span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(&#123;</span><span class="language-javascript">              id,</span><span class="language-javascript">              <span class="hljs-attr">value</span>: faker.<span class="hljs-property">lorem</span>.<span class="hljs-title function_">sentences</span>(),</span><span class="language-javascript">            &#125;);</span><span class="language-javascript">          &#125;</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">      &#125;);</span><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/02/24/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/02/24/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>数组需要申请连续的内存空间，链表可以使用“零散的”内存空间</li><li>插入/删除时间复杂度<code>O(1)</code></li><li>随机访问时间复杂度<code>O(n)</code></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul><li>零散的内存块称为<code>结点</code></li><li>记录下一个结点地址的指针叫做<code>后继指针next</code></li><li><code>headNode</code></li><li><code>tailNode.next = null</code></li></ul><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><ul><li>单链表</li><li>循环链表</li></ul><p>  <code>tailNode.next = headNode</code></p><p>  适合处理环状结构的数据</p><ul><li><p>双向链表</p><p>结点拥有两个指针<br><code>curNode.prev</code><br><code>curNode.next</code></p><p><code>O(1)</code>时间复杂度即可访问前序结点</p></li><li><p>双向循环链表</p><p><code>headNode.prev = tailNode</code><br><code>tailNode.next = headNode</code></p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单向链表</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = element;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">linkedList</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;  &#125;  <span class="hljs-comment">// 追加</span>  <span class="hljs-title function_">append</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = n;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">next</span>) &#123;        cur = cur.<span class="hljs-property">next</span>;      &#125;      cur.<span class="hljs-property">next</span> = n;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>++;    &#125;  &#125;  <span class="hljs-comment">// 查找</span>  <span class="hljs-title function_">search</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">element</span> === element) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      &#125;      cur = cur.<span class="hljs-property">next</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 插入</span>  <span class="hljs-comment">// position之前插入新node</span>  <span class="hljs-title function_">insert</span>(<span class="hljs-params">position, element</span>) &#123;    <span class="hljs-keyword">if</span> (position &gt;= <span class="hljs-number">0</span> &amp;&amp; position &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>) &#123;      <span class="hljs-keyword">let</span> n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;        n.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = n;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>,pre        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (index &lt; position) &#123;          pre = cur;          cur = cur.<span class="hljs-property">next</span>;          index++;        &#125;        pre.<span class="hljs-property">next</span> = n;        n.<span class="hljs-property">next</span> = cur;      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>++;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;  &#125;  <span class="hljs-comment">// 删除</span>  <span class="hljs-title function_">remove</span>(<span class="hljs-params">element</span>) &#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>,      pre = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">while</span> (cur) &#123;      <span class="hljs-keyword">if</span> (cur.<span class="hljs-property">element</span> === element) &#123;        cur = cur.<span class="hljs-property">next</span>;        pre.<span class="hljs-property">next</span> = cur;        <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> --       &#125;      pre = cur      cur = cur.<span class="hljs-property">next</span>;    &#125;  &#125;&#125;<span class="hljs-comment">// 双向链表</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">DubLinkedList</span>(<span class="hljs-params">params</span>) &#123;  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Node</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span> = element;  &#125;;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">append</span> = <span class="hljs-function">(<span class="hljs-params">element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element);    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>;    <span class="hljs-keyword">if</span> (!cur) &#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">while</span> (cur.<span class="hljs-property">next</span>) &#123;        cur = cur.<span class="hljs-property">next</span>;      &#125;      cur.<span class="hljs-property">next</span> = newNode      newNode.<span class="hljs-property">prev</span> = cur      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>++;  &#125;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">insert</span> = <span class="hljs-function">(<span class="hljs-params">position,element</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position &lt;=<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>)&#123;      <span class="hljs-keyword">let</span> newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(element)      <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>,pre      <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">//头</span>        <span class="hljs-keyword">if</span>(!cur)&#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode;        &#125;<span class="hljs-keyword">else</span>&#123;          newNode.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>          cur.<span class="hljs-property">prev</span> = newNode          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = newNode        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>)&#123;        <span class="hljs-comment">//尾巴</span>        cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>        cur.<span class="hljs-property">prev</span> = newNode        newNode.<span class="hljs-property">next</span> = cur        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = newNode      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.<span class="hljs-property">next</span>          index++        &#125;        cur.<span class="hljs-property">prev</span> = newNode        pre.<span class="hljs-property">next</span> = newNode        newNode.<span class="hljs-property">next</span> = cur        newNode.<span class="hljs-property">prev</span> = pre      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;  &#125;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">remove</span> = <span class="hljs-function"><span class="hljs-params">position</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span>(position&gt;=<span class="hljs-number">0</span> &amp;&amp; position&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;      <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>,pre,index = <span class="hljs-number">0</span>      <span class="hljs-keyword">if</span>(position===<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>)&#123;          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>        &#125;<span class="hljs-keyword">else</span>&#123;          cur = cur.<span class="hljs-property">next</span>          cur.<span class="hljs-property">prev</span> = <span class="hljs-literal">null</span>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = cur        &#125;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position===<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)&#123;        cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>        pre = cur.<span class="hljs-property">prev</span>        pre.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = pre      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">while</span>(index&lt;position)&#123;          pre = cur          cur = cur.<span class="hljs-property">next</span>          index ++        &#125;        cur = cur.<span class="hljs-property">next</span>        pre.<span class="hljs-property">next</span> = cur        cur.<span class="hljs-property">prev</span> = pre      &#125;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> --      <span class="hljs-keyword">return</span> cur.<span class="hljs-property">element</span>    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    &#125;  &#125;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">search</span> = <span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span>&#123;    <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>    <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">element</span> === element)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>      &#125;      cur = cur.<span class="hljs-property">next</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  &#125;&#125;</code></pre></div><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="注意边界情况"><a href="#注意边界情况" class="headerlink" title="注意边界情况"></a>注意边界情况</h3><ul><li>链表为空</li><li>链表只有一个结点</li><li>链表只有两个结点</li><li>处理头部结点和尾部结点</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>单链表反转<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ListNode</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseLinkedList</span>(<span class="hljs-params">head</span>)&#123;  <span class="hljs-comment">// 长度为1</span>  <span class="hljs-keyword">if</span>(!head.<span class="hljs-property">next</span>) <span class="hljs-keyword">return</span> head  <span class="hljs-comment">// 链表反过来，则head的值为null</span>  <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-comment">// 链表正向走完后.next = null</span>  <span class="hljs-keyword">while</span>(cur)&#123;    <span class="hljs-keyword">const</span> _next = cur.<span class="hljs-property">next</span>    cur.<span class="hljs-property">next</span> = pre    pre = cur    cur = _next  &#125;  <span class="hljs-keyword">return</span> pre&#125;<span class="hljs-comment">// es6</span><span class="hljs-keyword">let</span> [pre,cur] = [<span class="hljs-literal">null</span>,head]<span class="hljs-keyword">while</span>(cur)&#123;  [cur.<span class="hljs-property">next</span>,pre,cur] = [pre,cur,cur.<span class="hljs-property">next</span>]&#125;<span class="hljs-keyword">return</span> pre</code></pre></div></li><li>检测链表是否循环<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//</span><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>() <span class="hljs-comment">//不能序列化循环链表</span><span class="hljs-comment">//标记</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isLoop</span>(<span class="hljs-params">head</span>)&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> cur = head  <span class="hljs-keyword">while</span>(cur)&#123;    <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">flag</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    cur.<span class="hljs-property">flag</span> = <span class="hljs-literal">true</span>    cur = cur.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// 快慢指针</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isLoop2</span>(<span class="hljs-params">head</span>)&#123;  <span class="hljs-keyword">if</span>(!head || !head.<span class="hljs-property">next</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-keyword">let</span> fast = head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>  <span class="hljs-keyword">let</span> slow = head.<span class="hljs-property">next</span>  <span class="hljs-keyword">while</span>(slow!==fast)&#123;    <span class="hljs-keyword">if</span>(!fast || !fast.<span class="hljs-property">next</span>)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>    slow = slow.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div></li></ul><ul><li><p>实现LRU缓存淘汰策略</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Node</span>(<span class="hljs-params">value</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">LRULinkedList</span>(<span class="hljs-params">maxSize</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxSize</span> = maxSize  <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">curSize</span> = <span class="hljs-number">0</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">visit</span> = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(value)    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>,pre = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>    <span class="hljs-keyword">let</span> preCatch,curCatch    <span class="hljs-keyword">if</span>(!cur)&#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">curSize</span> = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span>     &#125;    <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">value</span>===value) <span class="hljs-keyword">return</span>     <span class="hljs-keyword">while</span>(cur)&#123;      <span class="hljs-keyword">if</span>(cur.<span class="hljs-property">value</span> === value)&#123;          <span class="hljs-comment">// 找到了</span>          <span class="hljs-comment">// 从原来位置删除并作为头</span>          pre.<span class="hljs-property">next</span> = cur.<span class="hljs-property">next</span>          cur.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>          <span class="hljs-keyword">return</span>      &#125;      preCatch = pre      curCatch = cur      pre = cur      cur = cur.<span class="hljs-property">next</span>    &#125;    <span class="hljs-comment">// 没找到</span>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">curSize</span>&lt;maxSize)&#123;      <span class="hljs-comment">// 插入头部</span>      n.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = n      <span class="hljs-variable language_">this</span>.<span class="hljs-property">curSize</span> ++    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 删除尾部结点</span>      <span class="hljs-comment">// 插入头部</span>      preCatch.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>      curCatch.<span class="hljs-property">next</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = curCatch    &#125;  &#125;&#125;</code></pre></div></li><li><p>回文链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 快慢指针找出中点</span><span class="hljs-comment">// 一半的链表与另一半链表组成的栈对比</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">isPalindrome</span>(<span class="hljs-params">head</span>)&#123;  <span class="hljs-keyword">if</span>(!head || !head.<span class="hljs-property">next</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  <span class="hljs-keyword">const</span> stack = []  <span class="hljs-keyword">let</span> slow = head  <span class="hljs-keyword">let</span> fast = head  <span class="hljs-keyword">while</span>(fast &amp;&amp; fast.<span class="hljs-property">next</span> &amp;&amp; fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>)&#123;    slow = slow.<span class="hljs-property">next</span>    fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">let</span> mid  = slow  <span class="hljs-keyword">while</span> (mid.<span class="hljs-property">next</span>) &#123;    stack.<span class="hljs-title function_">push</span>(mid.<span class="hljs-property">next</span>)    mid = mid.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">if</span>(head.<span class="hljs-property">val</span> !== stack.<span class="hljs-title function_">pop</span>().<span class="hljs-property">val</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    head = head.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// 或者将链表转数组，对撞指针</span><span class="hljs-comment">// 另一种是到到中点后反转链表，不使用辅助栈</span></code></pre></div></li><li><p>合并两个有序链表</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Node</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>&#125;<span class="hljs-comment">// 1-&gt;2-&gt;4,1-&gt;3-&gt;4</span><span class="hljs-comment">// 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeLinkedList</span>(<span class="hljs-params">l1,l2</span>)&#123;  <span class="hljs-keyword">if</span>(l1===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l2  &#125;  <span class="hljs-keyword">if</span>(l2===<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> l1  &#125;  <span class="hljs-keyword">if</span>(l1.<span class="hljs-property">val</span>&lt;=l2.<span class="hljs-property">val</span>)&#123;    l1.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeLinkedList</span>(l1.<span class="hljs-property">next</span>,l2)    <span class="hljs-keyword">return</span> l1  &#125;<span class="hljs-keyword">else</span>&#123;    l2.<span class="hljs-property">next</span> = <span class="hljs-title function_">mergeLinkedList</span>(l2.<span class="hljs-property">next</span>,l1)    <span class="hljs-keyword">return</span> l2  &#125;&#125;<span class="hljs-comment">// 或者蠢办法</span><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span>(<span class="hljs-params">l1, l2</span>) &#123;   <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>)   <span class="hljs-keyword">let</span> cur = n   <span class="hljs-keyword">while</span>(l1&amp;&amp;l2)&#123;       <span class="hljs-keyword">if</span>(l1.<span class="hljs-property">val</span>&lt;=l2.<span class="hljs-property">val</span>)&#123;           cur.<span class="hljs-property">next</span> = l1           l1 = l1.<span class="hljs-property">next</span>       &#125;<span class="hljs-keyword">else</span>&#123;           cur.<span class="hljs-property">next</span> = l2           l2 = l2.<span class="hljs-property">next</span>       &#125;       cur = cur.<span class="hljs-property">next</span>   &#125;   <span class="hljs-comment">// 有一条到头咯</span>   <span class="hljs-keyword">if</span>(l1)&#123;       cur.<span class="hljs-property">next</span> = l1   &#125;<span class="hljs-keyword">else</span>&#123;       cur.<span class="hljs-property">next</span> = l2   &#125;   <span class="hljs-keyword">return</span> n.<span class="hljs-property">next</span>&#125;;</code></pre></div></li><li><p>查找两个链表的公共起始点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">commonPrefix</span>(<span class="hljs-params">headA,headB</span>)&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-keyword">while</span>(headA)&#123;    headA.<span class="hljs-property">flag</span> = <span class="hljs-literal">true</span>    headA = headA.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">while</span>(headB)&#123;    <span class="hljs-keyword">if</span>(headB.<span class="hljs-property">flag</span>) <span class="hljs-keyword">return</span> headB    headB.<span class="hljs-property">flag</span> =<span class="hljs-literal">true</span>    headB = headB.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">commonPrefix2</span>(<span class="hljs-params">headA,headB</span>)&#123;  <span class="hljs-keyword">if</span>(!headA || !headB) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-comment">// 连个链表同时移动指针</span>  <span class="hljs-keyword">let</span> n1 = headA  <span class="hljs-keyword">let</span> n2 = headB  <span class="hljs-keyword">while</span>(n1 || n2)&#123;    <span class="hljs-keyword">if</span>(n1===n2) <span class="hljs-keyword">return</span> n1    <span class="hljs-comment">//指针到头后跳到对面的开头</span>    n1 = n1 === <span class="hljs-literal">null</span> ? headB : n1.<span class="hljs-property">next</span>    n2 = n2 === <span class="hljs-literal">null</span> ? headA : n2.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>&#125;</code></pre></div></li><li><p>删除特定值链表节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteNode</span>(<span class="hljs-params">head,val</span>)&#123;  <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span>   <span class="hljs-keyword">if</span>(head.<span class="hljs-property">val</span> === val)&#123;    <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>  &#125;  head.<span class="hljs-property">next</span> = <span class="hljs-title function_">deleteNode</span>(head.<span class="hljs-property">next</span>,val)  <span class="hljs-keyword">return</span> head&#125;</code></pre></div></li><li><p>返回链表中特定位置节点</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 计数法</span><span class="hljs-comment">// 一遍算链表长度</span><span class="hljs-comment">// 一遍根据位置.next</span><span class="hljs-comment">// 计数法配合map</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getKthFromEnd</span>(<span class="hljs-params">head,k</span>)&#123;  <span class="hljs-keyword">let</span> pos = <span class="hljs-number">1</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()  <span class="hljs-keyword">while</span>(head)&#123;    map.<span class="hljs-title function_">set</span>(pos++,head)    head = head.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(pos-k)&#125;<span class="hljs-comment">// 双指针</span><span class="hljs-comment">// 返回倒数k位置</span><span class="hljs-comment">//  * Definition for singly-linked list.</span><span class="hljs-comment">//  * function ListNode(val) &#123;</span><span class="hljs-comment">//  *     this.val = val;</span><span class="hljs-comment">//  *     this.next = null;</span><span class="hljs-comment">//  * &#125;</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">getKthFromEnd</span>(<span class="hljs-params">head,k</span>)&#123;  <span class="hljs-keyword">let</span> fast = head  <span class="hljs-keyword">let</span> slow = head  <span class="hljs-keyword">let</span> t = <span class="hljs-number">0</span>  <span class="hljs-keyword">while</span>(fast.<span class="hljs-property">next</span>)&#123;    fast = fast.<span class="hljs-property">next</span>    t ++    <span class="hljs-keyword">if</span>(t&gt;=k) slow = slow.<span class="hljs-property">next</span>  &#125;  <span class="hljs-keyword">return</span> slow&#125;</code></pre></div></li><li><p>字符串中第一个不重复字符</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//map</span><span class="hljs-comment">//循环两次</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">firstUniqChar</span>(<span class="hljs-params">s</span>)&#123;  <span class="hljs-keyword">if</span>(!s) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [i,v] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(s).<span class="hljs-title function_">entries</span>())&#123;    <span class="hljs-keyword">if</span>(map.<span class="hljs-title function_">has</span>(v))&#123;      map.<span class="hljs-title function_">set</span>(v,-<span class="hljs-number">1</span>)    &#125;<span class="hljs-keyword">else</span>&#123;      map.<span class="hljs-title function_">set</span>(v,i)    &#125;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> map.<span class="hljs-title function_">keys</span>())&#123;    <span class="hljs-keyword">if</span>(map.<span class="hljs-title function_">get</span>(key)!==-<span class="hljs-number">1</span>)&#123;      <span class="hljs-keyword">return</span> key    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>&#125;<span class="hljs-comment">//</span>...indexOf===lastIndexOf...</code></pre></div></li><li><p>字符串能否构成回文</p></li></ul><p>字符顺序修改后能否回文<br>相当于非回文字符最多只有一个</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">canPermutePalindrome</span>(<span class="hljs-params">s</span>)&#123;  <span class="hljs-comment">// map // object都行</span>&#125;<span class="hljs-keyword">var</span> canPermutePalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;  <span class="hljs-keyword">const</span> obj = &#123;&#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i&lt;s.<span class="hljs-property">length</span> ;i++)&#123;    <span class="hljs-keyword">const</span> str = s[i]    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);    <span class="hljs-keyword">if</span>(obj[str])&#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);      <span class="hljs-keyword">delete</span> obj[str]    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 使用object时，上面的if(obj[str])会和这里冲突</span>      <span class="hljs-comment">// 刚好设置obj[str] = 0</span>      <span class="hljs-comment">// if判断不成立</span>      obj[str] = <span class="hljs-number">1</span>    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>&#125;;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列及算法题</title>
    <link href="/2022/02/24/%E9%98%9F%E5%88%97/"/>
    <url>/2022/02/24/%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="队列结构，先进先出"><a href="#队列结构，先进先出" class="headerlink" title="队列结构，先进先出"></a>队列结构，先进先出</h2><ul><li><p>用数组实现-顺序队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ArrayQueue</span>(<span class="hljs-params">len</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len)  <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> = len  <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-number">0</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-number">0</span>&#125;<span class="hljs-title class_">ArrayQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">enqueue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span>)&#123;<span class="hljs-comment">// tail后没有空余空间</span>    <span class="hljs-keyword">if</span>(head === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-comment">// 判断是否队列前方有已经出队的位置</span>    <span class="hljs-comment">// 有则将整个队列向前移动</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = head;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>;i++)&#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i-head] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i]    &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>-<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-number">0</span>  &#125;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>] = item  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> ++  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-title class_">ArrayQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">dequeue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> ++   <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">shift</span>()&#125;</code></pre></div></li><li><p>!循环队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 避免了顺序队列中的数据搬移操作</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">CircularQueue</span>(<span class="hljs-params">len</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len)  <span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> = len  <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-number">0</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-number">0</span>&#125;<span class="hljs-title class_">CircularQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">enqueue</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;    <span class="hljs-keyword">if</span>((<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>+<span class="hljs-number">1</span>)%n===<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>] = item    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  <span class="hljs-attr">dequeue</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>===<span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>    <span class="hljs-keyword">const</span> ret = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[head]    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>+<span class="hljs-number">1</span>)%n    <span class="hljs-keyword">return</span> ret  &#125;&#125;</code></pre></div></li><li><p>用链表实现-链式队列</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Node</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = val  <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>&#125;<span class="hljs-keyword">function</span> <span class="hljs-title function_">LinkedListQueue</span>(<span class="hljs-params">len</span>)&#123;  <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-literal">null</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">curLen</span> = <span class="hljs-number">0</span>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLen</span> = len&#125;<span class="hljs-title class_">LinkedListQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">enqueue</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>)&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>===<span class="hljs-literal">null</span>)&#123;      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = node      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = node      <span class="hljs-variable language_">this</span>.<span class="hljs-property">curLen</span> = <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">curLen</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">len</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>    <span class="hljs-comment">// 循环到链表末尾</span>    <span class="hljs-keyword">while</span>(cur.<span class="hljs-property">next</span>)&#123;      cur = cur.<span class="hljs-property">next</span>    &#125;    cur.<span class="hljs-property">next</span> = node    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = node    <span class="hljs-variable language_">this</span>.<span class="hljs-property">curLen</span> ++    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;,  dequeue : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">let</span> cur = <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span>    <span class="hljs-comment">// 删除表头</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = cur.<span class="hljs-property">next</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">curLen</span> --    <span class="hljs-keyword">return</span> cur  &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象题</title>
    <link href="/2022/02/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/"/>
    <url>/2022/02/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ul><li>打车时可以打专车或快车。任何车都有车牌号和名称。快车每公里1元，专车每公里2元。行程开始时，显示车辆信息。行程结束时，显示打车金额。行程距离为5公里。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licence,name</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">licence</span> = licence    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">FastCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Car</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licence,name</span>)&#123;    <span class="hljs-variable language_">super</span>(licence,name)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> =<span class="hljs-number">1</span>  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Car</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licence,name</span>)&#123;    <span class="hljs-variable language_">super</span>(licence,name)    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = <span class="hljs-number">2</span>  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">car,distance</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = car    <span class="hljs-variable language_">this</span>.<span class="hljs-property">distance</span> = distance  &#125;  <span class="hljs-title function_">getIn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>.<span class="hljs-property">name</span>);    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>.<span class="hljs-property">licence</span>);  &#125;  <span class="hljs-title function_">getOff</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>.<span class="hljs-property">price</span>*<span class="hljs-variable language_">this</span>.<span class="hljs-property">distance</span>);  &#125;&#125;<span class="hljs-keyword">let</span> car1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivateCar</span>(<span class="hljs-string">&#x27;粤A8888888&#x27;</span>,<span class="hljs-string">&#x27;特斯拉&#x27;</span>)<span class="hljs-keyword">let</span> cost1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(car1,<span class="hljs-number">5</span>).<span class="hljs-title function_">getOff</span>()</code></pre></div><ul><li>某停车场, 分三层, 每层100 车位,每个车位都能监控到车辆的进入和离开,车辆进入前,显示每层的空余车位数量,车辆进入时,摄像头可识别车牌号和进入时间,车辆出来时,出口显示屏显示车牌号和停车时长</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licence</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">licence</span> = licence  &#125;&#125;<span class="hljs-comment">// 整个停车场</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkingLot</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">floors</span>)&#123;    <span class="hljs-comment">// floors:[[300],[300],[300]]</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">floors</span> = floors    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataBase</span> = []  &#125;  <span class="hljs-title function_">showSpace</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">floors</span>.<span class="hljs-property">length</span>;i++)&#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第<span class="hljs-subst">$&#123;i+<span class="hljs-number">1</span>&#125;</span>层空闲车位(<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.floors[i].emptySpace()&#125;</span>)`</span>)    &#125;  &#125;  <span class="hljs-title function_">intoLot</span>(<span class="hljs-params">car,floorIndex,lotIndex</span>)&#123;    <span class="hljs-comment">//车牌，时间</span>    <span class="hljs-keyword">let</span> licence = car.<span class="hljs-property">licence</span>    <span class="hljs-keyword">let</span> intoTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()    <span class="hljs-keyword">let</span> space = <span class="hljs-variable language_">this</span>.<span class="hljs-property">floors</span>[floorIndex].<span class="hljs-property">lot</span>[lotIndex]    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataBase</span>[licence] = &#123;intoTime,floorIndex,lotIndex&#125;    space.<span class="hljs-title function_">checkIn</span>()  &#125;  <span class="hljs-title function_">outLot</span>(<span class="hljs-params">car</span>)&#123;    <span class="hljs-keyword">let</span> outTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()    <span class="hljs-keyword">let</span> licence = car.<span class="hljs-property">licence</span>    <span class="hljs-keyword">let</span> info = <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataBase</span>[licence]    <span class="hljs-keyword">let</span> space = <span class="hljs-variable language_">this</span>.<span class="hljs-property">floors</span>[info.<span class="hljs-property">floorIndex</span>].<span class="hljs-property">lot</span>[info.<span class="hljs-property">lotIndex</span>]    <span class="hljs-keyword">let</span> timeCount = <span class="hljs-built_in">parseInt</span>((outTime-info.<span class="hljs-property">intoTime</span>)/<span class="hljs-number">36000000</span>)    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`停车时长<span class="hljs-subst">$&#123;timeCount&#125;</span>小时`</span>)    space.<span class="hljs-title function_">checkOut</span>()  &#125;&#125;<span class="hljs-comment">// 车位,监视驶入离开</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkingSpace</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">free</span> = <span class="hljs-literal">true</span>  &#125;  <span class="hljs-title function_">checkIn</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">free</span> = <span class="hljs-literal">false</span>  &#125;  <span class="hljs-title function_">checkOut</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">free</span> = <span class="hljs-literal">true</span>  &#125;&#125;<span class="hljs-comment">// 层</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkingFloor</span>&#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">floor,lot</span>)&#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">floor</span> = floor    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lot</span> = lot  &#125;  <span class="hljs-title function_">emptySpace</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">//返回空闲车位</span>    <span class="hljs-keyword">let</span> freeLot = <span class="hljs-number">0</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lot</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span>(item.<span class="hljs-property">free</span>)&#123;        freeLot++      &#125;    &#125;);    <span class="hljs-keyword">return</span> freeLot  &#125;&#125;</code></pre></div><ul><li>一副扑克牌有54张牌，其中52张是正牌，另2张是副牌（大王和小王）。<br>52张正牌又均分为13张一组，并以黑桃、红桃、草花、方块四种花色表示各组，每组花色的牌包括从1-10（1通常表示为A）以及J、Q、K标示的13张牌。<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;J&#x27;</span>,<span class="hljs-string">&#x27;Q&#x27;</span>,<span class="hljs-string">&#x27;K&#x27;</span>]<span class="hljs-keyword">const</span> signs = [<span class="hljs-string">&#x27;♥️&#x27;</span>, <span class="hljs-string">&#x27;♦️&#x27;</span>, <span class="hljs-string">&#x27;♣️&#x27;</span>, <span class="hljs-string">&#x27;♠️&#x27;</span>]<span class="hljs-keyword">class</span> <span class="hljs-title class_">Poker</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">signs,numbers</span>) &#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">signs</span> = signs<span class="hljs-variable language_">this</span>.<span class="hljs-property">numbers</span> = numbers<span class="hljs-variable language_">this</span>.<span class="hljs-property">mounts</span> = <span class="hljs-number">52</span><span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span> = []&#125;<span class="hljs-title function_">initPokers</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">signs</span>.<span class="hljs-property">length</span>;i++)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>;j&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">numbers</span>.<span class="hljs-property">length</span>;j++)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">signs</span>[i],<span class="hljs-variable language_">this</span>.<span class="hljs-property">numbers</span>[j]))&#125;&#125;<span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&#x27;BLACK&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))<span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Card</span>(<span class="hljs-string">&#x27;RED&#x27;</span>,<span class="hljs-string">&#x27;GHOST&#x27;</span>))&#125;  <span class="hljs-title function_">shuffleCard</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-comment">// let arr = this.pokers</span><span class="hljs-comment">// let len = arr.length</span>    <span class="hljs-comment">// let temp,i</span>    <span class="hljs-comment">// while(len)&#123;</span>    <span class="hljs-comment">//   i = Math.floor(Math.random()*len--)</span>    <span class="hljs-comment">//   temp = arr[i]</span>    <span class="hljs-comment">//   arr[i] = arr[len]</span>    <span class="hljs-comment">//   arr[len] = temp</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-comment">// this.pokers = arr</span>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()-<span class="hljs-number">0.5</span>)    <span class="hljs-comment">// Math.random() - 0.5 不完全随机</span>    <span class="hljs-keyword">const</span> temp = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span>]    <span class="hljs-keyword">let</span> len = temp.<span class="hljs-property">length</span>    <span class="hljs-keyword">while</span>(len)&#123;      <span class="hljs-keyword">const</span> i = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * len--)      [temp[i],temp[len]] = [temp[len],temp[i]]      &#125;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pokers</span> = [...temp]  &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Card</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">sign, number</span>) &#123;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sign</span> = sign;    <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> = number;  &#125;&#125;<span class="hljs-keyword">let</span> game1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Poker</span>(signs,numbers)game1.<span class="hljs-title function_">initPokers</span>()game1.<span class="hljs-title function_">shuffleCard</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(game1.<span class="hljs-property">pokers</span>);game1.<span class="hljs-title function_">shuffleCard</span>()<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(game1.<span class="hljs-property">pokers</span>);</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地址中输入URL回车后发生了什么</title>
    <link href="/2022/02/24/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/02/24/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="【DNS解析】"><a href="#【DNS解析】" class="headerlink" title="【DNS解析】"></a>【DNS解析】</h2><ol><li>查找浏览器DNS缓存</li><li>查找系统HOST文件</li><li>DNS查询<blockquote><p>主机和本地域名服务器之间使用递归查询，本地域名服务器要负责一直到查询得出结果</p><p>本地域名服务器和其他服务器之间的使用迭代查询，域名服务器会告诉本地服务器下一次去询问谁，防止单台域名服务器压力过大</p></blockquote></li></ol><blockquote><p>DNS请求使用<code>UDP</code>协议，如果请求失败则使用<code>TCP</code>重试</p></blockquote><div class="hljs code-wrapper"><pre><code class="hljs">1. 本地DNS服务器查找自己缓存2. 本地DNS服务器向【根域名服务器】发送请求，根域名服务器返回顶级域名服务器的地址`com`3. 本地DNS服务器向顶级域名服务器发送请求，顶级域名返回二级域名的服务器地址`baidu.com`4. 本地DNS服务器向二级域名服务器发送请求，得到目标主机IP地址，存入本地DNS服务器缓存并返回给用户主机5. 用户主机和浏览器都将缓存这个IP地址的映射</code></pre></div><h2 id="【TCP握手】"><a href="#【TCP握手】" class="headerlink" title="【TCP握手】"></a>【TCP握手】</h2><p>对应IP地址，端口建立TCP连接，构造HTTP请求并与服务器握手后发送tcp数据包</p><p>  TCP三次握手</p><blockquote><p>客户端与服务端互相确认收发能力</p></blockquote><ol><li>【CLIENT】 发送<code>SYN</code>报文，指明自己的初始化序列号<code>ISN(c)</code></li><li>【SERVER】 收到后，将client发送的<code>ISN(c)</code>+1作为<code>ACK</code>字符，并且也生成自己的<code>ISN(s)</code>发送给【CLIENT】</li><li>【CLIENT】 收到后，同样将<code>ISN(s)</code>+1作为<code>ACK</code>字符发送给【SERVER】</li></ol><h2 id="【分析请求资源】"><a href="#【分析请求资源】" class="headerlink" title="【分析请求资源】"></a>【分析请求资源】</h2><ul><li><p>不同浏览器对资源优先级分类</p></li><li><p>安全策略检查 </p><p>内容安全策略(Content Security Policy，缩写 CSP)是由浏览器提供的一种白名单制度。发者通过配置，来告诉浏览器各类外部资源的加载和执行限制，来提高网页的安全性。一种最常用应用就是通过限制非信任域名脚本的加载来预防XSS攻击。</p><p>可以通过两种方式来配置CSP：</p><ol><li>HTTP请求头的<code>Content-Security-Policy</code></li><li><code>meta</code>标签 <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;meta http-equiv=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> content=<span class="hljs-string">&quot;script-src &#x27;self&#x27;;style-src nos.netease.com kaola.com;&quot;</span>&gt;</code></pre></div></li></ol></li><li><p>资源优先级计算</p><ol><li><code>html,font,css</code></li><li><code>preload,script,xhr</code></li><li><code>img,audio,video</code></li><li><code>prefetch</code></li></ol></li><li><p>顺序调整</p><ol><li>同步XHR请求优先级调整到最高</li><li>图片根据是否出现在可视区域</li><li><code>async/defer</code>的<code>script</code>标签请求优先级降低</li></ol></li></ul><h2 id="【应用缓存策略】"><a href="#【应用缓存策略】" class="headerlink" title="【应用缓存策略】"></a>【应用缓存策略】</h2><ul><li>强缓存</li><li>协商缓存</li></ul><h2 id="【渲染页面】"><a href="#【渲染页面】" class="headerlink" title="【渲染页面】"></a>【渲染页面】</h2><h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><ul><li>处理html标记，生成DOM树，所有标签都会包含在内</li><li>DOM的构建是增量的</li><li>解析完一个节点的所有子元素才会解析他的兄弟元素</li></ul><h3 id="CSSOM-Tree"><a href="#CSSOM-Tree" class="headerlink" title="CSSOM Tree"></a>CSSOM Tree</h3><ul><li>加载所有样式，生成CSSOM树</li><li>CSSOM的构建会阻塞渲染<blockquote><p>不同来源的样式（内联、内部style标签和外部引用）可能会发生覆盖，所以要等他们全加载完才能继续渲染</p></blockquote></li></ul><h3 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h3><ul><li>对DOM节点找到与其匹配的CSSOM规则并应用</li><li>只包含DOM树中的可见元素(忽略像<code>display：none/&lt;head&gt;标签</code>)</li></ul><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>浏览器依据Render树和设备屏幕信息<strong>重排</strong>一次，从 <code>&lt;html&gt;标签</code> 开始往下依次计算所有的节点几何尺寸和位置</p><h3 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h3><p>根据上一步得到的像素信息<strong>重绘</strong>页面</p><h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p>GPU合成各图层，显示在屏幕上</p><h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><h3 id="重排reflow"><a href="#重排reflow" class="headerlink" title="重排reflow"></a>重排<code>reflow</code></h3><ul><li>有些情况下，比如修改了元素的样式，浏览器并不会立刻reflow，而是会把这样的操作积攒一批，然后做一次处理，这又叫异步 reflow 或增量异步 reflow。</li><li>在有些情况下，比如窗口<code>resize</code>，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li><li>除了渲染树的直接变化，当获取一些需要计算的属性时，浏览器为取得正确的值也会触发重排,这些属性包括：<code>offsetXXX、scrollXXX、clientXXX、getComputedStyle()</code></li><li>重排必定触发重绘</li></ul><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重绘，但是元素的几何尺寸没有变。</p><h3 id="合成层"><a href="#合成层" class="headerlink" title="合成层"></a>合成层</h3><p>区别于一般的图层，合成层【composite】使用GPU线程进行计算</p><h3 id="提升到合成层的条件"><a href="#提升到合成层的条件" class="headerlink" title="提升到合成层的条件"></a>提升到合成层的条件</h3><ul><li>3D<code>transform</code></li><li><code>opacity</code></li><li><code>filter</code></li><li><code>will-change</code></li><li><code>&lt;video&gt;,&lt;audio&gt;,&lt;canvas&gt;</code></li><li><code>position:fixed</code></li></ul><h3 id="解析URL参数"><a href="#解析URL参数" class="headerlink" title="解析URL参数"></a>解析URL参数</h3><ol><li><p>正则解析</p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseQueryString</span>(<span class="hljs-params">url</span>)&#123;  <span class="hljs-keyword">const</span> rule = <span class="hljs-regexp">/([^?=&amp;]+)=([^&amp;#]*)/g</span>    <span class="hljs-keyword">return</span> url.<span class="hljs-title function_">match</span>(rule).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;    <span class="hljs-keyword">let</span> [k,v] = b.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;=&#x27;</span>)    k = <span class="hljs-built_in">decodeURIComponent</span>(k)    v = <span class="hljs-title function_">decodeIRIComponent</span>(v)    a[k] = a[k] ? [...a[k],v] : v    <span class="hljs-keyword">return</span> a  &#125;,&#123;&#125;)  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li><li><p>API解析</p><p> URLSearchParams<br> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams">https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams</a></p> <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseURL</span>(<span class="hljs-params">url</span>)&#123;  <span class="hljs-keyword">const</span> urlObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(url.<span class="hljs-title function_">slice</span>(url.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;?&#x27;</span>)))  <span class="hljs-keyword">const</span> res = []  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> urlObj.<span class="hljs-title function_">keys</span>())&#123;    res[key] = urlObj.<span class="hljs-title function_">getAll</span>(key)  &#125;  <span class="hljs-keyword">return</span> res&#125;</code></pre></div></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码提交规范新手包</title>
    <link href="/2022/01/17/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E6%96%B0%E6%89%8B%E5%8C%85/"/>
    <url>/2022/01/17/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E6%96%B0%E6%89%8B%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="prettier代码美化"><a href="#prettier代码美化" class="headerlink" title="prettier代码美化"></a>prettier代码美化</h2><ul><li>  安装</li></ul><p>lint-stage<a href="https://github.com/okonet/lint-staged#examples">https://github.com/okonet/lint-staged#examples</a></p><div class="hljs code-wrapper"><pre><code class="hljs javascript">yarn add prettier --dev<span class="hljs-comment">// 为了不与eslint冲突</span>yarn add eslint-config-prettier<span class="hljs-comment">// 初始化lint-stage</span>npx mrm@<span class="hljs-number">2</span> lint-staged<span class="hljs-comment">// 这里会自动安装husky</span></code></pre></div><ul><li>创建配置文件 <code>.prettierrc</code> <code>.prettierIgnore</code></li><li>  修改 eslint 配置</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;!-- package.<span class="hljs-property">json</span> --&gt;  <span class="hljs-string">&quot;eslintConfig&quot;</span>: &#123;  <span class="hljs-string">&quot;rules&quot;</span>: &#123;    <span class="hljs-string">&quot;@typescript-eslint/no-unused-vars&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>  &#125;,  <span class="hljs-string">&quot;extends&quot;</span>: [    <span class="hljs-string">&quot;react-app&quot;</span>,    <span class="hljs-string">&quot;react-app/jest&quot;</span>,    <span class="hljs-string">&quot;prettier&quot;</span> ++  ]&#125;,<span class="hljs-string">&quot;lint-staged&quot;</span>: &#123;  <span class="hljs-string">&quot;*.&#123;js,css,md,ts,tsx&#125;&quot;</span>: <span class="hljs-string">&quot;prettier --write&quot;</span>&#125;</code></pre></div><h2 id="commit-校验工具"><a href="#commit-校验工具" class="headerlink" title="commit 校验工具"></a>commit 校验工具</h2><ul><li>  安装</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 安装cli和配置</span>yarn add @commitlint/&#123;config-conventional,cli&#125; --dev<span class="hljs-comment">// 创建配置commitlint文件</span>echo <span class="hljs-string">&quot;module.exports = &#123;extends:[&#x27;@commitlint/config-conventional&#x27;]&#125;&quot;</span> &gt; commitlint.<span class="hljs-property">config</span>.<span class="hljs-property">js</span></code></pre></div><ul><li>  配置</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加husky钩子</span>npx husky add .<span class="hljs-property">husky</span>/commit-msg <span class="hljs-string">&#x27;npx --no-install commitlint --edit &quot;$1&quot;&#x27;</span></code></pre></div><h2 id="commit-交互式提交工具"><a href="#commit-交互式提交工具" class="headerlink" title="commit 交互式提交工具"></a>commit 交互式提交工具</h2><p><a href="https://commitlint.js.org/#/?id=getting-started">https://commitlint.js.org/#/?id=getting-started</a></p><ul><li><p>安装</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">npm i -d commitizen</code></pre></div></li><li><p>预设配置</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 预设</span>npm i -d cz-conventional-changelog <span class="hljs-comment">// or cz-conventional</span></code></pre></div></li><li><p>修改<code>package.json</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加config</span><span class="hljs-string">&quot;config&quot;</span>: &#123;  <span class="hljs-string">&quot;commitizen&quot;</span>: &#123;    <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;cz-conventional-changelog // cz-conventional&quot;</span>  &#125;&#125;</code></pre></div></li><li><p>交互式提交</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 添加到script</span><span class="hljs-string">&quot;commit&quot;</span>:<span class="hljs-string">&quot;cz&quot;</span></code></pre></div></li></ul><h2 id="生成-CHANGELOG"><a href="#生成-CHANGELOG" class="headerlink" title="生成 CHANGELOG"></a>生成 CHANGELOG</h2><ul><li><p>安装</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">npm i -D standard-version</code></pre></div></li><li><p>添加 script</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;  <span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <span class="hljs-string">&quot;release&quot;</span>: <span class="hljs-string">&quot;standard-version&quot;</span>  &#125;&#125;</code></pre></div></li><li><p>  运行后会自动生成<code>CHANGELOG.md</code>，当提交类型是 feat 和 fix 的时候版本号会累加</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mapbox-gl拾遗</title>
    <link href="/2022/01/17/mapbox-gl/"/>
    <url>/2022/01/17/mapbox-gl/</url>
    
    <content type="html"><![CDATA[<h2 id="expressions"><a href="#expressions" class="headerlink" title="expressions"></a>expressions</h2><p><a href="https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/">https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/</a></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>适用于<code>Style</code>中的<code>layout</code>,<code>paint</code>,<code>filter</code>属性，均可添加表达式。</li><li>表达式定义了如何使用逻辑、数学、字符串或颜色操作组合<code>feature</code>中的一个或多个<code>properties</code>或<code>zoom</code>，以生成适当的样式属性值或过滤器决策。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><code>[expression_name, argument_0, argument_1, ...]</code></p><ol><li>常用操作符<code>expression_name</code></li></ol><ul><li><code>*</code></li><li><code>case</code></li><li><code>==,&gt;=,&lt;</code>(比较的两边类型需要相同，都是数字或都是字符串)</li><li><code>match</code></li><li><code>all</code></li><li><code>contact</code><br>…  </li></ul><ol><li><p>大部分操作符可以多级嵌套</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&quot;line-dasharray&quot;</span>: [<span class="hljs-string">&quot;case&quot;</span>,[<span class="hljs-string">&quot;==&quot;</span>, [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;customStatus&quot;</span>], <span class="hljs-string">&quot;PLANING&quot;</span>], <span class="hljs-comment">// 规划</span>[<span class="hljs-string">&quot;literal&quot;</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>]],[<span class="hljs-string">&quot;==&quot;</span>, [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;customStatus&quot;</span>], <span class="hljs-string">&quot;TEST&quot;</span>], <span class="hljs-comment">// 测试</span>[<span class="hljs-string">&quot;literal&quot;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]],<span class="hljs-comment">// 回退选项</span>[<span class="hljs-string">&quot;literal&quot;</span>, [<span class="hljs-number">1</span>]],],</code></pre></div></li><li><p>定义变量的表达式<br>变量需要设定在使用变量的外层表达式</p></li><li><p>获取feature属性</p></li></ol><ul><li><code>[&#39;get&#39;,&#39;propName&#39;]</code>获取properties对象中的属性</li><li><code>$propName</code>获取定义在feature对象顶层的属性，例如<code>$type</code>,<code>$geometry</code><br>``</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>data表达式<div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;    <span class="hljs-string">&quot;circle-color&quot;</span>: [        <span class="hljs-string">&quot;rgb&quot;</span>,        <span class="hljs-comment">// red is higher when feature.properties.temperature is higher</span>        [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;temperature&quot;</span>],<span class="hljs-comment">// r数值取temperature数值</span>        <span class="hljs-comment">// green is always zero</span>        <span class="hljs-number">0</span>,        <span class="hljs-comment">// blue is higher when feature.properties.temperature is lower</span>        [<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">100</span>, [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;temperature&quot;</span>]]<span class="hljs-comment">// b数值=100-temp</span>    ]&#125;</code></pre></div></li><li>camera表达式<div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;    <span class="hljs-string">&quot;circle-radius&quot;</span>: [        <span class="hljs-string">&quot;interpolate&quot;</span>, [<span class="hljs-string">&quot;linear&quot;</span>], [<span class="hljs-string">&quot;zoom&quot;</span>],        <span class="hljs-comment">// zoom is 5 (or less) -&gt; circle radius will be 1px</span>        <span class="hljs-number">5</span>, <span class="hljs-number">1</span>,        <span class="hljs-comment">// zoom 5到10两个定义档位之间，interpolate运算符讲线性计算数值</span>        <span class="hljs-comment">// zoom is 10 (or greater) -&gt; circle radius will be 5px</span>        <span class="hljs-number">10</span>, <span class="hljs-number">5</span>    ]&#125;</code></pre></div></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>mapbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>graphql新手包</title>
    <link href="/2022/01/04/graphql%E6%96%B0%E6%89%8B%E5%8C%85/"/>
    <url>/2022/01/04/graphql%E6%96%B0%E6%89%8B%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="GraphQl"><a href="#GraphQl" class="headerlink" title="GraphQl"></a>GraphQl</h2><p><code>GraphQL</code>是一个旨在简化前端和后端之间通信的规范。它主要由服务端的 schema 语言和客户端的查询语言组成。<br>【_查询语法和 schema 语法几乎是相等的_】。</p><p><code>gql</code>的 api 需要完整描述期望返回的数据，相对于<code>RestFul API</code>减少了数据的冗余。修改一下官网的示例：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 描述你的数据</span><span class="hljs-comment">// 定义了一个名为Project的对象类型，该类型上有三个字段，并且字段拥有不同的数据类型</span>type <span class="hljs-title class_">Project</span> &#123;  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>  <span class="hljs-attr">tagline</span>: <span class="hljs-title class_">String</span>  <span class="hljs-attr">contributors</span>: [<span class="hljs-title class_">User</span>]&#125;<span class="hljs-comment">// 请求你所要的数据</span><span class="hljs-comment">// 请求project中，name值为字符串‘GraphQl’的数据，并返回他的tagline字段</span>&#123;  <span class="hljs-title function_">project</span>(<span class="hljs-params">name: <span class="hljs-string">&quot;GraphQL&quot;</span></span>) &#123;    tagline  &#125;&#125;<span class="hljs-comment">// 得到可预测的结果</span>&#123;  <span class="hljs-string">&quot;project&quot;</span>: &#123;    <span class="hljs-string">&quot;tagline&quot;</span>: <span class="hljs-string">&quot;A query language for APIs&quot;</span>  &#125;&#125;</code></pre></div><ul><li><p>  gql 实体资源不能通过 URL 识别</p></li><li><p>与 gql 服务器的<strong>全部</strong>数据交互基于一个指定的<code>URL</code>通<br>  道</p></li><li><p>标准的 gql GET 请求</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-attr">http</span>:<span class="hljs-comment">//myapi/graphql?query=&#123;me&#123;name&#125;&#125;</span>&#123;  me&#123;    name  &#125;&#125;</code></pre></div></li><li><p>标准的 gql POST 请求</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">content-<span class="hljs-attr">type</span>:application/json&#123;  <span class="hljs-string">&quot;query&quot;</span>: 查询的对象及参数,  <span class="hljs-string">&quot;operationName&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,  <span class="hljs-string">&quot;variables&quot;</span>: 变量形式的参数传参&#125;<span class="hljs-comment">// 并且一般会发起两次请求，先发一次OPTION，</span></code></pre></div></li></ul><h3 id="gql-文件"><a href="#gql-文件" class="headerlink" title="gql 文件"></a>gql 文件</h3><ul><li>  比较方便的管理 gql 接口的方式就是预先编写<code>.graphql</code>文件，方便复用和拓展。</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 在一个gql文件内声明多个query，需要命名query，并支持es6结构引用。单个query请求文件则可不命名。</span>query <span class="hljs-title function_">queryxxx</span>(<span class="hljs-params"></span><span class="hljs-params">  $variable1: <span class="hljs-built_in">String</span></span><span class="hljs-params">  $variable2: [<span class="hljs-built_in">String</span>]</span><span class="hljs-params"></span>)&#123;  <span class="hljs-title function_">myCoWorkers</span>(<span class="hljs-params"></span><span class="hljs-params">    name:$variable1</span><span class="hljs-params">    gender:$variable2</span><span class="hljs-params">  </span>)&#123;    name    age    gender    nation  &#125;&#125;</code></pre></div><ul><li>  也可以在请求时手动编写（需安装’graphql-tag’）</li></ul><div class="hljs code-wrapper"><pre><code class="hljs javascript">$apollo.<span class="hljs-title function_">query</span>(  <span class="hljs-attr">query</span>:gql<span class="hljs-string">`query tagList &#123;</span><span class="hljs-string">      tags &#123;</span><span class="hljs-string">        id,</span><span class="hljs-string">        label</span><span class="hljs-string">      &#125;</span><span class="hljs-string">    &#125;`</span>)</code></pre></div><h2 id="ApolloClient"><a href="#ApolloClient" class="headerlink" title="ApolloClient"></a>ApolloClient</h2><p><code>Apollo</code>是实现 gql 标准的客户端，(可以理解成使用 gql 的<code>axios</code>)。各大框架和开发场景都有对应的整合库，如<code>VueApollo</code>。</p><h3 id="常用-api-选项"><a href="#常用-api-选项" class="headerlink" title="常用 api/选项"></a>常用 api/选项</h3><p><a href="https://vue-apollo.netlify.app/zh-cn/api/smart-query.html#%E9%80%89%E9%A1%B9">https://vue-apollo.netlify.app/zh-cn/api/smart-query.html#%E9%80%89%E9%A1%B9</a></p><ul><li><p>  query 查询表（可以是 query，mutation）</p></li><li><p>  variables 变量</p></li><li><p>fetchPolicy 缓存选项</p>  <div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section"># cache-first[default]</span>Apollo Client 首先对缓存执行查询。如果缓存中存在所有请求的数据，则返回该数据。否则，Apollo Client 会针对您的 GraphQL 服务器执行查询，并在缓存数据后返回该数据。<span class="hljs-section"># cache-only</span>Apollo Client 仅针对缓存执行查询。在这种情况下，它永远不会查询您的服务器。如果缓存不包含所有请求字段的数据，则会引发错误。<span class="hljs-section"># cache-and-network</span>Apollo Client 对缓存和 GraphQL 服务器执行完整查询。如果服务器端查询的结果修改了缓存字段，则查询会自动更新。<span class="hljs-section"># network-only</span>Apollo Client 会针对您的 GraphQL 服务器执行完整查询，而无需先检查缓存。查询的结果存储在缓存中。<span class="hljs-section"># no-cache</span>与 network-only 类似, 但不缓存结果。<span class="hljs-section"># standby</span>使用与 cache-first 相同的逻辑，除了当基础字段值更改时此查询不会自动更新。您仍然可以使用 refetch 和 updateQueries 手动更新此查询。</code></pre></div></li><li><p>  pollInterval 轮询（间隔 x 毫秒）</p></li><li><p>  fetchMore 加载更多（可以改变个别或全部参数发送同一个请求，需手动处理请求结果）</p></li></ul><h3 id="使用-Apollo（vue-v2）"><a href="#使用-Apollo（vue-v2）" class="headerlink" title="使用 Apollo（vue v2）"></a>使用 Apollo（vue v2）</h3><ul><li><p>安装<code>Apollo</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">yarn add vue-apollo graphql apollo-boost#  apollo-boost 是创建apollo client的懒人包，包含常用的默认值，无需繁琐的手动配置ornpm install --save vue-apollo graphql apollo-client apollo-link apollo-link-http apollo-cache-inmemory graphql-tag</code></pre></div></li><li><p>封装<code>ApolloClient</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ApolloClient</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;apollo-boost&quot;</span>;<span class="hljs-keyword">const</span> $apollo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloClient</span>(&#123;<span class="hljs-attr">uri</span>:<span class="hljs-string">&#x27;xxx&#x27;</span>&#125;)<span class="hljs-comment">// or</span><span class="hljs-comment">// 封装举例</span><span class="hljs-comment">// 超时</span><span class="hljs-keyword">import</span> <span class="hljs-title class_">ApolloLinkTimeout</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;apollo-link-timeout&quot;</span>;<span class="hljs-keyword">const</span> timeoutLink = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloLinkTimeout</span>(<span class="hljs-number">30000</span>);<span class="hljs-comment">// 缓存</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">InMemoryCache</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;apollo-cache-inmemory&#x27;</span><span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InMemoryCache</span>()<span class="hljs-comment">// link</span><span class="hljs-keyword">const</span> httpLink = <span class="hljs-title function_">createHttpLink</span>(&#123; <span class="hljs-attr">uri</span>: <span class="hljs-string">&#x27;xxx&#x27;</span> &#125;);<span class="hljs-keyword">const</span> timeoutHttpLink = timeoutLink.<span class="hljs-title function_">concat</span>(httpLink);<span class="hljs-keyword">const</span> apolloClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApolloClient</span>(&#123;  <span class="hljs-attr">version</span>:<span class="hljs-string">&#x27;&#x27;</span>,  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,  <span class="hljs-attr">link</span>: timeoutHttpLink,<span class="hljs-comment">//同时提供时优先级高于uri，提供更精细化的配置</span>  <span class="hljs-attr">cache</span>: <span class="hljs-comment">// InMemoryCache (&#123;......&#125;) 缓存控制 www.apollographql.com/docs/react/caching/cache-configuration/`</span>  <span class="hljs-attr">defaultOptions</span>:&#123;      <span class="hljs-attr">watchQuery</span>: &#123;        <span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">&#x27;cache-and-network&#x27;</span>,        <span class="hljs-attr">errorPolicy</span>: <span class="hljs-string">&#x27;ignore&#x27;</span>,      &#125;,      <span class="hljs-attr">query</span>: &#123;        <span class="hljs-attr">fetchPolicy</span>: <span class="hljs-string">&#x27;network-only&#x27;</span>,        <span class="hljs-attr">errorPolicy</span>: <span class="hljs-string">&#x27;all&#x27;</span>,      &#125;,      <span class="hljs-attr">mutate</span>: &#123;        <span class="hljs-attr">errorPolicy</span>: <span class="hljs-string">&#x27;all&#x27;</span>,      &#125;    &#125;<span class="hljs-comment">//&#x27;各种查询的默认策略&#x27;</span>  &#125;);</code></pre></div></li><li><p>使用方法</p><ul><li><h4 id="apollo-provider"><a href="#apollo-provider" class="headerlink" title="apollo provider"></a>apollo provider</h4><p>  使用 apollo 组件，需先生成<code>apollo provider</code>，为 vue 实例提供 apollo 能力</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueApollo</span>);<span class="hljs-keyword">const</span> apolloProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueApollo</span>(&#123;<span class="hljs-attr">defaultClient</span>: apolloClient,&#125;);<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,<span class="hljs-comment">// 像 vue-router 或 vuex 一样注入 apolloProvider</span>apolloProvider,<span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),&#125;);</code></pre></div><p>  引入后之后，在你的每个 vue 组件实例上将多出$apollo 对象指向 apollo 客户端。</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$apollo</span> ===&gt;&#123;<span class="hljs-attr">query</span>:[....],&#125;</code></pre></div><p>  并且与 data 选项平行的 apollo 选择中可以自定义各种 gql 查询，并且他们的结果将作为 vue 变量来使用</p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;  <span class="hljs-keyword">return</span> &#123;    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>  &#125;&#125;,<span class="hljs-attr">apollo</span>:&#123;  <span class="hljs-attr">fetchB</span>:&#123;    <span class="hljs-attr">query</span>:...,    <span class="hljs-attr">variables</span>:...,    <span class="hljs-attr">fetchPolicy</span>:...,    ...各种apollo的api选项  &#125;&#125;</code></pre></div></li><li><h4 id="apollo-组件"><a href="#apollo-组件" class="headerlink" title="apollo 组件"></a>apollo 组件</h4><p>  在组件模版中编写 gql 查询，同时通过插槽<code>slot</code>分发请求结果,分别有<code>ApolloQuery</code>,<code>ApolloMutation</code>,<code>ApolloSubscribeToMore</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript">&lt;template&gt;  &lt;!-- <span class="hljs-title class_">Apollo</span> 查询 --&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ApolloQuery</span> <span class="hljs-attr">:query</span>=<span class="hljs-string">&quot;/* 一些查询 */&quot;</span>&gt;</span></span><span class="language-xml">    <span class="hljs-comment">&lt;!-- 结果将自动更新 --&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;&#123; result: &#123; data, loading &#125; &#125;&quot;</span>&gt;</span></span><span class="language-xml">      <span class="hljs-comment">&lt;!-- 一些内容 --&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loading&quot;</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-else</span>&gt;</span></span><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;user of data.users&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span></span><span class="language-xml">          &#123;&#123; user.name &#125;&#125;</span><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ApolloQuery</span>&gt;</span></span>&lt;/template&gt;</code></pre></div></li><li><h4 id="纯-api-封装"><a href="#纯-api-封装" class="headerlink" title="纯 api 封装"></a>纯 api 封装</h4><p>  基本上没有侵入性的使用方法，封装成函数式的 api，不需要在实例中插入<code>Apollo Provider</code>和<code>vue.use(vueApollo)</code></p>  <div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 伪代码</span><span class="hljs-keyword">import</span> apolloclient<span class="hljs-keyword">import</span> gql图表文件<span class="hljs-comment">// apollo请求基于promise</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">xxxapi</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">params</span>) =&gt; &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> $apollo.<span class="hljs-title function_">query</span>(&#123;    <span class="hljs-attr">query</span>:，    <span class="hljs-attr">variables</span>:&#123;&#125;,    fetchPolicy,    ...    ...各种参数  &#125;)&#125;</code></pre></div><p>  然后在你的 js 代码中引入,熟悉的味道熟悉的配方</p></li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>相较于<code>restful</code>少了大量处理数据的步骤，接口天然更加安全(参数类型参数数量对不上都会请求失败)，apollo 功能也是十分强大（轮询，分页，缓存），再回去用 restful 会有一种略难受的感觉。并且后端的同学也表示舒服。</p><p>之后打算在别的项目里陆续试一试智能查询和 apollo 组件，看看有没有耦合度低的接入方式或者复用的 apollo 组件。</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>graphql</tag>
      
      <tag>apollo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js设计模式</title>
    <link href="/2021/09/09/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/09/09/js%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://item.jd.com/11747684.html">javascript设计模式 张容铭</a></p><h2 id="创建性设计模式"><a href="#创建性设计模式" class="headerlink" title="创建性设计模式"></a>创建性设计模式</h2><ul><li><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><p>创建实例时，为了保证被new关键字正确调用，可在构造函数中加入对this指向的判断。</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Factory</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)&#123;  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Factory</span>)&#123;    ...    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">this</span>(args)  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory</span>(...args)  &#125;&#125;</code></pre></div></li><li><h3 id="简单工厂模式（静态工厂）"><a href="#简单工厂模式（静态工厂）" class="headerlink" title="简单工厂模式（静态工厂）"></a>简单工厂模式（静态工厂）</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建单独一类对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Factory</span>(<span class="hljs-params">name,age,gender</span>)&#123;  <span class="hljs-keyword">const</span> o = &#123;&#125;  o.<span class="hljs-property">name</span> = name  o.<span class="hljs-property">age</span> = age  o.<span class="hljs-property">gender</span> = gender  o.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;my name is&quot;</span>+  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)  &#125;  <span class="hljs-keyword">return</span> o&#125;</code></pre></div></li><li><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建多类对象</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">Factory</span>(<span class="hljs-params">...args</span>)&#123;    ...&#125;<span class="hljs-title class_">Factory</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-title class_">Product1</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">// 简单工厂</span>  &#125;,  <span class="hljs-title class_">Product2</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">//简单工厂</span>  &#125;&#125;</code></pre></div></li><li><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ul><li><code>抽象类</code>：没有任何属性，并且原形上的方法都被限制不能使用。</li><li>作用：假设子代都可能调用一些该类的必要方法，如果只是调用而不重写该方法，则会调用类上的被限制的版本而得到错误提示。<div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Car</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;  <span class="hljs-attr">getPrice</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;抽象方法不能调用&quot;</span>)  &#125;,  <span class="hljs-attr">getSpeed</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;抽象方法不能调用&quot;</span>)  &#125;&#125;</code></pre></div></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
